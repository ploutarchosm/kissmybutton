94c2e5981afc9306fa81f45b3d9ed225
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var platform_browser_exports = {};
__export(platform_browser_exports, {
  BrowserModule: () => BrowserModule,
  BrowserTransferStateModule: () => BrowserTransferStateModule,
  By: () => By,
  DomSanitizer: () => DomSanitizer,
  EVENT_MANAGER_PLUGINS: () => EVENT_MANAGER_PLUGINS,
  EventManager: () => EventManager,
  HAMMER_GESTURE_CONFIG: () => HAMMER_GESTURE_CONFIG,
  HAMMER_LOADER: () => HAMMER_LOADER,
  HammerGestureConfig: () => HammerGestureConfig,
  HammerModule: () => HammerModule,
  Meta: () => Meta,
  Title: () => Title,
  TransferState: () => TransferState,
  VERSION: () => VERSION,
  bootstrapApplication: () => bootstrapApplication,
  createApplication: () => createApplication,
  disableDebugTools: () => disableDebugTools,
  enableDebugTools: () => enableDebugTools,
  makeStateKey: () => makeStateKey,
  platformBrowser: () => platformBrowser,
  provideProtractorTestingSupport: () => provideProtractorTestingSupport,
  \u0275BrowserDomAdapter: () => BrowserDomAdapter,
  \u0275BrowserGetTestability: () => BrowserGetTestability,
  \u0275DomEventsPlugin: () => DomEventsPlugin,
  \u0275DomRendererFactory2: () => DomRendererFactory2,
  \u0275DomSanitizerImpl: () => DomSanitizerImpl,
  \u0275DomSharedStylesHost: () => DomSharedStylesHost,
  \u0275HammerGesturesPlugin: () => HammerGesturesPlugin,
  \u0275INTERNAL_BROWSER_PLATFORM_PROVIDERS: () => INTERNAL_BROWSER_PLATFORM_PROVIDERS,
  \u0275KeyEventsPlugin: () => KeyEventsPlugin,
  \u0275NAMESPACE_URIS: () => NAMESPACE_URIS,
  \u0275SharedStylesHost: () => SharedStylesHost,
  \u0275TRANSITION_ID: () => TRANSITION_ID,
  \u0275escapeHtml: () => escapeHtml,
  \u0275flattenStyles: () => flattenStyles,
  \u0275getDOM: () => import_common2.\u0275getDOM,
  \u0275initDomAdapter: () => initDomAdapter,
  \u0275shimContentAttribute: () => shimContentAttribute,
  \u0275shimHostAttribute: () => shimHostAttribute
});
module.exports = __toCommonJS(platform_browser_exports);
var import_common = require("@angular/common");
var import_common2 = require("@angular/common");
var i0 = __toESM(require("@angular/core"), 1);
var import_core = require("@angular/core");
/**
 * @license Angular v14.3.0
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class GenericBrowserDomAdapter extends import_common.\u0275DomAdapter {
  constructor() {
    super(...arguments);
    this.supportsDOMEvents = true;
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class BrowserDomAdapter extends GenericBrowserDomAdapter {
  static makeCurrent() {
    (0, import_common.\u0275setRootDomAdapter)(new BrowserDomAdapter());
  }
  onAndCancel(el, evt, listener) {
    el.addEventListener(evt, listener, false);
    return () => {
      el.removeEventListener(evt, listener, false);
    };
  }
  dispatchEvent(el, evt) {
    el.dispatchEvent(evt);
  }
  remove(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  createElement(tagName, doc) {
    doc = doc || this.getDefaultDocument();
    return doc.createElement(tagName);
  }
  createHtmlDocument() {
    return document.implementation.createHTMLDocument("fakeTitle");
  }
  getDefaultDocument() {
    return document;
  }
  isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
  }
  isShadowRoot(node) {
    return node instanceof DocumentFragment;
  }
  getGlobalEventTarget(doc, target) {
    if (target === "window") {
      return window;
    }
    if (target === "document") {
      return doc;
    }
    if (target === "body") {
      return doc.body;
    }
    return null;
  }
  getBaseHref(doc) {
    const href = getBaseElementHref();
    return href == null ? null : relativePath(href);
  }
  resetBaseElement() {
    baseElement = null;
  }
  getUserAgent() {
    return window.navigator.userAgent;
  }
  getCookie(name) {
    return (0, import_common.\u0275parseCookieValue)(document.cookie, name);
  }
}
let baseElement = null;
function getBaseElementHref() {
  baseElement = baseElement || document.querySelector("base");
  return baseElement ? baseElement.getAttribute("href") : null;
}
let urlParsingNode;
function relativePath(url) {
  urlParsingNode = urlParsingNode || document.createElement("a");
  urlParsingNode.setAttribute("href", url);
  const pathName = urlParsingNode.pathname;
  return pathName.charAt(0) === "/" ? pathName : `/${pathName}`;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const TRANSITION_ID = new import_core.InjectionToken("TRANSITION_ID");
function appInitializerFactory(transitionId, document2, injector) {
  return () => {
    injector.get(import_core.ApplicationInitStatus).donePromise.then(() => {
      const dom = (0, import_common.\u0275getDOM)();
      const styles = document2.querySelectorAll(`style[ng-transition="${transitionId}"]`);
      for (let i = 0; i < styles.length; i++) {
        dom.remove(styles[i]);
      }
    });
  };
}
const SERVER_TRANSITION_PROVIDERS = [
  {
    provide: import_core.APP_INITIALIZER,
    useFactory: appInitializerFactory,
    deps: [TRANSITION_ID, import_common.DOCUMENT, import_core.Injector],
    multi: true
  }
];
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class BrowserGetTestability {
  addToWindow(registry) {
    import_core.\u0275global["getAngularTestability"] = (elem, findInAncestors = true) => {
      const testability = registry.findTestabilityInTree(elem, findInAncestors);
      if (testability == null) {
        throw new Error("Could not find testability for element.");
      }
      return testability;
    };
    import_core.\u0275global["getAllAngularTestabilities"] = () => registry.getAllTestabilities();
    import_core.\u0275global["getAllAngularRootElements"] = () => registry.getAllRootElements();
    const whenAllStable = (callback) => {
      const testabilities = import_core.\u0275global["getAllAngularTestabilities"]();
      let count = testabilities.length;
      let didWork = false;
      const decrement = function(didWork_) {
        didWork = didWork || didWork_;
        count--;
        if (count == 0) {
          callback(didWork);
        }
      };
      testabilities.forEach(function(testability) {
        testability.whenStable(decrement);
      });
    };
    if (!import_core.\u0275global["frameworkStabilizers"]) {
      import_core.\u0275global["frameworkStabilizers"] = [];
    }
    import_core.\u0275global["frameworkStabilizers"].push(whenAllStable);
  }
  findTestabilityInTree(registry, elem, findInAncestors) {
    if (elem == null) {
      return null;
    }
    const t = registry.getTestability(elem);
    if (t != null) {
      return t;
    } else if (!findInAncestors) {
      return null;
    }
    if ((0, import_common.\u0275getDOM)().isShadowRoot(elem)) {
      return this.findTestabilityInTree(registry, elem.host, true);
    }
    return this.findTestabilityInTree(registry, elem.parentElement, true);
  }
}
class BrowserXhr {
  build() {
    return new XMLHttpRequest();
  }
}
BrowserXhr.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: BrowserXhr, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable });
BrowserXhr.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: BrowserXhr });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: BrowserXhr, decorators: [{
  type: import_core.Injectable
}] });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const EVENT_MANAGER_PLUGINS = new import_core.InjectionToken("EventManagerPlugins");
class EventManager {
  constructor(plugins, _zone) {
    this._zone = _zone;
    this._eventNameToPlugin = /* @__PURE__ */ new Map();
    plugins.forEach((p) => p.manager = this);
    this._plugins = plugins.slice().reverse();
  }
  addEventListener(element, eventName, handler) {
    const plugin = this._findPluginFor(eventName);
    return plugin.addEventListener(element, eventName, handler);
  }
  addGlobalEventListener(target, eventName, handler) {
    const plugin = this._findPluginFor(eventName);
    return plugin.addGlobalEventListener(target, eventName, handler);
  }
  getZone() {
    return this._zone;
  }
  _findPluginFor(eventName) {
    const plugin = this._eventNameToPlugin.get(eventName);
    if (plugin) {
      return plugin;
    }
    const plugins = this._plugins;
    for (let i = 0; i < plugins.length; i++) {
      const plugin2 = plugins[i];
      if (plugin2.supports(eventName)) {
        this._eventNameToPlugin.set(eventName, plugin2);
        return plugin2;
      }
    }
    throw new Error(`No event manager plugin found for event ${eventName}`);
  }
}
EventManager.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: EventManager, deps: [{ token: EVENT_MANAGER_PLUGINS }, { token: i0.NgZone }], target: i0.\u0275\u0275FactoryTarget.Injectable });
EventManager.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: EventManager });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: EventManager, decorators: [{
  type: import_core.Injectable
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: import_core.Inject,
    args: [EVENT_MANAGER_PLUGINS]
  }] }, { type: i0.NgZone }];
} });
class EventManagerPlugin {
  constructor(_doc) {
    this._doc = _doc;
  }
  addGlobalEventListener(element, eventName, handler) {
    const target = (0, import_common.\u0275getDOM)().getGlobalEventTarget(this._doc, element);
    if (!target) {
      throw new Error(`Unsupported event target ${target} for event ${eventName}`);
    }
    return this.addEventListener(target, eventName, handler);
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class SharedStylesHost {
  constructor() {
    this._stylesSet = /* @__PURE__ */ new Set();
  }
  addStyles(styles) {
    const additions = /* @__PURE__ */ new Set();
    styles.forEach((style) => {
      if (!this._stylesSet.has(style)) {
        this._stylesSet.add(style);
        additions.add(style);
      }
    });
    this.onStylesAdded(additions);
  }
  onStylesAdded(additions) {
  }
  getAllStyles() {
    return Array.from(this._stylesSet);
  }
}
SharedStylesHost.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: SharedStylesHost, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable });
SharedStylesHost.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: SharedStylesHost });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: SharedStylesHost, decorators: [{
  type: import_core.Injectable
}] });
class DomSharedStylesHost extends SharedStylesHost {
  constructor(_doc) {
    super();
    this._doc = _doc;
    this._hostNodes = /* @__PURE__ */ new Map();
    this._hostNodes.set(_doc.head, []);
  }
  _addStylesToHost(styles, host, styleNodes) {
    styles.forEach((style) => {
      const styleEl = this._doc.createElement("style");
      styleEl.textContent = style;
      styleNodes.push(host.appendChild(styleEl));
    });
  }
  addHost(hostNode) {
    const styleNodes = [];
    this._addStylesToHost(this._stylesSet, hostNode, styleNodes);
    this._hostNodes.set(hostNode, styleNodes);
  }
  removeHost(hostNode) {
    const styleNodes = this._hostNodes.get(hostNode);
    if (styleNodes) {
      styleNodes.forEach(removeStyle);
    }
    this._hostNodes.delete(hostNode);
  }
  onStylesAdded(additions) {
    this._hostNodes.forEach((styleNodes, hostNode) => {
      this._addStylesToHost(additions, hostNode, styleNodes);
    });
  }
  ngOnDestroy() {
    this._hostNodes.forEach((styleNodes) => styleNodes.forEach(removeStyle));
  }
}
DomSharedStylesHost.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomSharedStylesHost, deps: [{ token: import_common.DOCUMENT }], target: i0.\u0275\u0275FactoryTarget.Injectable });
DomSharedStylesHost.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomSharedStylesHost });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomSharedStylesHost, decorators: [{
  type: import_core.Injectable
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: import_core.Inject,
    args: [import_common.DOCUMENT]
  }] }];
} });
function removeStyle(styleNode) {
  (0, import_common.\u0275getDOM)().remove(styleNode);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NAMESPACE_URIS = {
  "svg": "http://www.w3.org/2000/svg",
  "xhtml": "http://www.w3.org/1999/xhtml",
  "xlink": "http://www.w3.org/1999/xlink",
  "xml": "http://www.w3.org/XML/1998/namespace",
  "xmlns": "http://www.w3.org/2000/xmlns/",
  "math": "http://www.w3.org/1998/MathML/"
};
const COMPONENT_REGEX = /%COMP%/g;
const NG_DEV_MODE$1 = typeof ngDevMode === "undefined" || !!ngDevMode;
const COMPONENT_VARIABLE = "%COMP%";
const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
function shimContentAttribute(componentShortId) {
  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimHostAttribute(componentShortId) {
  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function flattenStyles(compId, styles, target) {
  for (let i = 0; i < styles.length; i++) {
    let style = styles[i];
    if (Array.isArray(style)) {
      flattenStyles(compId, style, target);
    } else {
      style = style.replace(COMPONENT_REGEX, compId);
      target.push(style);
    }
  }
  return target;
}
function decoratePreventDefault(eventHandler) {
  return (event) => {
    if (event === "__ngUnwrap__") {
      return eventHandler;
    }
    const allowDefaultBehavior = eventHandler(event);
    if (allowDefaultBehavior === false) {
      event.preventDefault();
      event.returnValue = false;
    }
    return void 0;
  };
}
let hasLoggedNativeEncapsulationWarning = false;
class DomRendererFactory2 {
  constructor(eventManager, sharedStylesHost, appId) {
    this.eventManager = eventManager;
    this.sharedStylesHost = sharedStylesHost;
    this.appId = appId;
    this.rendererByCompId = /* @__PURE__ */ new Map();
    this.defaultRenderer = new DefaultDomRenderer2(eventManager);
  }
  createRenderer(element, type) {
    if (!element || !type) {
      return this.defaultRenderer;
    }
    switch (type.encapsulation) {
      case import_core.ViewEncapsulation.Emulated: {
        let renderer = this.rendererByCompId.get(type.id);
        if (!renderer) {
          renderer = new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type, this.appId);
          this.rendererByCompId.set(type.id, renderer);
        }
        renderer.applyToHost(element);
        return renderer;
      }
      case 1:
      case import_core.ViewEncapsulation.ShadowDom:
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !hasLoggedNativeEncapsulationWarning && type.encapsulation === 1) {
          hasLoggedNativeEncapsulationWarning = true;
          console.warn("ViewEncapsulation.Native is no longer supported. Falling back to ViewEncapsulation.ShadowDom. The fallback will be removed in v12.");
        }
        return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);
      default: {
        if (!this.rendererByCompId.has(type.id)) {
          const styles = flattenStyles(type.id, type.styles, []);
          this.sharedStylesHost.addStyles(styles);
          this.rendererByCompId.set(type.id, this.defaultRenderer);
        }
        return this.defaultRenderer;
      }
    }
  }
  begin() {
  }
  end() {
  }
}
DomRendererFactory2.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomRendererFactory2, deps: [{ token: EventManager }, { token: DomSharedStylesHost }, { token: import_core.APP_ID }], target: i0.\u0275\u0275FactoryTarget.Injectable });
DomRendererFactory2.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomRendererFactory2 });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomRendererFactory2, decorators: [{
  type: import_core.Injectable
}], ctorParameters: function() {
  return [{ type: EventManager }, { type: DomSharedStylesHost }, { type: void 0, decorators: [{
    type: import_core.Inject,
    args: [import_core.APP_ID]
  }] }];
} });
class DefaultDomRenderer2 {
  constructor(eventManager) {
    this.eventManager = eventManager;
    this.data = /* @__PURE__ */ Object.create(null);
    this.destroyNode = null;
  }
  destroy() {
  }
  createElement(name, namespace) {
    if (namespace) {
      return document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
    }
    return document.createElement(name);
  }
  createComment(value) {
    return document.createComment(value);
  }
  createText(value) {
    return document.createTextNode(value);
  }
  appendChild(parent, newChild) {
    const targetParent = isTemplateNode(parent) ? parent.content : parent;
    targetParent.appendChild(newChild);
  }
  insertBefore(parent, newChild, refChild) {
    if (parent) {
      const targetParent = isTemplateNode(parent) ? parent.content : parent;
      targetParent.insertBefore(newChild, refChild);
    }
  }
  removeChild(parent, oldChild) {
    if (parent) {
      parent.removeChild(oldChild);
    }
  }
  selectRootElement(selectorOrNode, preserveContent) {
    let el = typeof selectorOrNode === "string" ? document.querySelector(selectorOrNode) : selectorOrNode;
    if (!el) {
      throw new Error(`The selector "${selectorOrNode}" did not match any elements`);
    }
    if (!preserveContent) {
      el.textContent = "";
    }
    return el;
  }
  parentNode(node) {
    return node.parentNode;
  }
  nextSibling(node) {
    return node.nextSibling;
  }
  setAttribute(el, name, value, namespace) {
    if (namespace) {
      name = namespace + ":" + name;
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.setAttributeNS(namespaceUri, name, value);
      } else {
        el.setAttribute(name, value);
      }
    } else {
      el.setAttribute(name, value);
    }
  }
  removeAttribute(el, name, namespace) {
    if (namespace) {
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.removeAttributeNS(namespaceUri, name);
      } else {
        el.removeAttribute(`${namespace}:${name}`);
      }
    } else {
      el.removeAttribute(name);
    }
  }
  addClass(el, name) {
    el.classList.add(name);
  }
  removeClass(el, name) {
    el.classList.remove(name);
  }
  setStyle(el, style, value, flags) {
    if (flags & (import_core.RendererStyleFlags2.DashCase | import_core.RendererStyleFlags2.Important)) {
      el.style.setProperty(style, value, flags & import_core.RendererStyleFlags2.Important ? "important" : "");
    } else {
      el.style[style] = value;
    }
  }
  removeStyle(el, style, flags) {
    if (flags & import_core.RendererStyleFlags2.DashCase) {
      el.style.removeProperty(style);
    } else {
      el.style[style] = "";
    }
  }
  setProperty(el, name, value) {
    NG_DEV_MODE$1 && checkNoSyntheticProp(name, "property");
    el[name] = value;
  }
  setValue(node, value) {
    node.nodeValue = value;
  }
  listen(target, event, callback) {
    NG_DEV_MODE$1 && checkNoSyntheticProp(event, "listener");
    if (typeof target === "string") {
      return this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback));
    }
    return this.eventManager.addEventListener(target, event, decoratePreventDefault(callback));
  }
}
const AT_CHARCODE = (() => "@".charCodeAt(0))();
function checkNoSyntheticProp(name, nameKind) {
  if (name.charCodeAt(0) === AT_CHARCODE) {
    throw new Error(`Unexpected synthetic ${nameKind} ${name} found. Please make sure that:
  - Either \`BrowserAnimationsModule\` or \`NoopAnimationsModule\` are imported in your application.
  - There is corresponding configuration for the animation named \`${name}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.io/api/core/Component#animations).`);
  }
}
function isTemplateNode(node) {
  return node.tagName === "TEMPLATE" && node.content !== void 0;
}
class EmulatedEncapsulationDomRenderer2 extends DefaultDomRenderer2 {
  constructor(eventManager, sharedStylesHost, component, appId) {
    super(eventManager);
    this.component = component;
    const styles = flattenStyles(appId + "-" + component.id, component.styles, []);
    sharedStylesHost.addStyles(styles);
    this.contentAttr = shimContentAttribute(appId + "-" + component.id);
    this.hostAttr = shimHostAttribute(appId + "-" + component.id);
  }
  applyToHost(element) {
    super.setAttribute(element, this.hostAttr, "");
  }
  createElement(parent, name) {
    const el = super.createElement(parent, name);
    super.setAttribute(el, this.contentAttr, "");
    return el;
  }
}
class ShadowDomRenderer extends DefaultDomRenderer2 {
  constructor(eventManager, sharedStylesHost, hostEl, component) {
    super(eventManager);
    this.sharedStylesHost = sharedStylesHost;
    this.hostEl = hostEl;
    this.shadowRoot = hostEl.attachShadow({ mode: "open" });
    this.sharedStylesHost.addHost(this.shadowRoot);
    const styles = flattenStyles(component.id, component.styles, []);
    for (let i = 0; i < styles.length; i++) {
      const styleEl = document.createElement("style");
      styleEl.textContent = styles[i];
      this.shadowRoot.appendChild(styleEl);
    }
  }
  nodeOrShadowRoot(node) {
    return node === this.hostEl ? this.shadowRoot : node;
  }
  destroy() {
    this.sharedStylesHost.removeHost(this.shadowRoot);
  }
  appendChild(parent, newChild) {
    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
  }
  insertBefore(parent, newChild, refChild) {
    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
  }
  removeChild(parent, oldChild) {
    return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);
  }
  parentNode(node) {
    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class DomEventsPlugin extends EventManagerPlugin {
  constructor(doc) {
    super(doc);
  }
  supports(eventName) {
    return true;
  }
  addEventListener(element, eventName, handler) {
    element.addEventListener(eventName, handler, false);
    return () => this.removeEventListener(element, eventName, handler);
  }
  removeEventListener(target, eventName, callback) {
    return target.removeEventListener(eventName, callback);
  }
}
DomEventsPlugin.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomEventsPlugin, deps: [{ token: import_common.DOCUMENT }], target: i0.\u0275\u0275FactoryTarget.Injectable });
DomEventsPlugin.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomEventsPlugin });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomEventsPlugin, decorators: [{
  type: import_core.Injectable
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: import_core.Inject,
    args: [import_common.DOCUMENT]
  }] }];
} });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const MODIFIER_KEYS = ["alt", "control", "meta", "shift"];
const _keyMap = {
  "\b": "Backspace",
  "	": "Tab",
  "\x7F": "Delete",
  "\x1B": "Escape",
  "Del": "Delete",
  "Esc": "Escape",
  "Left": "ArrowLeft",
  "Right": "ArrowRight",
  "Up": "ArrowUp",
  "Down": "ArrowDown",
  "Menu": "ContextMenu",
  "Scroll": "ScrollLock",
  "Win": "OS"
};
const MODIFIER_KEY_GETTERS = {
  "alt": (event) => event.altKey,
  "control": (event) => event.ctrlKey,
  "meta": (event) => event.metaKey,
  "shift": (event) => event.shiftKey
};
class KeyEventsPlugin extends EventManagerPlugin {
  constructor(doc) {
    super(doc);
  }
  supports(eventName) {
    return KeyEventsPlugin.parseEventName(eventName) != null;
  }
  addEventListener(element, eventName, handler) {
    const parsedEvent = KeyEventsPlugin.parseEventName(eventName);
    const outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent["fullKey"], handler, this.manager.getZone());
    return this.manager.getZone().runOutsideAngular(() => {
      return (0, import_common.\u0275getDOM)().onAndCancel(element, parsedEvent["domEventName"], outsideHandler);
    });
  }
  static parseEventName(eventName) {
    const parts = eventName.toLowerCase().split(".");
    const domEventName = parts.shift();
    if (parts.length === 0 || !(domEventName === "keydown" || domEventName === "keyup")) {
      return null;
    }
    const key = KeyEventsPlugin._normalizeKey(parts.pop());
    let fullKey = "";
    let codeIX = parts.indexOf("code");
    if (codeIX > -1) {
      parts.splice(codeIX, 1);
      fullKey = "code.";
    }
    MODIFIER_KEYS.forEach((modifierName) => {
      const index = parts.indexOf(modifierName);
      if (index > -1) {
        parts.splice(index, 1);
        fullKey += modifierName + ".";
      }
    });
    fullKey += key;
    if (parts.length != 0 || key.length === 0) {
      return null;
    }
    const result = {};
    result["domEventName"] = domEventName;
    result["fullKey"] = fullKey;
    return result;
  }
  static matchEventFullKeyCode(event, fullKeyCode) {
    let keycode = _keyMap[event.key] || event.key;
    let key = "";
    if (fullKeyCode.indexOf("code.") > -1) {
      keycode = event.code;
      key = "code.";
    }
    if (keycode == null || !keycode)
      return false;
    keycode = keycode.toLowerCase();
    if (keycode === " ") {
      keycode = "space";
    } else if (keycode === ".") {
      keycode = "dot";
    }
    MODIFIER_KEYS.forEach((modifierName) => {
      if (modifierName !== keycode) {
        const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
        if (modifierGetter(event)) {
          key += modifierName + ".";
        }
      }
    });
    key += keycode;
    return key === fullKeyCode;
  }
  static eventCallback(fullKey, handler, zone) {
    return (event) => {
      if (KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {
        zone.runGuarded(() => handler(event));
      }
    };
  }
  static _normalizeKey(keyName) {
    switch (keyName) {
      case "esc":
        return "escape";
      default:
        return keyName;
    }
  }
}
KeyEventsPlugin.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: KeyEventsPlugin, deps: [{ token: import_common.DOCUMENT }], target: i0.\u0275\u0275FactoryTarget.Injectable });
KeyEventsPlugin.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: KeyEventsPlugin });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: KeyEventsPlugin, decorators: [{
  type: import_core.Injectable
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: import_core.Inject,
    args: [import_common.DOCUMENT]
  }] }];
} });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NG_DEV_MODE = typeof ngDevMode === "undefined" || !!ngDevMode;
function bootstrapApplication(rootComponent, options) {
  return (0, import_core.\u0275internalCreateApplication)(__spreadValues({ rootComponent }, createProvidersConfig(options)));
}
function createApplication(options) {
  return (0, import_core.\u0275internalCreateApplication)(createProvidersConfig(options));
}
function createProvidersConfig(options) {
  var _a;
  return {
    appProviders: [
      ...BROWSER_MODULE_PROVIDERS,
      ...(_a = options == null ? void 0 : options.providers) != null ? _a : []
    ],
    platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS
  };
}
function provideProtractorTestingSupport() {
  return [...TESTABILITY_PROVIDERS];
}
function initDomAdapter() {
  BrowserDomAdapter.makeCurrent();
}
function errorHandler() {
  return new import_core.ErrorHandler();
}
function _document() {
  (0, import_core.\u0275setDocument)(document);
  return document;
}
const INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
  { provide: import_core.PLATFORM_ID, useValue: import_common.\u0275PLATFORM_BROWSER_ID },
  { provide: import_core.PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },
  { provide: import_common.DOCUMENT, useFactory: _document, deps: [] }
];
const platformBrowser = (0, import_core.createPlatformFactory)(import_core.platformCore, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS);
const BROWSER_MODULE_PROVIDERS_MARKER = new import_core.InjectionToken(NG_DEV_MODE ? "BrowserModule Providers Marker" : "");
const TESTABILITY_PROVIDERS = [
  {
    provide: import_core.\u0275TESTABILITY_GETTER,
    useClass: BrowserGetTestability,
    deps: []
  },
  {
    provide: import_core.\u0275TESTABILITY,
    useClass: import_core.Testability,
    deps: [import_core.NgZone, import_core.TestabilityRegistry, import_core.\u0275TESTABILITY_GETTER]
  },
  {
    provide: import_core.Testability,
    useClass: import_core.Testability,
    deps: [import_core.NgZone, import_core.TestabilityRegistry, import_core.\u0275TESTABILITY_GETTER]
  }
];
const BROWSER_MODULE_PROVIDERS = [
  { provide: import_core.\u0275INJECTOR_SCOPE, useValue: "root" },
  { provide: import_core.ErrorHandler, useFactory: errorHandler, deps: [] },
  {
    provide: EVENT_MANAGER_PLUGINS,
    useClass: DomEventsPlugin,
    multi: true,
    deps: [import_common.DOCUMENT, import_core.NgZone, import_core.PLATFORM_ID]
  },
  { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true, deps: [import_common.DOCUMENT] },
  {
    provide: DomRendererFactory2,
    useClass: DomRendererFactory2,
    deps: [EventManager, DomSharedStylesHost, import_core.APP_ID]
  },
  { provide: import_core.RendererFactory2, useExisting: DomRendererFactory2 },
  { provide: SharedStylesHost, useExisting: DomSharedStylesHost },
  { provide: DomSharedStylesHost, useClass: DomSharedStylesHost, deps: [import_common.DOCUMENT] },
  { provide: EventManager, useClass: EventManager, deps: [EVENT_MANAGER_PLUGINS, import_core.NgZone] },
  { provide: import_common.XhrFactory, useClass: BrowserXhr, deps: [] },
  NG_DEV_MODE ? { provide: BROWSER_MODULE_PROVIDERS_MARKER, useValue: true } : []
];
class BrowserModule {
  constructor(providersAlreadyPresent) {
    if (NG_DEV_MODE && providersAlreadyPresent) {
      throw new Error(`Providers from the \`BrowserModule\` have already been loaded. If you need access to common directives such as NgIf and NgFor, import the \`CommonModule\` instead.`);
    }
  }
  static withServerTransition(params) {
    return {
      ngModule: BrowserModule,
      providers: [
        { provide: import_core.APP_ID, useValue: params.appId },
        { provide: TRANSITION_ID, useExisting: import_core.APP_ID },
        SERVER_TRANSITION_PROVIDERS
      ]
    };
  }
}
BrowserModule.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: BrowserModule, deps: [{ token: BROWSER_MODULE_PROVIDERS_MARKER, optional: true, skipSelf: true }], target: i0.\u0275\u0275FactoryTarget.NgModule });
BrowserModule.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "14.3.0", ngImport: i0, type: BrowserModule, exports: [import_common.CommonModule, import_core.ApplicationModule] });
BrowserModule.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: BrowserModule, providers: [
  ...BROWSER_MODULE_PROVIDERS,
  ...TESTABILITY_PROVIDERS
], imports: [import_common.CommonModule, import_core.ApplicationModule] });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: BrowserModule, decorators: [{
  type: import_core.NgModule,
  args: [{
    providers: [
      ...BROWSER_MODULE_PROVIDERS,
      ...TESTABILITY_PROVIDERS
    ],
    exports: [import_common.CommonModule, import_core.ApplicationModule]
  }]
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: import_core.Optional
  }, {
    type: import_core.SkipSelf
  }, {
    type: import_core.Inject,
    args: [BROWSER_MODULE_PROVIDERS_MARKER]
  }] }];
} });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function createMeta() {
  return new Meta((0, import_core.\u0275\u0275inject)(import_common.DOCUMENT));
}
class Meta {
  constructor(_doc) {
    this._doc = _doc;
    this._dom = (0, import_common.\u0275getDOM)();
  }
  addTag(tag, forceCreation = false) {
    if (!tag)
      return null;
    return this._getOrCreateElement(tag, forceCreation);
  }
  addTags(tags, forceCreation = false) {
    if (!tags)
      return [];
    return tags.reduce((result, tag) => {
      if (tag) {
        result.push(this._getOrCreateElement(tag, forceCreation));
      }
      return result;
    }, []);
  }
  getTag(attrSelector) {
    if (!attrSelector)
      return null;
    return this._doc.querySelector(`meta[${attrSelector}]`) || null;
  }
  getTags(attrSelector) {
    if (!attrSelector)
      return [];
    const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
    return list ? [].slice.call(list) : [];
  }
  updateTag(tag, selector) {
    if (!tag)
      return null;
    selector = selector || this._parseSelector(tag);
    const meta = this.getTag(selector);
    if (meta) {
      return this._setMetaElementAttributes(tag, meta);
    }
    return this._getOrCreateElement(tag, true);
  }
  removeTag(attrSelector) {
    this.removeTagElement(this.getTag(attrSelector));
  }
  removeTagElement(meta) {
    if (meta) {
      this._dom.remove(meta);
    }
  }
  _getOrCreateElement(meta, forceCreation = false) {
    if (!forceCreation) {
      const selector = this._parseSelector(meta);
      const elem = this.getTags(selector).filter((elem2) => this._containsAttributes(meta, elem2))[0];
      if (elem !== void 0)
        return elem;
    }
    const element = this._dom.createElement("meta");
    this._setMetaElementAttributes(meta, element);
    const head = this._doc.getElementsByTagName("head")[0];
    head.appendChild(element);
    return element;
  }
  _setMetaElementAttributes(tag, el) {
    Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
    return el;
  }
  _parseSelector(tag) {
    const attr = tag.name ? "name" : "property";
    return `${attr}="${tag[attr]}"`;
  }
  _containsAttributes(tag, elem) {
    return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
  }
  _getMetaKeyMap(prop) {
    return META_KEYS_MAP[prop] || prop;
  }
}
Meta.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Meta, deps: [{ token: import_common.DOCUMENT }], target: i0.\u0275\u0275FactoryTarget.Injectable });
Meta.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Meta, providedIn: "root", useFactory: createMeta, deps: [] });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Meta, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root", useFactory: createMeta, deps: [] }]
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: import_core.Inject,
    args: [import_common.DOCUMENT]
  }] }];
} });
const META_KEYS_MAP = {
  httpEquiv: "http-equiv"
};
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function createTitle() {
  return new Title((0, import_core.\u0275\u0275inject)(import_common.DOCUMENT));
}
class Title {
  constructor(_doc) {
    this._doc = _doc;
  }
  getTitle() {
    return this._doc.title;
  }
  setTitle(newTitle) {
    this._doc.title = newTitle || "";
  }
}
Title.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Title, deps: [{ token: import_common.DOCUMENT }], target: i0.\u0275\u0275FactoryTarget.Injectable });
Title.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Title, providedIn: "root", useFactory: createTitle, deps: [] });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Title, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root", useFactory: createTitle, deps: [] }]
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: import_core.Inject,
    args: [import_common.DOCUMENT]
  }] }];
} });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const CAMEL_CASE_REGEXP = /([A-Z])/g;
const DASH_CASE_REGEXP = /-([a-z])/g;
function camelCaseToDashCase(input) {
  return input.replace(CAMEL_CASE_REGEXP, (...m) => "-" + m[1].toLowerCase());
}
function dashCaseToCamelCase(input) {
  return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
}
function exportNgVar(name, value) {
  if (typeof COMPILED === "undefined" || !COMPILED) {
    const ng = import_core.\u0275global["ng"] = import_core.\u0275global["ng"] || {};
    ng[name] = value;
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const win = typeof window !== "undefined" && window || {};
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class ChangeDetectionPerfRecord {
  constructor(msPerTick, numTicks) {
    this.msPerTick = msPerTick;
    this.numTicks = numTicks;
  }
}
class AngularProfiler {
  constructor(ref) {
    this.appRef = ref.injector.get(import_core.ApplicationRef);
  }
  timeChangeDetection(config) {
    const record = config && config["record"];
    const profileName = "Change Detection";
    const isProfilerAvailable = win.console.profile != null;
    if (record && isProfilerAvailable) {
      win.console.profile(profileName);
    }
    const start = performanceNow();
    let numTicks = 0;
    while (numTicks < 5 || performanceNow() - start < 500) {
      this.appRef.tick();
      numTicks++;
    }
    const end = performanceNow();
    if (record && isProfilerAvailable) {
      win.console.profileEnd(profileName);
    }
    const msPerTick = (end - start) / numTicks;
    win.console.log(`ran ${numTicks} change detection cycles`);
    win.console.log(`${msPerTick.toFixed(2)} ms per check`);
    return new ChangeDetectionPerfRecord(msPerTick, numTicks);
  }
}
function performanceNow() {
  return win.performance && win.performance.now ? win.performance.now() : new Date().getTime();
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const PROFILER_GLOBAL_NAME = "profiler";
function enableDebugTools(ref) {
  exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));
  return ref;
}
function disableDebugTools() {
  exportNgVar(PROFILER_GLOBAL_NAME, null);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function escapeHtml(text) {
  const escapedText = {
    "&": "&a;",
    '"': "&q;",
    "'": "&s;",
    "<": "&l;",
    ">": "&g;"
  };
  return text.replace(/[&"'<>]/g, (s) => escapedText[s]);
}
function unescapeHtml(text) {
  const unescapedText = {
    "&a;": "&",
    "&q;": '"',
    "&s;": "'",
    "&l;": "<",
    "&g;": ">"
  };
  return text.replace(/&[^;]+;/g, (s) => unescapedText[s]);
}
function makeStateKey(key) {
  return key;
}
class TransferState {
  constructor() {
    this.store = {};
    this.onSerializeCallbacks = {};
  }
  get(key, defaultValue) {
    return this.store[key] !== void 0 ? this.store[key] : defaultValue;
  }
  set(key, value) {
    this.store[key] = value;
  }
  remove(key) {
    delete this.store[key];
  }
  hasKey(key) {
    return this.store.hasOwnProperty(key);
  }
  get isEmpty() {
    return Object.keys(this.store).length === 0;
  }
  onSerialize(key, callback) {
    this.onSerializeCallbacks[key] = callback;
  }
  toJson() {
    for (const key in this.onSerializeCallbacks) {
      if (this.onSerializeCallbacks.hasOwnProperty(key)) {
        try {
          this.store[key] = this.onSerializeCallbacks[key]();
        } catch (e) {
          console.warn("Exception in onSerialize callback: ", e);
        }
      }
    }
    return JSON.stringify(this.store);
  }
}
TransferState.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TransferState, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable });
TransferState.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TransferState, providedIn: "root", useFactory: () => {
  const doc = (0, import_core.inject)(import_common.DOCUMENT);
  const appId = (0, import_core.inject)(import_core.APP_ID);
  const state = new TransferState();
  state.store = retrieveTransferredState(doc, appId);
  return state;
} });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TransferState, decorators: [{
  type: import_core.Injectable,
  args: [{
    providedIn: "root",
    useFactory: () => {
      const doc = (0, import_core.inject)(import_common.DOCUMENT);
      const appId = (0, import_core.inject)(import_core.APP_ID);
      const state = new TransferState();
      state.store = retrieveTransferredState(doc, appId);
      return state;
    }
  }]
}] });
function retrieveTransferredState(doc, appId) {
  const script = doc.getElementById(appId + "-state");
  let initialState = {};
  if (script && script.textContent) {
    try {
      initialState = JSON.parse(unescapeHtml(script.textContent));
    } catch (e) {
      console.warn("Exception while restoring TransferState for app " + appId, e);
    }
  }
  return initialState;
}
class BrowserTransferStateModule {
}
BrowserTransferStateModule.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: BrowserTransferStateModule, deps: [], target: i0.\u0275\u0275FactoryTarget.NgModule });
BrowserTransferStateModule.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "14.3.0", ngImport: i0, type: BrowserTransferStateModule });
BrowserTransferStateModule.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: BrowserTransferStateModule });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: BrowserTransferStateModule, decorators: [{
  type: import_core.NgModule,
  args: [{}]
}] });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class By {
  static all() {
    return () => true;
  }
  static css(selector) {
    return (debugElement) => {
      return debugElement.nativeElement != null ? elementMatches(debugElement.nativeElement, selector) : false;
    };
  }
  static directive(type) {
    return (debugNode) => debugNode.providerTokens.indexOf(type) !== -1;
  }
}
function elementMatches(n, selector) {
  if ((0, import_common.\u0275getDOM)().isElementNode(n)) {
    return n.matches && n.matches(selector) || n.msMatchesSelector && n.msMatchesSelector(selector) || n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
  }
  return false;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const EVENT_NAMES = {
  "pan": true,
  "panstart": true,
  "panmove": true,
  "panend": true,
  "pancancel": true,
  "panleft": true,
  "panright": true,
  "panup": true,
  "pandown": true,
  "pinch": true,
  "pinchstart": true,
  "pinchmove": true,
  "pinchend": true,
  "pinchcancel": true,
  "pinchin": true,
  "pinchout": true,
  "press": true,
  "pressup": true,
  "rotate": true,
  "rotatestart": true,
  "rotatemove": true,
  "rotateend": true,
  "rotatecancel": true,
  "swipe": true,
  "swipeleft": true,
  "swiperight": true,
  "swipeup": true,
  "swipedown": true,
  "tap": true,
  "doubletap": true
};
const HAMMER_GESTURE_CONFIG = new import_core.InjectionToken("HammerGestureConfig");
const HAMMER_LOADER = new import_core.InjectionToken("HammerLoader");
class HammerGestureConfig {
  constructor() {
    this.events = [];
    this.overrides = {};
  }
  buildHammer(element) {
    const mc = new Hammer(element, this.options);
    mc.get("pinch").set({ enable: true });
    mc.get("rotate").set({ enable: true });
    for (const eventName in this.overrides) {
      mc.get(eventName).set(this.overrides[eventName]);
    }
    return mc;
  }
}
HammerGestureConfig.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: HammerGestureConfig, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable });
HammerGestureConfig.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: HammerGestureConfig });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: HammerGestureConfig, decorators: [{
  type: import_core.Injectable
}] });
class HammerGesturesPlugin extends EventManagerPlugin {
  constructor(doc, _config, console2, loader) {
    super(doc);
    this._config = _config;
    this.console = console2;
    this.loader = loader;
    this._loaderPromise = null;
  }
  supports(eventName) {
    if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
      return false;
    }
    if (!window.Hammer && !this.loader) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        this.console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);
      }
      return false;
    }
    return true;
  }
  addEventListener(element, eventName, handler) {
    const zone = this.manager.getZone();
    eventName = eventName.toLowerCase();
    if (!window.Hammer && this.loader) {
      this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());
      let cancelRegistration = false;
      let deregister = () => {
        cancelRegistration = true;
      };
      zone.runOutsideAngular(() => this._loaderPromise.then(() => {
        if (!window.Hammer) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            this.console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
          }
          deregister = () => {
          };
          return;
        }
        if (!cancelRegistration) {
          deregister = this.addEventListener(element, eventName, handler);
        }
      }).catch(() => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          this.console.warn(`The "${eventName}" event cannot be bound because the custom Hammer.JS loader failed.`);
        }
        deregister = () => {
        };
      }));
      return () => {
        deregister();
      };
    }
    return zone.runOutsideAngular(() => {
      const mc = this._config.buildHammer(element);
      const callback = function(eventObj) {
        zone.runGuarded(function() {
          handler(eventObj);
        });
      };
      mc.on(eventName, callback);
      return () => {
        mc.off(eventName, callback);
        if (typeof mc.destroy === "function") {
          mc.destroy();
        }
      };
    });
  }
  isCustomEvent(eventName) {
    return this._config.events.indexOf(eventName) > -1;
  }
}
HammerGesturesPlugin.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: HammerGesturesPlugin, deps: [{ token: import_common.DOCUMENT }, { token: HAMMER_GESTURE_CONFIG }, { token: i0.\u0275Console }, { token: HAMMER_LOADER, optional: true }], target: i0.\u0275\u0275FactoryTarget.Injectable });
HammerGesturesPlugin.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: HammerGesturesPlugin });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: HammerGesturesPlugin, decorators: [{
  type: import_core.Injectable
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: import_core.Inject,
    args: [import_common.DOCUMENT]
  }] }, { type: HammerGestureConfig, decorators: [{
    type: import_core.Inject,
    args: [HAMMER_GESTURE_CONFIG]
  }] }, { type: i0.\u0275Console }, { type: void 0, decorators: [{
    type: import_core.Optional
  }, {
    type: import_core.Inject,
    args: [HAMMER_LOADER]
  }] }];
} });
class HammerModule {
}
HammerModule.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: HammerModule, deps: [], target: i0.\u0275\u0275FactoryTarget.NgModule });
HammerModule.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "14.3.0", ngImport: i0, type: HammerModule });
HammerModule.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: HammerModule, providers: [
  {
    provide: EVENT_MANAGER_PLUGINS,
    useClass: HammerGesturesPlugin,
    multi: true,
    deps: [import_common.DOCUMENT, HAMMER_GESTURE_CONFIG, import_core.\u0275Console, [new import_core.Optional(), HAMMER_LOADER]]
  },
  { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig, deps: [] }
] });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: HammerModule, decorators: [{
  type: import_core.NgModule,
  args: [{
    providers: [
      {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: HammerGesturesPlugin,
        multi: true,
        deps: [import_common.DOCUMENT, HAMMER_GESTURE_CONFIG, import_core.\u0275Console, [new import_core.Optional(), HAMMER_LOADER]]
      },
      { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig, deps: [] }
    ]
  }]
}] });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class DomSanitizer {
}
DomSanitizer.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomSanitizer, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable });
DomSanitizer.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomSanitizer, providedIn: "root", useExisting: i0.forwardRef(function() {
  return DomSanitizerImpl;
}) });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomSanitizer, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root", useExisting: (0, import_core.forwardRef)(() => DomSanitizerImpl) }]
}] });
function domSanitizerImplFactory(injector) {
  return new DomSanitizerImpl(injector.get(import_common.DOCUMENT));
}
class DomSanitizerImpl extends DomSanitizer {
  constructor(_doc) {
    super();
    this._doc = _doc;
  }
  sanitize(ctx, value) {
    if (value == null)
      return null;
    switch (ctx) {
      case import_core.SecurityContext.NONE:
        return value;
      case import_core.SecurityContext.HTML:
        if ((0, import_core.\u0275allowSanitizationBypassAndThrow)(value, "HTML")) {
          return (0, import_core.\u0275unwrapSafeValue)(value);
        }
        return (0, import_core.\u0275_sanitizeHtml)(this._doc, String(value)).toString();
      case import_core.SecurityContext.STYLE:
        if ((0, import_core.\u0275allowSanitizationBypassAndThrow)(value, "Style")) {
          return (0, import_core.\u0275unwrapSafeValue)(value);
        }
        return value;
      case import_core.SecurityContext.SCRIPT:
        if ((0, import_core.\u0275allowSanitizationBypassAndThrow)(value, "Script")) {
          return (0, import_core.\u0275unwrapSafeValue)(value);
        }
        throw new Error("unsafe value used in a script context");
      case import_core.SecurityContext.URL:
        if ((0, import_core.\u0275allowSanitizationBypassAndThrow)(value, "URL")) {
          return (0, import_core.\u0275unwrapSafeValue)(value);
        }
        return (0, import_core.\u0275_sanitizeUrl)(String(value));
      case import_core.SecurityContext.RESOURCE_URL:
        if ((0, import_core.\u0275allowSanitizationBypassAndThrow)(value, "ResourceURL")) {
          return (0, import_core.\u0275unwrapSafeValue)(value);
        }
        throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");
      default:
        throw new Error(`Unexpected SecurityContext ${ctx} (see https://g.co/ng/security#xss)`);
    }
  }
  bypassSecurityTrustHtml(value) {
    return (0, import_core.\u0275bypassSanitizationTrustHtml)(value);
  }
  bypassSecurityTrustStyle(value) {
    return (0, import_core.\u0275bypassSanitizationTrustStyle)(value);
  }
  bypassSecurityTrustScript(value) {
    return (0, import_core.\u0275bypassSanitizationTrustScript)(value);
  }
  bypassSecurityTrustUrl(value) {
    return (0, import_core.\u0275bypassSanitizationTrustUrl)(value);
  }
  bypassSecurityTrustResourceUrl(value) {
    return (0, import_core.\u0275bypassSanitizationTrustResourceUrl)(value);
  }
}
DomSanitizerImpl.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomSanitizerImpl, deps: [{ token: import_common.DOCUMENT }], target: i0.\u0275\u0275FactoryTarget.Injectable });
DomSanitizerImpl.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomSanitizerImpl, providedIn: "root", useFactory: domSanitizerImplFactory, deps: [{ token: import_core.Injector }] });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DomSanitizerImpl, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root", useFactory: domSanitizerImplFactory, deps: [import_core.Injector] }]
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: import_core.Inject,
    args: [import_common.DOCUMENT]
  }] }];
} });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const VERSION = new import_core.Version("14.3.0");
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
