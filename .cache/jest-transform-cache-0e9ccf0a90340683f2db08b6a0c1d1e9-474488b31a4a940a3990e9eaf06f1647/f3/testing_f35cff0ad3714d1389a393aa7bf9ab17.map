{
  "version": 3,
  "sources": ["C:\\Users\\User\\Desktop\\kissmybutton\\node_modules\\@angular\\core\\fesm2020\\testing.mjs"],
  "sourcesContent": ["/**\n * @license Angular v14.3.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { getDebugNode as getDebugNode$1, RendererFactory2 as RendererFactory2$1, InjectionToken as InjectionToken$1, \u0275stringify, \u0275ReflectionCapabilities, Directive, Component, Pipe, NgModule, \u0275getInjectableDef, resolveForwardRef as resolveForwardRef$1, \u0275NG_COMP_DEF, \u0275Render3NgModuleRef, ApplicationInitStatus, LOCALE_ID as LOCALE_ID$1, \u0275DEFAULT_LOCALE_ID, \u0275setLocaleId, \u0275Render3ComponentFactory, \u0275compileComponent, \u0275NG_DIR_DEF, \u0275compileDirective, \u0275NG_PIPE_DEF, \u0275compilePipe, \u0275NG_MOD_DEF, \u0275transitiveScopesFor, \u0275patchComponentDefWithScope, \u0275NG_INJ_DEF, \u0275compileNgModuleDefs, NgZone, Compiler, COMPILER_OPTIONS, \u0275NgModuleFactory, ModuleWithComponentFactories, Injector as Injector$1, InjectFlags as InjectFlags$1, \u0275setAllowDuplicateNgModuleIdsForTest, \u0275resetCompiledComponents, \u0275setUnknownElementStrictMode as \u0275setUnknownElementStrictMode$1, \u0275setUnknownPropertyStrictMode as \u0275setUnknownPropertyStrictMode$1, \u0275getUnknownElementStrictMode as \u0275getUnknownElementStrictMode$1, \u0275getUnknownPropertyStrictMode as \u0275getUnknownPropertyStrictMode$1, \u0275flushModuleScopingQueueAsMuchAsPossible } from '@angular/core';\nimport { ResourceLoader } from '@angular/compiler';\nimport { Subject, Subscription } from 'rxjs';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\nfunction waitForAsync(fn) {\n    const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n    if (!_Zone) {\n        return function () {\n            return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js');\n        };\n    }\n    const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n    if (typeof asyncTest === 'function') {\n        return asyncTest(fn);\n    }\n    return function () {\n        return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' +\n            'Please make sure that your environment includes zone.js/testing');\n    };\n}\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\nfunction async(fn) {\n    return waitForAsync(fn);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nclass ComponentFixture {\n    constructor(componentRef, ngZone, _autoDetect) {\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        this._autoDetect = _autoDetect;\n        this._isStable = true;\n        this._isDestroyed = false;\n        this._resolve = null;\n        this._promise = null;\n        this._onUnstableSubscription = null;\n        this._onStableSubscription = null;\n        this._onMicrotaskEmptySubscription = null;\n        this._onErrorSubscription = null;\n        this.changeDetectorRef = componentRef.changeDetectorRef;\n        this.elementRef = componentRef.location;\n        this.debugElement = getDebugNode$1(this.elementRef.nativeElement);\n        this.componentInstance = componentRef.instance;\n        this.nativeElement = this.elementRef.nativeElement;\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        if (ngZone) {\n            // Create subscriptions outside the NgZone so that the callbacks run oustide\n            // of NgZone.\n            ngZone.runOutsideAngular(() => {\n                this._onUnstableSubscription = ngZone.onUnstable.subscribe({\n                    next: () => {\n                        this._isStable = false;\n                    }\n                });\n                this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n                    next: () => {\n                        if (this._autoDetect) {\n                            // Do a change detection run with checkNoChanges set to true to check\n                            // there are no changes on the second run.\n                            this.detectChanges(true);\n                        }\n                    }\n                });\n                this._onStableSubscription = ngZone.onStable.subscribe({\n                    next: () => {\n                        this._isStable = true;\n                        // Check whether there is a pending whenStable() completer to resolve.\n                        if (this._promise !== null) {\n                            // If so check whether there are no pending macrotasks before resolving.\n                            // Do this check in the next tick so that ngZone gets a chance to update the state of\n                            // pending macrotasks.\n                            scheduleMicroTask(() => {\n                                if (!ngZone.hasPendingMacrotasks) {\n                                    if (this._promise !== null) {\n                                        this._resolve(true);\n                                        this._resolve = null;\n                                        this._promise = null;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                });\n                this._onErrorSubscription = ngZone.onError.subscribe({\n                    next: (error) => {\n                        throw error;\n                    }\n                });\n            });\n        }\n    }\n    _tick(checkNoChanges) {\n        this.changeDetectorRef.detectChanges();\n        if (checkNoChanges) {\n            this.checkNoChanges();\n        }\n    }\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n    detectChanges(checkNoChanges = true) {\n        if (this.ngZone != null) {\n            // Run the change detection inside the NgZone so that any async tasks as part of the change\n            // detection are captured by the zone and can be waited for in isStable.\n            this.ngZone.run(() => {\n                this._tick(checkNoChanges);\n            });\n        }\n        else {\n            // Running without zone. Just do the change detection.\n            this._tick(checkNoChanges);\n        }\n    }\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n    checkNoChanges() {\n        this.changeDetectorRef.checkNoChanges();\n    }\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     */\n    autoDetectChanges(autoDetect = true) {\n        if (this.ngZone == null) {\n            throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n        }\n        this._autoDetect = autoDetect;\n        this.detectChanges();\n    }\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n    isStable() {\n        return this._isStable && !this.ngZone.hasPendingMacrotasks;\n    }\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n    whenStable() {\n        if (this.isStable()) {\n            return Promise.resolve(false);\n        }\n        else if (this._promise !== null) {\n            return this._promise;\n        }\n        else {\n            this._promise = new Promise(res => {\n                this._resolve = res;\n            });\n            return this._promise;\n        }\n    }\n    _getRenderer() {\n        if (this._renderer === undefined) {\n            this._renderer = this.componentRef.injector.get(RendererFactory2$1, null);\n        }\n        return this._renderer;\n    }\n    /**\n     * Get a promise that resolves when the ui state is stable following animations.\n     */\n    whenRenderingDone() {\n        const renderer = this._getRenderer();\n        if (renderer && renderer.whenRenderingDone) {\n            return renderer.whenRenderingDone();\n        }\n        return this.whenStable();\n    }\n    /**\n     * Trigger component destruction.\n     */\n    destroy() {\n        if (!this._isDestroyed) {\n            this.componentRef.destroy();\n            if (this._onUnstableSubscription != null) {\n                this._onUnstableSubscription.unsubscribe();\n                this._onUnstableSubscription = null;\n            }\n            if (this._onStableSubscription != null) {\n                this._onStableSubscription.unsubscribe();\n                this._onStableSubscription = null;\n            }\n            if (this._onMicrotaskEmptySubscription != null) {\n                this._onMicrotaskEmptySubscription.unsubscribe();\n                this._onMicrotaskEmptySubscription = null;\n            }\n            if (this._onErrorSubscription != null) {\n                this._onErrorSubscription.unsubscribe();\n                this._onErrorSubscription = null;\n            }\n            this._isDestroyed = true;\n        }\n    }\n}\nfunction scheduleMicroTask(fn) {\n    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\nconst fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\nconst fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nfunction resetFakeAsyncZone() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.resetFakeAsyncZone();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception is thrown.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAysnc` zone.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\nfunction fakeAsync(fn) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.fakeAsync(fn);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\nfunction tick(millis = 0, tickOptions = {\n    processNewMacroTasksSynchronously: true\n}) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.tick(millis, tickOptions);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\n * the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\nfunction flush(maxTurns) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flush(maxTurns);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nfunction discardPeriodicTasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.discardPeriodicTasks();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nfunction flushMicrotasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flushMicrotasks();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Whether test modules should be torn down by default. */\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n/** Whether unknown elements in templates should throw by default. */\nconst THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\n/** Whether unknown properties in templates should throw by default. */\nconst THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nclass TestComponentRenderer {\n    insertRootElement(rootElementId) { }\n    removeAllRootElements() { }\n}\n/**\n * @publicApi\n */\nconst ComponentFixtureAutoDetect = new InjectionToken$1('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\nconst ComponentFixtureNoNgZone = new InjectionToken$1('ComponentFixtureNoNgZone');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\nfunction resolveComponentResources(resourceResolver) {\n    // Store all promises which are fetching the resources.\n    const componentResolved = [];\n    // Cache so that we don't fetch the same resource more than once.\n    const urlMap = new Map();\n    function cachedResourceResolve(url) {\n        let promise = urlMap.get(url);\n        if (!promise) {\n            const resp = resourceResolver(url);\n            urlMap.set(url, promise = resp.then(unwrapResponse));\n        }\n        return promise;\n    }\n    componentResourceResolutionQueue.forEach((component, type) => {\n        const promises = [];\n        if (component.templateUrl) {\n            promises.push(cachedResourceResolve(component.templateUrl).then((template) => {\n                component.template = template;\n            }));\n        }\n        const styleUrls = component.styleUrls;\n        const styles = component.styles || (component.styles = []);\n        const styleOffset = component.styles.length;\n        styleUrls && styleUrls.forEach((styleUrl, index) => {\n            styles.push(''); // pre-allocate array.\n            promises.push(cachedResourceResolve(styleUrl).then((style) => {\n                styles[styleOffset + index] = style;\n                styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n                if (styleUrls.length == 0) {\n                    component.styleUrls = undefined;\n                }\n            }));\n        });\n        const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));\n        componentResolved.push(fullyResolved);\n    });\n    clearResolutionOfComponentResourcesQueue();\n    return Promise.all(componentResolved).then(() => undefined);\n}\nlet componentResourceResolutionQueue = new Map();\n// Track when existing \u0275cmp for a Type is waiting on resources.\nconst componentDefPendingResolution = new Set();\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\n    if (componentNeedsResolution(metadata)) {\n        componentResourceResolutionQueue.set(type, metadata);\n        componentDefPendingResolution.add(type);\n    }\n}\nfunction isComponentDefPendingResolution(type) {\n    return componentDefPendingResolution.has(type);\n}\nfunction componentNeedsResolution(component) {\n    return !!((component.templateUrl && !component.hasOwnProperty('template')) ||\n        component.styleUrls && component.styleUrls.length);\n}\nfunction clearResolutionOfComponentResourcesQueue() {\n    const old = componentResourceResolutionQueue;\n    componentResourceResolutionQueue = new Map();\n    return old;\n}\nfunction restoreComponentResolutionQueue(queue) {\n    componentDefPendingResolution.clear();\n    queue.forEach((_, type) => componentDefPendingResolution.add(type));\n    componentResourceResolutionQueue = queue;\n}\nfunction isComponentResourceResolutionQueueEmpty() {\n    return componentResourceResolutionQueue.size === 0;\n}\nfunction unwrapResponse(response) {\n    return typeof response == 'string' ? response : response.text();\n}\nfunction componentDefResolved(type) {\n    componentDefPendingResolution.delete(type);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Always use __globalThis if available, which is the spec-defined global variable across all\n// environments, then fallback to __global first, because in Node tests both __global and\n// __window may be defined and _global should be __global in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\nconst _global$1 = ( /* @__PURE__ */(() => (typeof globalThis !== 'undefined' && globalThis) ||\n    (typeof global !== 'undefined' && global) || (typeof window !== 'undefined' && window) ||\n    (typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n        self instanceof WorkerGlobalScope && self))());\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar FactoryTarget;\n(function (FactoryTarget) {\n    FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n    FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n    FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n    FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n    FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget || (FactoryTarget = {}));\nvar R3TemplateDependencyKind;\n(function (R3TemplateDependencyKind) {\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));\nvar ViewEncapsulation$1;\n(function (ViewEncapsulation) {\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n    // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction getCompilerFacade(request) {\n    const globalNg = _global$1['ng'];\n    if (globalNg && globalNg.\u0275compilerFacade) {\n        return globalNg.\u0275compilerFacade;\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        // Log the type as an error so that a developer can easily navigate to the type from the\n        // console.\n        console.error(`JIT compilation failed for ${request.kind}`, request.type);\n        let message = `The ${request.kind} '${request\n            .type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\\n\\n`;\n        if (request.usage === 1 /* JitCompilerUsage.PartialDeclaration */) {\n            message += `The ${request.kind} is part of a library that has been partially compiled.\\n`;\n            message +=\n                `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\\n`;\n            message += '\\n';\n            message +=\n                `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\\n`;\n        }\n        else {\n            message +=\n                `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\\n`;\n        }\n        message +=\n            `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\\n`;\n        message +=\n            `or manually provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.`;\n        throw new Error(message);\n    }\n    else {\n        throw new Error('JIT compiler unavailable');\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction getClosureSafeProperty(objWithPropertyToExtract) {\n    for (let key in objWithPropertyToExtract) {\n        if (objWithPropertyToExtract[key] === getClosureSafeProperty) {\n            return key;\n        }\n    }\n    throw Error('Could not find renamed property on target object.');\n}\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nfunction fillProperties(target, source) {\n    for (const key in source) {\n        if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n            target[key] = source[key];\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction stringify(token) {\n    if (typeof token === 'string') {\n        return token;\n    }\n    if (Array.isArray(token)) {\n        return '[' + token.map(stringify).join(', ') + ']';\n    }\n    if (token == null) {\n        return '' + token;\n    }\n    if (token.overriddenName) {\n        return `${token.overriddenName}`;\n    }\n    if (token.name) {\n        return `${token.name}`;\n    }\n    const res = token.toString();\n    if (res == null) {\n        return '' + res;\n    }\n    const newLineIndex = res.indexOf('\\n');\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n/**\n * Concatenates two strings with separator, allocating new strings only when necessary.\n *\n * @param before before string.\n * @param separator separator string.\n * @param after after string.\n * @returns concatenated string.\n */\nfunction concatStringsWithSpace(before, after) {\n    return (before == null || before === '') ?\n        (after === null ? '' : after) :\n        ((after == null || after === '') ? before : before + ' ' + after);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * @usageNotes\n * ### Example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n * @publicApi\n */\nfunction forwardRef(forwardRefFn) {\n    forwardRefFn.__forward_ref__ = forwardRef;\n    forwardRefFn.toString = function () {\n        return stringify(this());\n    };\n    return forwardRefFn;\n}\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see `forwardRef`\n * @publicApi\n */\nfunction resolveForwardRef(type) {\n    return isForwardRef(type) ? type() : type;\n}\n/** Checks whether a function is wrapped by a `forwardRef`. */\nfunction isForwardRef(fn) {\n    return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) &&\n        fn.__forward_ref__ === forwardRef;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Construct an injectable definition which defines how a token will be constructed by the DI\n * system, and in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `\u0275prov` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call `inject` to access the `Injector` and request injection of dependencies.\n *\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nfunction \u0275\u0275defineInjectable(opts) {\n    return {\n        token: opts.token,\n        providedIn: opts.providedIn || null,\n        factory: opts.factory,\n        value: undefined,\n    };\n}\n/**\n * @deprecated in v8, delete after v10. This API should be used only by generated code, and that\n * code should now use \u0275\u0275defineInjectable instead.\n * @publicApi\n */\nconst defineInjectable = \u0275\u0275defineInjectable;\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static injector def (`\u0275inj`) field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has a `\u0275prov` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275defineInjector(options) {\n    return { providers: options.providers || [], imports: options.imports || [] };\n}\n/**\n * Read the injectable def (`\u0275prov`) for `type` in a way which is immune to accidentally reading\n * inherited value.\n *\n * @param type A type which may have its own (non-inherited) `\u0275prov`.\n */\nfunction getInjectableDef(type) {\n    return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);\n}\nfunction isInjectable(type) {\n    return getInjectableDef(type) !== null;\n}\n/**\n * Return definition only if it is defined directly on `type` and is not inherited from a base\n * class of `type`.\n */\nfunction getOwnDefinition(type, field) {\n    return type.hasOwnProperty(field) ? type[field] : null;\n}\n/**\n * Read the injectable def (`\u0275prov`) for `type` or read the `\u0275prov` from one of its ancestors.\n *\n * @param type A type which may have `\u0275prov`, via inheritance.\n *\n * @deprecated Will be removed in a future version of Angular, where an error will occur in the\n *     scenario if we find the `\u0275prov` on an ancestor only.\n */\nfunction getInheritedInjectableDef(type) {\n    const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);\n    if (def) {\n        const typeName = getTypeName(type);\n        // TODO(FW-1307): Re-add ngDevMode when closure can handle it\n        // ngDevMode &&\n        console.warn(`DEPRECATED: DI is instantiating a token \"${typeName}\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\n            `This will become an error in a future version of Angular. Please add @Injectable() to the \"${typeName}\" class.`);\n        return def;\n    }\n    else {\n        return null;\n    }\n}\n/** Gets the name of a type, accounting for some cross-browser differences. */\nfunction getTypeName(type) {\n    // `Function.prototype.name` behaves differently between IE and other browsers. In most browsers\n    // it'll always return the name of the function itself, no matter how many other functions it\n    // inherits from. On IE the function doesn't have its own `name` property, but it takes it from\n    // the lowest level in the prototype chain. E.g. if we have `class Foo extends Parent` most\n    // browsers will evaluate `Foo.name` to `Foo` while IE will return `Parent`. We work around\n    // the issue by converting the function to a string and parsing its name out that way via a regex.\n    if (type.hasOwnProperty('name')) {\n        return type.name;\n    }\n    const match = ('' + type).match(/^function\\s*([^\\s(]+)/);\n    return match === null ? '' : match[1];\n}\n/**\n * Read the injector def type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have an injector def (`\u0275inj`)\n */\nfunction getInjectorDef(type) {\n    return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ?\n        type[NG_INJ_DEF] :\n        null;\n}\nconst NG_PROV_DEF = getClosureSafeProperty({ \u0275prov: getClosureSafeProperty });\nconst NG_INJ_DEF = getClosureSafeProperty({ \u0275inj: getClosureSafeProperty });\n// We need to keep these around so we can read off old defs if new defs are unavailable\nconst NG_INJECTABLE_DEF = getClosureSafeProperty({ ngInjectableDef: getClosureSafeProperty });\nconst NG_INJECTOR_DEF = getClosureSafeProperty({ ngInjectorDef: getClosureSafeProperty });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Base URL for the error details page.\n *\n * Keep the files below in full sync:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime logic.\n */\nclass RuntimeError extends Error {\n    constructor(code, message) {\n        super(formatRuntimeError(code, message));\n        this.code = code;\n    }\n}\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nfunction formatRuntimeError(code, message) {\n    // Error code might be a negative number, which is a special marker that instructs the logic to\n    // generate a link to the error details page on angular.io.\n    const fullCode = `NG0${Math.abs(code)}`;\n    let errorMessage = `${fullCode}${message ? ': ' + message.trim() : ''}`;\n    if (ngDevMode && code < 0) {\n        const addPeriodSeparator = !errorMessage.match(/[.,;!?]$/);\n        const separator = addPeriodSeparator ? '.' : '';\n        errorMessage =\n            `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n    }\n    return errorMessage;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @description\n *\n * Represents a type that a Component or other object is instances of.\n *\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is represented by\n * the `MyCustomComponent` constructor function.\n *\n * @publicApi\n */\nconst Type = Function;\nfunction isType(v) {\n    return typeof v === 'function';\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction assertNumber(actual, msg) {\n    if (!(typeof actual === 'number')) {\n        throwError(msg, typeof actual, 'number', '===');\n    }\n}\nfunction assertNumberInRange(actual, minInclusive, maxInclusive) {\n    assertNumber(actual, 'Expected a number');\n    assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');\n    assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');\n}\nfunction assertString(actual, msg) {\n    if (!(typeof actual === 'string')) {\n        throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');\n    }\n}\nfunction assertFunction(actual, msg) {\n    if (!(typeof actual === 'function')) {\n        throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');\n    }\n}\nfunction assertEqual(actual, expected, msg) {\n    if (!(actual == expected)) {\n        throwError(msg, actual, expected, '==');\n    }\n}\nfunction assertNotEqual(actual, expected, msg) {\n    if (!(actual != expected)) {\n        throwError(msg, actual, expected, '!=');\n    }\n}\nfunction assertSame(actual, expected, msg) {\n    if (!(actual === expected)) {\n        throwError(msg, actual, expected, '===');\n    }\n}\nfunction assertNotSame(actual, expected, msg) {\n    if (!(actual !== expected)) {\n        throwError(msg, actual, expected, '!==');\n    }\n}\nfunction assertLessThan(actual, expected, msg) {\n    if (!(actual < expected)) {\n        throwError(msg, actual, expected, '<');\n    }\n}\nfunction assertLessThanOrEqual(actual, expected, msg) {\n    if (!(actual <= expected)) {\n        throwError(msg, actual, expected, '<=');\n    }\n}\nfunction assertGreaterThan(actual, expected, msg) {\n    if (!(actual > expected)) {\n        throwError(msg, actual, expected, '>');\n    }\n}\nfunction assertGreaterThanOrEqual(actual, expected, msg) {\n    if (!(actual >= expected)) {\n        throwError(msg, actual, expected, '>=');\n    }\n}\nfunction assertNotDefined(actual, msg) {\n    if (actual != null) {\n        throwError(msg, actual, null, '==');\n    }\n}\nfunction assertDefined(actual, msg) {\n    if (actual == null) {\n        throwError(msg, actual, null, '!=');\n    }\n}\nfunction throwError(msg, actual, expected, comparison) {\n    throw new Error(`ASSERTION ERROR: ${msg}` +\n        (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));\n}\nfunction assertDomNode(node) {\n    // If we're in a worker, `Node` will not be defined.\n    if (!(typeof Node !== 'undefined' && node instanceof Node) &&\n        !(typeof node === 'object' && node != null &&\n            node.constructor.name === 'WebWorkerRenderNode')) {\n        throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n    }\n}\nfunction assertIndexInRange(arr, index) {\n    assertDefined(arr, 'Array must be defined.');\n    const maxLen = arr.length;\n    if (index < 0 || index >= maxLen) {\n        throwError(`Index expected to be less than ${maxLen} but got ${index}`);\n    }\n}\nfunction assertOneOf(value, ...validValues) {\n    if (validValues.indexOf(value) !== -1)\n        return true;\n    throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Equivalent to ES6 spread, add each item to an array.\n *\n * @param items The items to add\n * @param arr The array to which you want to add the items\n */\nfunction addAllToArray(items, arr) {\n    for (let i = 0; i < items.length; i++) {\n        arr.push(items[i]);\n    }\n}\n/**\n * Determines if the contents of two arrays is identical\n *\n * @param a first array\n * @param b second array\n * @param identityAccessor Optional function for extracting stable object identity from a value in\n *     the array.\n */\nfunction arrayEquals(a, b, identityAccessor) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++) {\n        let valueA = a[i];\n        let valueB = b[i];\n        if (identityAccessor) {\n            valueA = identityAccessor(valueA);\n            valueB = identityAccessor(valueB);\n        }\n        if (valueB !== valueA) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Flattens an array.\n */\nfunction flatten$1(list, dst) {\n    if (dst === undefined)\n        dst = list;\n    for (let i = 0; i < list.length; i++) {\n        let item = list[i];\n        if (Array.isArray(item)) {\n            // we need to inline it.\n            if (dst === list) {\n                // Our assumption that the list was already flat was wrong and\n                // we need to clone flat since we need to write to it.\n                dst = list.slice(0, i);\n            }\n            flatten$1(item, dst);\n        }\n        else if (dst !== list) {\n            dst.push(item);\n        }\n    }\n    return dst;\n}\nfunction deepForEach(input, fn) {\n    input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\nfunction addToArray(arr, index, value) {\n    // perf: array.push is faster than array.splice!\n    if (index >= arr.length) {\n        arr.push(value);\n    }\n    else {\n        arr.splice(index, 0, value);\n    }\n}\nfunction removeFromArray(arr, index) {\n    // perf: array.pop is faster than array.splice!\n    if (index >= arr.length - 1) {\n        return arr.pop();\n    }\n    else {\n        return arr.splice(index, 1)[0];\n    }\n}\nfunction newArray(size, value) {\n    const list = [];\n    for (let i = 0; i < size; i++) {\n        list.push(value);\n    }\n    return list;\n}\n/**\n * Remove item from array (Same as `Array.splice()` but faster.)\n *\n * `Array.splice()` is not as fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * https://jsperf.com/fast-array-splice (About 20x faster)\n *\n * @param array Array to splice\n * @param index Index of element in array to remove.\n * @param count Number of items to remove.\n */\nfunction arraySplice(array, index, count) {\n    const length = array.length - count;\n    while (index < length) {\n        array[index] = array[index + count];\n        index++;\n    }\n    while (count--) {\n        array.pop(); // shrink the array\n    }\n}\n/**\n * Same as `Array.splice(index, 0, value)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value Value to add to array.\n */\nfunction arrayInsert(array, index, value) {\n    ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n    let end = array.length;\n    while (end > index) {\n        const previousEnd = end - 1;\n        array[end] = array[previousEnd];\n        end = previousEnd;\n    }\n    array[index] = value;\n}\n/**\n * Same as `Array.splice2(index, 0, value1, value2)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value1 Value to add to array.\n * @param value2 Value to add to array.\n */\nfunction arrayInsert2(array, index, value1, value2) {\n    ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n    let end = array.length;\n    if (end == index) {\n        // inserting at the end.\n        array.push(value1, value2);\n    }\n    else if (end === 1) {\n        // corner case when we have less items in array than we have items to insert.\n        array.push(value2, array[0]);\n        array[0] = value1;\n    }\n    else {\n        end--;\n        array.push(array[end - 1], array[end]);\n        while (end > index) {\n            const previousEnd = end - 2;\n            array[end] = array[previousEnd];\n            end--;\n        }\n        array[index] = value1;\n        array[index + 1] = value2;\n    }\n}\n/**\n * Insert a `value` into an `array` so that the array remains sorted.\n *\n * NOTE:\n * - Duplicates are not allowed, and are ignored.\n * - This uses binary search algorithm for fast inserts.\n *\n * @param array A sorted array to insert into.\n * @param value The value to insert.\n * @returns index of the inserted value.\n */\nfunction arrayInsertSorted(array, value) {\n    let index = arrayIndexOfSorted(array, value);\n    if (index < 0) {\n        // if we did not find it insert it.\n        index = ~index;\n        arrayInsert(array, index, value);\n    }\n    return index;\n}\n/**\n * Remove `value` from a sorted `array`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to remove from.\n * @param value The value to remove.\n * @returns index of the removed value.\n *   - positive index if value found and removed.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n *     inserted)\n */\nfunction arrayRemoveSorted(array, value) {\n    const index = arrayIndexOfSorted(array, value);\n    if (index >= 0) {\n        arraySplice(array, index, 1);\n    }\n    return index;\n}\n/**\n * Get an index of an `value` in a sorted `array`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n *     located)\n */\nfunction arrayIndexOfSorted(array, value) {\n    return _arrayIndexOfSorted(array, value, 0);\n}\n/**\n * Set a `value` for a `key`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or create.\n * @param value The value to set for a `key`.\n * @returns index (always even) of where the value vas set.\n */\nfunction keyValueArraySet(keyValueArray, key, value) {\n    let index = keyValueArrayIndexOf(keyValueArray, key);\n    if (index >= 0) {\n        // if we found it set it.\n        keyValueArray[index | 1] = value;\n    }\n    else {\n        index = ~index;\n        arrayInsert2(keyValueArray, index, key, value);\n    }\n    return index;\n}\n/**\n * Retrieve a `value` for a `key` (on `undefined` if not found.)\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @return The `value` stored at the `key` location or `undefined if not found.\n */\nfunction keyValueArrayGet(keyValueArray, key) {\n    const index = keyValueArrayIndexOf(keyValueArray, key);\n    if (index >= 0) {\n        // if we found it retrieve it.\n        return keyValueArray[index | 1];\n    }\n    return undefined;\n}\n/**\n * Retrieve a `key` index value in the array or `-1` if not found.\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @returns index of where the key is (or should have been.)\n *   - positive (even) index if key found.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been inserted.)\n */\nfunction keyValueArrayIndexOf(keyValueArray, key) {\n    return _arrayIndexOfSorted(keyValueArray, key, 1);\n}\n/**\n * Delete a `key` (and `value`) from the `KeyValueArray`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or delete (if exist).\n * @returns index of where the key was (or should have been.)\n *   - positive (even) index if key found and deleted.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been.)\n */\nfunction keyValueArrayDelete(keyValueArray, key) {\n    const index = keyValueArrayIndexOf(keyValueArray, key);\n    if (index >= 0) {\n        // if we found it remove it.\n        arraySplice(keyValueArray, index, 2);\n    }\n    return index;\n}\n/**\n * INTERNAL: Get an index of an `value` in a sorted `array` by grouping search by `shift`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @param shift grouping shift.\n *   - `0` means look at every location\n *   - `1` means only look at every other (even) location (the odd locations are to be ignored as\n *         they are values.)\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n * inserted)\n */\nfunction _arrayIndexOfSorted(array, value, shift) {\n    ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\n    let start = 0;\n    let end = array.length >> shift;\n    while (end !== start) {\n        const middle = start + ((end - start) >> 1); // find the middle.\n        const current = array[middle << shift];\n        if (value === current) {\n            return (middle << shift);\n        }\n        else if (current > value) {\n            end = middle;\n        }\n        else {\n            start = middle + 1; // We already searched middle so make it non-inclusive by adding 1\n        }\n    }\n    return ~(end << shift);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\nfunction noSideEffects(fn) {\n    return { toString: fn }.toString();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst ANNOTATIONS = '__annotations__';\nconst PARAMETERS = '__parameters__';\nconst PROP_METADATA = '__prop__metadata__';\n/**\n * @suppress {globalThis}\n */\nfunction makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {\n    return noSideEffects(() => {\n        const metaCtor = makeMetadataCtor(props);\n        function DecoratorFactory(...args) {\n            if (this instanceof DecoratorFactory) {\n                metaCtor.call(this, ...args);\n                return this;\n            }\n            const annotationInstance = new DecoratorFactory(...args);\n            return function TypeDecorator(cls) {\n                if (typeFn)\n                    typeFn(cls, ...args);\n                // Use of Object.defineProperty is important since it creates non-enumerable property which\n                // prevents the property is copied during subclassing.\n                const annotations = cls.hasOwnProperty(ANNOTATIONS) ?\n                    cls[ANNOTATIONS] :\n                    Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];\n                annotations.push(annotationInstance);\n                if (additionalProcessing)\n                    additionalProcessing(cls);\n                return cls;\n            };\n        }\n        if (parentClass) {\n            DecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        DecoratorFactory.prototype.ngMetadataName = name;\n        DecoratorFactory.annotationCls = DecoratorFactory;\n        return DecoratorFactory;\n    });\n}\nfunction makeMetadataCtor(props) {\n    return function ctor(...args) {\n        if (props) {\n            const values = props(...args);\n            for (const propName in values) {\n                this[propName] = values[propName];\n            }\n        }\n    };\n}\nfunction makeParamDecorator(name, props, parentClass) {\n    return noSideEffects(() => {\n        const metaCtor = makeMetadataCtor(props);\n        function ParamDecoratorFactory(...args) {\n            if (this instanceof ParamDecoratorFactory) {\n                metaCtor.apply(this, args);\n                return this;\n            }\n            const annotationInstance = new ParamDecoratorFactory(...args);\n            ParamDecorator.annotation = annotationInstance;\n            return ParamDecorator;\n            function ParamDecorator(cls, unusedKey, index) {\n                // Use of Object.defineProperty is important since it creates non-enumerable property which\n                // prevents the property is copied during subclassing.\n                const parameters = cls.hasOwnProperty(PARAMETERS) ?\n                    cls[PARAMETERS] :\n                    Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];\n                // there might be gaps if some in between parameters do not have annotations.\n                // we pad with nulls.\n                while (parameters.length <= index) {\n                    parameters.push(null);\n                }\n                (parameters[index] = parameters[index] || []).push(annotationInstance);\n                return cls;\n            }\n        }\n        if (parentClass) {\n            ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        ParamDecoratorFactory.prototype.ngMetadataName = name;\n        ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;\n        return ParamDecoratorFactory;\n    });\n}\nfunction makePropDecorator(name, props, parentClass, additionalProcessing) {\n    return noSideEffects(() => {\n        const metaCtor = makeMetadataCtor(props);\n        function PropDecoratorFactory(...args) {\n            if (this instanceof PropDecoratorFactory) {\n                metaCtor.apply(this, args);\n                return this;\n            }\n            const decoratorInstance = new PropDecoratorFactory(...args);\n            function PropDecorator(target, name) {\n                const constructor = target.constructor;\n                // Use of Object.defineProperty is important because it creates a non-enumerable property\n                // which prevents the property from being copied during subclassing.\n                const meta = constructor.hasOwnProperty(PROP_METADATA) ?\n                    constructor[PROP_METADATA] :\n                    Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];\n                meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n                meta[name].unshift(decoratorInstance);\n                if (additionalProcessing)\n                    additionalProcessing(target, name, ...args);\n            }\n            return PropDecorator;\n        }\n        if (parentClass) {\n            PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n        }\n        PropDecoratorFactory.prototype.ngMetadataName = name;\n        PropDecoratorFactory.annotationCls = PropDecoratorFactory;\n        return PropDecoratorFactory;\n    });\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/*\n * #########################\n * Attention: These Regular expressions have to hold even if the code is minified!\n * ##########################\n */\n/**\n * Regular expression that detects pass-through constructors for ES5 output. This Regex\n * intends to capture the common delegation pattern emitted by TypeScript and Babel. Also\n * it intends to capture the pattern where existing constructors have been downleveled from\n * ES2015 to ES5 using TypeScript w/ downlevel iteration. e.g.\n *\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, arguments) || this;\n * ```\n *\n * downleveled to ES5 with `downlevelIteration` for TypeScript < 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spread(arguments)) || this;\n * ```\n *\n * or downleveled to ES5 with `downlevelIteration` for TypeScript >= 4.2:\n * ```\n *   function MyClass() {\n *     var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;\n * ```\n *\n * More details can be found in: https://github.com/angular/angular/issues/38453.\n */\nconst ES5_DELEGATE_CTOR = /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*(arguments|(?:[^()]+\\(\\[\\],)?[^()]+\\(arguments\\).*)\\)/;\n/** Regular expression that detects ES2015 classes which extend from other classes. */\nconst ES2015_INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes and\n * have an explicit constructor defined.\n */\nconst ES2015_INHERITED_CLASS_WITH_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\n/**\n * Regular expression that detects ES2015 classes which extend from other classes\n * and inherit a constructor.\n */\nconst ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{[^}]*super\\(\\.\\.\\.arguments\\)/;\n/**\n * Determine whether a stringified type is a class which delegates its constructor\n * to its parent.\n *\n * This is not trivial since compiled code can actually contain a constructor function\n * even if the original source code did not. For instance, when the child class contains\n * an initialized instance property.\n */\nfunction isDelegateCtor(typeStr) {\n    return ES5_DELEGATE_CTOR.test(typeStr) ||\n        ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) ||\n        (ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr));\n}\nclass ReflectionCapabilities {\n    constructor(reflect) {\n        this._reflect = reflect || _global$1['Reflect'];\n    }\n    factory(t) {\n        return (...args) => new t(...args);\n    }\n    /** @internal */\n    _zipTypesAndAnnotations(paramTypes, paramAnnotations) {\n        let result;\n        if (typeof paramTypes === 'undefined') {\n            result = newArray(paramAnnotations.length);\n        }\n        else {\n            result = newArray(paramTypes.length);\n        }\n        for (let i = 0; i < result.length; i++) {\n            // TS outputs Object for parameters without types, while Traceur omits\n            // the annotations. For now we preserve the Traceur behavior to aid\n            // migration, but this can be revisited.\n            if (typeof paramTypes === 'undefined') {\n                result[i] = [];\n            }\n            else if (paramTypes[i] && paramTypes[i] != Object) {\n                result[i] = [paramTypes[i]];\n            }\n            else {\n                result[i] = [];\n            }\n            if (paramAnnotations && paramAnnotations[i] != null) {\n                result[i] = result[i].concat(paramAnnotations[i]);\n            }\n        }\n        return result;\n    }\n    _ownParameters(type, parentCtor) {\n        const typeStr = type.toString();\n        // If we have no decorators, we only have function.length as metadata.\n        // In that case, to detect whether a child class declared an own constructor or not,\n        // we need to look inside of that constructor to check whether it is\n        // just calling the parent.\n        // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n        // that sets 'design:paramtypes' to []\n        // if a class inherits from another class but has no ctor declared itself.\n        if (isDelegateCtor(typeStr)) {\n            return null;\n        }\n        // Prefer the direct API.\n        if (type.parameters && type.parameters !== parentCtor.parameters) {\n            return type.parameters;\n        }\n        // API of tsickle for lowering decorators to properties on the class.\n        const tsickleCtorParams = type.ctorParameters;\n        if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n            // Newer tsickle uses a function closure\n            // Retain the non-function case for compatibility with older tsickle\n            const ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n            const paramTypes = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);\n            const paramAnnotations = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n            return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n        }\n        // API for metadata created by invoking the decorators.\n        const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];\n        const paramTypes = this._reflect && this._reflect.getOwnMetadata &&\n            this._reflect.getOwnMetadata('design:paramtypes', type);\n        if (paramTypes || paramAnnotations) {\n            return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n        }\n        // If a class has no decorators, at least create metadata\n        // based on function.length.\n        // Note: We know that this is a real constructor as we checked\n        // the content of the constructor above.\n        return newArray(type.length);\n    }\n    parameters(type) {\n        // Note: only report metadata if we have at least one class decorator\n        // to stay in sync with the static reflector.\n        if (!isType(type)) {\n            return [];\n        }\n        const parentCtor = getParentCtor(type);\n        let parameters = this._ownParameters(type, parentCtor);\n        if (!parameters && parentCtor !== Object) {\n            parameters = this.parameters(parentCtor);\n        }\n        return parameters || [];\n    }\n    _ownAnnotations(typeOrFunc, parentCtor) {\n        // Prefer the direct API.\n        if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {\n            let annotations = typeOrFunc.annotations;\n            if (typeof annotations === 'function' && annotations.annotations) {\n                annotations = annotations.annotations;\n            }\n            return annotations;\n        }\n        // API of tsickle for lowering decorators to properties on the class.\n        if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {\n            return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);\n        }\n        // API for metadata created by invoking the decorators.\n        if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n            return typeOrFunc[ANNOTATIONS];\n        }\n        return null;\n    }\n    annotations(typeOrFunc) {\n        if (!isType(typeOrFunc)) {\n            return [];\n        }\n        const parentCtor = getParentCtor(typeOrFunc);\n        const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n        const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n        return parentAnnotations.concat(ownAnnotations);\n    }\n    _ownPropMetadata(typeOrFunc, parentCtor) {\n        // Prefer the direct API.\n        if (typeOrFunc.propMetadata &&\n            typeOrFunc.propMetadata !== parentCtor.propMetadata) {\n            let propMetadata = typeOrFunc.propMetadata;\n            if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n                propMetadata = propMetadata.propMetadata;\n            }\n            return propMetadata;\n        }\n        // API of tsickle for lowering decorators to properties on the class.\n        if (typeOrFunc.propDecorators &&\n            typeOrFunc.propDecorators !== parentCtor.propDecorators) {\n            const propDecorators = typeOrFunc.propDecorators;\n            const propMetadata = {};\n            Object.keys(propDecorators).forEach(prop => {\n                propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n            });\n            return propMetadata;\n        }\n        // API for metadata created by invoking the decorators.\n        if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n            return typeOrFunc[PROP_METADATA];\n        }\n        return null;\n    }\n    propMetadata(typeOrFunc) {\n        if (!isType(typeOrFunc)) {\n            return {};\n        }\n        const parentCtor = getParentCtor(typeOrFunc);\n        const propMetadata = {};\n        if (parentCtor !== Object) {\n            const parentPropMetadata = this.propMetadata(parentCtor);\n            Object.keys(parentPropMetadata).forEach((propName) => {\n                propMetadata[propName] = parentPropMetadata[propName];\n            });\n        }\n        const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n        if (ownPropMetadata) {\n            Object.keys(ownPropMetadata).forEach((propName) => {\n                const decorators = [];\n                if (propMetadata.hasOwnProperty(propName)) {\n                    decorators.push(...propMetadata[propName]);\n                }\n                decorators.push(...ownPropMetadata[propName]);\n                propMetadata[propName] = decorators;\n            });\n        }\n        return propMetadata;\n    }\n    ownPropMetadata(typeOrFunc) {\n        if (!isType(typeOrFunc)) {\n            return {};\n        }\n        return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\n    }\n    hasLifecycleHook(type, lcProperty) {\n        return type instanceof Type && lcProperty in type.prototype;\n    }\n}\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations) {\n    if (!decoratorInvocations) {\n        return [];\n    }\n    return decoratorInvocations.map(decoratorInvocation => {\n        const decoratorType = decoratorInvocation.type;\n        const annotationCls = decoratorType.annotationCls;\n        const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n        return new annotationCls(...annotationArgs);\n    });\n}\nfunction getParentCtor(ctor) {\n    const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n    const parentCtor = parentProto ? parentProto.constructor : null;\n    // Note: We always use `Object` as the null value\n    // to simplify checking later on.\n    return parentCtor || Object;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction ngDevModeResetPerfCounters() {\n    const locationString = typeof location !== 'undefined' ? location.toString() : '';\n    const newCounters = {\n        namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n        firstCreatePass: 0,\n        tNode: 0,\n        tView: 0,\n        rendererCreateTextNode: 0,\n        rendererSetText: 0,\n        rendererCreateElement: 0,\n        rendererAddEventListener: 0,\n        rendererSetAttribute: 0,\n        rendererRemoveAttribute: 0,\n        rendererSetProperty: 0,\n        rendererSetClassName: 0,\n        rendererAddClass: 0,\n        rendererRemoveClass: 0,\n        rendererSetStyle: 0,\n        rendererRemoveStyle: 0,\n        rendererDestroy: 0,\n        rendererDestroyNode: 0,\n        rendererMoveNode: 0,\n        rendererRemoveNode: 0,\n        rendererAppendChild: 0,\n        rendererInsertBefore: 0,\n        rendererCreateComment: 0,\n    };\n    // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n    const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n    _global$1['ngDevMode'] = allowNgDevModeTrue && newCounters;\n    return newCounters;\n}\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `\u0275\u0275defineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nfunction initNgDevMode() {\n    // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n    // reset the counters.\n    // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n    // yet.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (typeof ngDevMode !== 'object') {\n            ngDevModeResetPerfCounters();\n        }\n        return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Used for stringify render output in Ivy.\n * Important! This function is very performance-sensitive and we should\n * be extra careful not to introduce megamorphic reads in it.\n * Check `core/test/render3/perf/render_stringify` for benchmarks and alternate implementations.\n */\nfunction renderStringify(value) {\n    if (typeof value === 'string')\n        return value;\n    if (value == null)\n        return '';\n    // Use `String` so that it invokes the `toString` method of the value. Note that this\n    // appears to be faster than calling `value.toString` (see `render_stringify` benchmark).\n    return String(value);\n}\n/**\n * Used to stringify a value so that it can be displayed in an error message.\n * Important! This function contains a megamorphic read and should only be\n * used for error messages.\n */\nfunction stringifyForError(value) {\n    if (typeof value === 'function')\n        return value.name || value.toString();\n    if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n        return value.type.name || value.type.toString();\n    }\n    return renderStringify(value);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Called when directives inject each other (creating a circular dependency) */\nfunction throwCyclicDependencyError(token, path) {\n    const depPath = path ? `. Dependency path: ${path.join(' > ')} > ${token}` : '';\n    throw new RuntimeError(-200 /* RuntimeErrorCode.CYCLIC_DI_DEPENDENCY */, `Circular dependency in DI detected for ${token}${depPath}`);\n}\nfunction throwMixedMultiProviderError() {\n    throw new Error(`Cannot mix multi providers and regular providers`);\n}\nfunction throwInvalidProviderError(ngModuleType, providers, provider) {\n    if (ngModuleType && providers) {\n        const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');\n        throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);\n    }\n    else if (provider.\u0275providers) {\n        throw new RuntimeError(207 /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);\n    }\n    else {\n        throw new Error('Invalid provider');\n    }\n}\n/** Throws an error when a token is not found in DI. */\nfunction throwProviderNotFoundError(token, injectorName) {\n    const injectorDetails = injectorName ? ` in ${injectorName}` : '';\n    throw new RuntimeError(-201 /* RuntimeErrorCode.PROVIDER_NOT_FOUND */, ngDevMode && `No provider for ${stringifyForError(token)} found${injectorDetails}`);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection flags for DI.\n *\n * @publicApi\n * @deprecated use an options object for `inject` instead.\n */\nvar InjectFlags;\n(function (InjectFlags) {\n    // TODO(alxhub): make this 'const' (and remove `InternalInjectFlags` enum) when ngc no longer\n    // writes exports of it into ngfactory files.\n    /** Check self and check parent injector if needed */\n    InjectFlags[InjectFlags[\"Default\"] = 0] = \"Default\";\n    /**\n     * Specifies that an injector should retrieve a dependency from any injector until reaching the\n     * host element of the current component. (Only used with Element Injector)\n     */\n    InjectFlags[InjectFlags[\"Host\"] = 1] = \"Host\";\n    /** Don't ascend to ancestors of the node requesting injection. */\n    InjectFlags[InjectFlags[\"Self\"] = 2] = \"Self\";\n    /** Skip the node that is requesting injection. */\n    InjectFlags[InjectFlags[\"SkipSelf\"] = 4] = \"SkipSelf\";\n    /** Inject `defaultValue` instead if token not found. */\n    InjectFlags[InjectFlags[\"Optional\"] = 8] = \"Optional\";\n})(InjectFlags || (InjectFlags = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation;\nfunction getInjectImplementation() {\n    return _injectImplementation;\n}\n/**\n * Sets the current inject implementation.\n */\nfunction setInjectImplementation(impl) {\n    const previous = _injectImplementation;\n    _injectImplementation = impl;\n    return previous;\n}\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * injectable definition.\n */\nfunction injectRootLimpMode(token, notFoundValue, flags) {\n    const injectableDef = getInjectableDef(token);\n    if (injectableDef && injectableDef.providedIn == 'root') {\n        return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\n            injectableDef.value;\n    }\n    if (flags & InjectFlags.Optional)\n        return null;\n    if (notFoundValue !== undefined)\n        return notFoundValue;\n    throwProviderNotFoundError(stringify(token), 'Injector');\n}\n/**\n * Assert that `_injectImplementation` is not `fn`.\n *\n * This is useful, to prevent infinite recursion.\n *\n * @param fn Function which it should not equal to\n */\nfunction assertInjectImplementationNotEqual(fn) {\n    ngDevMode &&\n        assertNotEqual(_injectImplementation, fn, 'Calling \u0275\u0275inject would cause infinite recursion');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _THROW_IF_NOT_FOUND = {};\nconst THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n/*\n * Name of a property (that we patch onto DI decorator), which is used as an annotation of which\n * InjectFlag this decorator represents. This allows to avoid direct references to the DI decorators\n * in the code, thus making them tree-shakable.\n */\nconst DI_DECORATOR_FLAG = '__NG_DI_FLAG__';\nconst NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = '\u0275';\nconst SOURCE = '__source';\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector = undefined;\nfunction setCurrentInjector(injector) {\n    const former = _currentInjector;\n    _currentInjector = injector;\n    return former;\n}\nfunction injectInjectorOnly(token, flags = InjectFlags.Default) {\n    if (_currentInjector === undefined) {\n        throw new RuntimeError(-203 /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */, ngDevMode &&\n            `inject() must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \\`EnvironmentInjector#runInContext\\`.`);\n    }\n    else if (_currentInjector === null) {\n        return injectRootLimpMode(token, undefined, flags);\n    }\n    else {\n        return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n    }\n}\nfunction \u0275\u0275inject(token, flags = InjectFlags.Default) {\n    return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275invalidFactoryDep(index) {\n    throw new RuntimeError(202 /* RuntimeErrorCode.INVALID_FACTORY_DEPENDENCY */, ngDevMode &&\n        `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);\n}\n/**\n * Injects a token from the currently active injector.\n * `inject` is only supported during instantiation of a dependency by the DI system. It can be used\n * during:\n * - Construction (via the `constructor`) of a class being instantiated by the DI system, such\n * as an `@Injectable` or `@Component`.\n * - In the initializer for fields of such classes.\n * - In the factory function specified for `useFactory` of a `Provider` or an `@Injectable`.\n * - In the `factory` function specified for an `InjectionToken`.\n *\n * @param token A token that represents a dependency that should be injected.\n * @param flags Optional flags that control how injection is executed.\n * The flags correspond to injection strategies that can be specified with\n * parameter decorators `@Host`, `@Self`, `@SkipSef`, and `@Optional`.\n * @returns the injected value if operation is successful, `null` otherwise.\n * @throws if called outside of a supported context.\n *\n * @usageNotes\n * In practice the `inject()` calls are allowed in a constructor, a constructor parameter and a\n * field initializer:\n *\n * ```typescript\n * @Injectable({providedIn: 'root'})\n * export class Car {\n *   radio: Radio|undefined;\n *   // OK: field initializer\n *   spareTyre = inject(Tyre);\n *\n *   constructor() {\n *     // OK: constructor body\n *     this.radio = inject(Radio);\n *   }\n * }\n * ```\n *\n * It is also legal to call `inject` from a provider's factory:\n *\n * ```typescript\n * providers: [\n *   {provide: Car, useFactory: () => {\n *     // OK: a class factory\n *     const engine = inject(Engine);\n *     return new Car(engine);\n *   }}\n * ]\n * ```\n *\n * Calls to the `inject()` function outside of the class creation context will result in error. Most\n * notably, calls to `inject()` are disallowed after a class instance was created, in methods\n * (including lifecycle hooks):\n *\n * ```typescript\n * @Component({ ... })\n * export class CarComponent {\n *   ngOnInit() {\n *     // ERROR: too late, the component instance was already created\n *     const engine = inject(Engine);\n *     engine.start();\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nfunction inject$1(token, flags = InjectFlags.Default) {\n    if (typeof flags !== 'number') {\n        // While TypeScript doesn't accept it without a cast, bitwise OR with false-y values in\n        // JavaScript is a no-op. We can use that for a very codesize-efficient conversion from\n        // `InjectOptions` to `InjectFlags`.\n        flags = (0 /* InternalInjectFlags.Default */ | // comment to force a line break in the formatter\n            (flags.optional && 8 /* InternalInjectFlags.Optional */) |\n            (flags.host && 1 /* InternalInjectFlags.Host */) |\n            (flags.self && 2 /* InternalInjectFlags.Self */) |\n            (flags.skipSelf && 4 /* InternalInjectFlags.SkipSelf */));\n    }\n    return \u0275\u0275inject(token, flags);\n}\nfunction injectArgs(types) {\n    const args = [];\n    for (let i = 0; i < types.length; i++) {\n        const arg = resolveForwardRef(types[i]);\n        if (Array.isArray(arg)) {\n            if (arg.length === 0) {\n                throw new RuntimeError(900 /* RuntimeErrorCode.INVALID_DIFFER_INPUT */, ngDevMode && 'Arguments array must have arguments.');\n            }\n            let type = undefined;\n            let flags = InjectFlags.Default;\n            for (let j = 0; j < arg.length; j++) {\n                const meta = arg[j];\n                const flag = getInjectFlag(meta);\n                if (typeof flag === 'number') {\n                    // Special case when we handle @Inject decorator.\n                    if (flag === -1 /* DecoratorFlags.Inject */) {\n                        type = meta.token;\n                    }\n                    else {\n                        flags |= flag;\n                    }\n                }\n                else {\n                    type = meta;\n                }\n            }\n            args.push(\u0275\u0275inject(type, flags));\n        }\n        else {\n            args.push(\u0275\u0275inject(arg));\n        }\n    }\n    return args;\n}\n/**\n * Attaches a given InjectFlag to a given decorator using monkey-patching.\n * Since DI decorators can be used in providers `deps` array (when provider is configured using\n * `useFactory`) without initialization (e.g. `Host`) and as an instance (e.g. `new Host()`), we\n * attach the flag to make it available both as a static property and as a field on decorator\n * instance.\n *\n * @param decorator Provided DI decorator.\n * @param flag InjectFlag that should be applied.\n */\nfunction attachInjectFlag(decorator, flag) {\n    decorator[DI_DECORATOR_FLAG] = flag;\n    decorator.prototype[DI_DECORATOR_FLAG] = flag;\n    return decorator;\n}\n/**\n * Reads monkey-patched property that contains InjectFlag attached to a decorator.\n *\n * @param token Token that may contain monkey-patched DI flags property.\n */\nfunction getInjectFlag(token) {\n    return token[DI_DECORATOR_FLAG];\n}\nfunction catchInjectorError(e, token, injectorErrorName, source) {\n    const tokenPath = e[NG_TEMP_TOKEN_PATH];\n    if (token[SOURCE]) {\n        tokenPath.unshift(token[SOURCE]);\n    }\n    e.message = formatError('\\n' + e.message, tokenPath, injectorErrorName, source);\n    e[NG_TOKEN_PATH] = tokenPath;\n    e[NG_TEMP_TOKEN_PATH] = null;\n    throw e;\n}\nfunction formatError(text, obj, injectorErrorName, source = null) {\n    text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;\n    let context = stringify(obj);\n    if (Array.isArray(obj)) {\n        context = obj.map(stringify).join(' -> ');\n    }\n    else if (typeof obj === 'object') {\n        let parts = [];\n        for (let key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                let value = obj[key];\n                parts.push(key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n            }\n        }\n        context = `{${parts.join(', ')}}`;\n    }\n    return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Inject = attachInjectFlag(\n// Disable tslint because `DecoratorFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nmakeParamDecorator('Inject', (token) => ({ token })), -1 /* DecoratorFlags.Inject */);\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Optional = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Optional'), 8 /* InternalInjectFlags.Optional */);\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Self = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Self'), 2 /* InternalInjectFlags.Self */);\n/**\n * `SkipSelf` decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst SkipSelf = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('SkipSelf'), 4 /* InternalInjectFlags.SkipSelf */);\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Host = \n// Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n// tslint:disable-next-line: no-toplevel-property-access\nattachInjectFlag(makeParamDecorator('Host'), 1 /* InternalInjectFlags.Host */);\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The strategy that the default change detector uses to detect changes.\n * When set, takes effect the next time change detection is triggered.\n *\n * @see {@link ChangeDetectorRef#usage-notes Change detection usage}\n *\n * @publicApi\n */\nvar ChangeDetectionStrategy;\n(function (ChangeDetectionStrategy) {\n    /**\n     * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\n     * until reactivated by setting the strategy to `Default` (`CheckAlways`).\n     * Change detection can still be explicitly invoked.\n     * This strategy applies to all child directives and cannot be overridden.\n     */\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n    /**\n     * Use the default `CheckAlways` strategy, in which change detection is automatic until\n     * explicitly deactivated.\n     */\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\n/**\n * Defines the possible states of the default change detector.\n * @see `ChangeDetectorRef`\n */\nvar ChangeDetectorStatus;\n(function (ChangeDetectorStatus) {\n    /**\n     * A state in which, after calling `detectChanges()`, the change detector\n     * state becomes `Checked`, and must be explicitly invoked or reactivated.\n     */\n    ChangeDetectorStatus[ChangeDetectorStatus[\"CheckOnce\"] = 0] = \"CheckOnce\";\n    /**\n     * A state in which change detection is skipped until the change detector mode\n     * becomes `CheckOnce`.\n     */\n    ChangeDetectorStatus[ChangeDetectorStatus[\"Checked\"] = 1] = \"Checked\";\n    /**\n     * A state in which change detection continues automatically until explicitly\n     * deactivated.\n     */\n    ChangeDetectorStatus[ChangeDetectorStatus[\"CheckAlways\"] = 2] = \"CheckAlways\";\n    /**\n     * A state in which a change detector sub tree is not a part of the main tree and\n     * should be skipped.\n     */\n    ChangeDetectorStatus[ChangeDetectorStatus[\"Detached\"] = 3] = \"Detached\";\n    /**\n     * Indicates that the change detector encountered an error checking a binding\n     * or calling a directive lifecycle method and is now in an inconsistent state. Change\n     * detectors in this state do not detect changes.\n     */\n    ChangeDetectorStatus[ChangeDetectorStatus[\"Errored\"] = 4] = \"Errored\";\n    /**\n     * Indicates that the change detector has been destroyed.\n     */\n    ChangeDetectorStatus[ChangeDetectorStatus[\"Destroyed\"] = 5] = \"Destroyed\";\n})(ChangeDetectorStatus || (ChangeDetectorStatus = {}));\n/**\n * Reports whether a given strategy is currently the default for change detection.\n * @param changeDetectionStrategy The strategy to check.\n * @returns True if the given strategy is the current default, false otherwise.\n * @see `ChangeDetectorStatus`\n * @see `ChangeDetectorRef`\n */\nfunction isDefaultChangeDetectionStrategy(changeDetectionStrategy) {\n    return changeDetectionStrategy == null ||\n        changeDetectionStrategy === ChangeDetectionStrategy.Default;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Defines the CSS styles encapsulation policies for the {@link Component} decorator's\n * `encapsulation` option.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\n *\n * @publicApi\n */\nvar ViewEncapsulation;\n(function (ViewEncapsulation) {\n    // TODO: consider making `ViewEncapsulation` a `const enum` instead. See\n    // https://github.com/angular/angular/issues/44119 for additional information.\n    /**\n     * Emulates a native Shadow DOM encapsulation behavior by adding a specific attribute to the\n     * component's host element and applying the same attribute to all the CSS selectors provided\n     * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls}.\n     *\n     * This is the default option.\n     */\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n    // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n    /**\n     * Doesn't provide any sort of CSS style encapsulation, meaning that all the styles provided\n     * via {@link Component#styles styles} or {@link Component#styleUrls styleUrls} are applicable\n     * to any HTML element of the application regardless of their host Component.\n     */\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    /**\n     * Uses the browser's native Shadow DOM API to encapsulate CSS styles, meaning that it creates\n     * a ShadowRoot for the component's host element which is then used to encapsulate\n     * all the Component's styling.\n     */\n    ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This file contains reuseable \"empty\" symbols that can be used as default return values\n * in different parts of the rendering code. Because the same symbols are returned, this\n * allows for identity checks against these values to be consistently used by the framework\n * code.\n */\nconst EMPTY_OBJ = {};\nconst EMPTY_ARRAY = [];\n// freezing the values prevents any code from accidentally inserting new values in\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n    // These property accesses can be ignored because ngDevMode will be set to false\n    // when optimizing code and the whole if statement will be dropped.\n    // tslint:disable-next-line:no-toplevel-property-access\n    Object.freeze(EMPTY_OBJ);\n    // tslint:disable-next-line:no-toplevel-property-access\n    Object.freeze(EMPTY_ARRAY);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst NG_COMP_DEF = getClosureSafeProperty({ \u0275cmp: getClosureSafeProperty });\nconst NG_DIR_DEF = getClosureSafeProperty({ \u0275dir: getClosureSafeProperty });\nconst NG_PIPE_DEF = getClosureSafeProperty({ \u0275pipe: getClosureSafeProperty });\nconst NG_MOD_DEF = getClosureSafeProperty({ \u0275mod: getClosureSafeProperty });\nconst NG_FACTORY_DEF = getClosureSafeProperty({ \u0275fac: getClosureSafeProperty });\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\n// TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\nconst NG_ELEMENT_ID = getClosureSafeProperty({ __NG_ELEMENT_ID__: getClosureSafeProperty });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Counter used to generate unique IDs for component definitions. */\nlet componentDefCount = 0;\n/**\n * Create a component definition object.\n *\n *\n * # Example\n * ```\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static \u0275cmp = defineComponent({\n *     ...\n *   });\n * }\n * ```\n * @codeGenApi\n */\nfunction \u0275\u0275defineComponent(componentDefinition) {\n    return noSideEffects(() => {\n        // Initialize ngDevMode. This must be the first statement in \u0275\u0275defineComponent.\n        // See the `initNgDevMode` docstring for more information.\n        (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();\n        const type = componentDefinition.type;\n        const standalone = componentDefinition.standalone === true;\n        const declaredInputs = {};\n        const def = {\n            type: type,\n            providersResolver: null,\n            decls: componentDefinition.decls,\n            vars: componentDefinition.vars,\n            factory: null,\n            template: componentDefinition.template || null,\n            consts: componentDefinition.consts || null,\n            ngContentSelectors: componentDefinition.ngContentSelectors,\n            hostBindings: componentDefinition.hostBindings || null,\n            hostVars: componentDefinition.hostVars || 0,\n            hostAttrs: componentDefinition.hostAttrs || null,\n            contentQueries: componentDefinition.contentQueries || null,\n            declaredInputs: declaredInputs,\n            inputs: null,\n            outputs: null,\n            exportAs: componentDefinition.exportAs || null,\n            onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,\n            directiveDefs: null,\n            pipeDefs: null,\n            standalone,\n            dependencies: standalone && componentDefinition.dependencies || null,\n            getStandaloneInjector: null,\n            selectors: componentDefinition.selectors || EMPTY_ARRAY,\n            viewQuery: componentDefinition.viewQuery || null,\n            features: componentDefinition.features || null,\n            data: componentDefinition.data || {},\n            encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,\n            id: `c${componentDefCount++}`,\n            styles: componentDefinition.styles || EMPTY_ARRAY,\n            _: null,\n            setInput: null,\n            schemas: componentDefinition.schemas || null,\n            tView: null,\n        };\n        const dependencies = componentDefinition.dependencies;\n        const feature = componentDefinition.features;\n        def.inputs = invertObject(componentDefinition.inputs, declaredInputs),\n            def.outputs = invertObject(componentDefinition.outputs),\n            feature && feature.forEach((fn) => fn(def));\n        def.directiveDefs = dependencies ?\n            (() => (typeof dependencies === 'function' ? dependencies() : dependencies)\n                .map(extractDirectiveDef)\n                .filter(nonNull)) :\n            null;\n        def.pipeDefs = dependencies ?\n            (() => (typeof dependencies === 'function' ? dependencies() : dependencies)\n                .map(getPipeDef$1)\n                .filter(nonNull)) :\n            null;\n        return def;\n    });\n}\n/**\n * Generated next to NgModules to monkey-patch directive and pipe references onto a component's\n * definition, when generating a direct reference in the component file would otherwise create an\n * import cycle.\n *\n * See [this explanation](https://hackmd.io/Odw80D0pR6yfsOjg_7XCJg?view) for more details.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275setComponentScope(type, directives, pipes) {\n    const def = type.\u0275cmp;\n    def.directiveDefs = () => (typeof directives === 'function' ? directives() : directives).map(extractDirectiveDef);\n    def.pipeDefs = () => (typeof pipes === 'function' ? pipes() : pipes).map(getPipeDef$1);\n}\nfunction extractDirectiveDef(type) {\n    return getComponentDef$1(type) || getDirectiveDef(type);\n}\nfunction nonNull(value) {\n    return value !== null;\n}\n/**\n * @codeGenApi\n */\nfunction \u0275\u0275defineNgModule(def) {\n    return noSideEffects(() => {\n        const res = {\n            type: def.type,\n            bootstrap: def.bootstrap || EMPTY_ARRAY,\n            declarations: def.declarations || EMPTY_ARRAY,\n            imports: def.imports || EMPTY_ARRAY,\n            exports: def.exports || EMPTY_ARRAY,\n            transitiveCompileScopes: null,\n            schemas: def.schemas || null,\n            id: def.id || null,\n        };\n        return res;\n    });\n}\n/**\n * Adds the module metadata that is necessary to compute the module's transitive scope to an\n * existing module definition.\n *\n * Scope metadata of modules is not used in production builds, so calls to this function can be\n * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\n * to become eligible for tree-shaking as well.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275setNgModuleScope(type, scope) {\n    return noSideEffects(() => {\n        const ngModuleDef = getNgModuleDef(type, true);\n        ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;\n        ngModuleDef.imports = scope.imports || EMPTY_ARRAY;\n        ngModuleDef.exports = scope.exports || EMPTY_ARRAY;\n    });\n}\n/**\n * Inverts an inputs or outputs lookup such that the keys, which were the\n * minified keys, are part of the values, and the values are parsed so that\n * the publicName of the property is the new key\n *\n * e.g. for\n *\n * ```\n * class Comp {\n *   @Input()\n *   propName1: string;\n *\n *   @Input('publicName2')\n *   declaredPropName2: number;\n * }\n * ```\n *\n * will be serialized as\n *\n * ```\n * {\n *   propName1: 'propName1',\n *   declaredPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * which is than translated by the minifier as:\n *\n * ```\n * {\n *   minifiedPropName1: 'propName1',\n *   minifiedPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * becomes: (public name => minifiedName)\n *\n * ```\n * {\n *  'propName1': 'minifiedPropName1',\n *  'publicName2': 'minifiedPropName2',\n * }\n * ```\n *\n * Optionally the function can take `secondary` which will result in: (public name => declared name)\n *\n * ```\n * {\n *  'propName1': 'propName1',\n *  'publicName2': 'declaredPropName2',\n * }\n * ```\n *\n\n */\nfunction invertObject(obj, secondary) {\n    if (obj == null)\n        return EMPTY_OBJ;\n    const newLookup = {};\n    for (const minifiedKey in obj) {\n        if (obj.hasOwnProperty(minifiedKey)) {\n            let publicName = obj[minifiedKey];\n            let declaredName = publicName;\n            if (Array.isArray(publicName)) {\n                declaredName = publicName[1];\n                publicName = publicName[0];\n            }\n            newLookup[publicName] = minifiedKey;\n            if (secondary) {\n                (secondary[publicName] = declaredName);\n            }\n        }\n    }\n    return newLookup;\n}\n/**\n * Create a directive definition object.\n *\n * # Example\n * ```ts\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static \u0275dir = \u0275\u0275defineDirective({\n *     ...\n *   });\n * }\n * ```\n *\n * @codeGenApi\n */\nconst \u0275\u0275defineDirective = \u0275\u0275defineComponent;\n/**\n * Create a pipe definition object.\n *\n * # Example\n * ```\n * class MyPipe implements PipeTransform {\n *   // Generated by Angular Template Compiler\n *   static \u0275pipe = definePipe({\n *     ...\n *   });\n * }\n * ```\n * @param pipeDef Pipe definition generated by the compiler\n *\n * @codeGenApi\n */\nfunction \u0275\u0275definePipe(pipeDef) {\n    return {\n        type: pipeDef.type,\n        name: pipeDef.name,\n        factory: null,\n        pure: pipeDef.pure !== false,\n        standalone: pipeDef.standalone === true,\n        onDestroy: pipeDef.type.prototype.ngOnDestroy || null\n    };\n}\n/**\n * The following getter methods retrieve the definition from the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\nfunction getComponentDef$1(type) {\n    return type[NG_COMP_DEF] || null;\n}\nfunction getDirectiveDef(type) {\n    return type[NG_DIR_DEF] || null;\n}\nfunction getPipeDef$1(type) {\n    return type[NG_PIPE_DEF] || null;\n}\nfunction isStandalone(type) {\n    const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n    return def !== null ? def.standalone : false;\n}\nfunction getNgModuleDef(type, throwNotFound) {\n    const ngModuleDef = type[NG_MOD_DEF] || null;\n    if (!ngModuleDef && throwNotFound === true) {\n        throw new Error(`Type ${stringify(type)} does not have '\u0275mod' property.`);\n    }\n    return ngModuleDef;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nconst HOST = 0;\nconst TVIEW = 1;\nconst FLAGS = 2;\nconst PARENT = 3;\nconst NEXT = 4;\nconst TRANSPLANTED_VIEWS_TO_REFRESH = 5;\nconst T_HOST = 6;\nconst CLEANUP = 7;\nconst CONTEXT = 8;\nconst INJECTOR$1 = 9;\nconst RENDERER_FACTORY = 10;\nconst RENDERER = 11;\nconst SANITIZER = 12;\nconst CHILD_HEAD = 13;\nconst CHILD_TAIL = 14;\n// FIXME(misko): Investigate if the three declarations aren't all same thing.\nconst DECLARATION_VIEW = 15;\nconst DECLARATION_COMPONENT_VIEW = 16;\nconst DECLARATION_LCONTAINER = 17;\nconst PREORDER_HOOK_FLAGS = 18;\nconst QUERIES = 19;\nconst ID = 20;\nconst EMBEDDED_VIEW_INJECTOR = 21;\n/**\n * Size of LView's header. Necessary to adjust for it when setting slots.\n *\n * IMPORTANT: `HEADER_OFFSET` should only be referred to the in the `\u0275\u0275*` instructions to translate\n * instruction index into `LView` index. All other indexes should be in the `LView` index space and\n * there should be no need to refer to `HEADER_OFFSET` anywhere else.\n */\nconst HEADER_OFFSET = 22;\n/**\n * Converts `TViewType` into human readable text.\n * Make sure this matches with `TViewType`\n */\nconst TViewTypeAsString = [\n    'Root',\n    'Component',\n    'Embedded', // 2\n];\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$8 = 1;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\nconst TYPE = 1;\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\n/**\n * Flag to signify that this `LContainer` may have transplanted views which need to be change\n * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n *\n * This flag, once set, is never unset for the `LContainer`. This means that when unset we can skip\n * a lot of work in `refreshEmbeddedViews`. But when set we still need to verify\n * that the `MOVED_VIEWS` are transplanted and on-push.\n */\nconst HAS_TRANSPLANTED_VIEWS = 2;\n// PARENT, NEXT, TRANSPLANTED_VIEWS_TO_REFRESH are indices 3, 4, and 5\n// As we already have these constants in LView, we don't need to re-create them.\n// T_HOST is index 6\n// We already have this constants in LView, we don't need to re-create it.\nconst NATIVE = 7;\nconst VIEW_REFS = 8;\nconst MOVED_VIEWS = 9;\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\nconst CONTAINER_HEADER_OFFSET = 10;\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$7 = 1;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * True if `value` is `LView`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction isLView(value) {\n    return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\n/**\n * True if `value` is `LContainer`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction isLContainer(value) {\n    return Array.isArray(value) && value[TYPE] === true;\n}\nfunction isContentQueryHost(tNode) {\n    return (tNode.flags & 8 /* TNodeFlags.hasContentQuery */) !== 0;\n}\nfunction isComponentHost(tNode) {\n    return (tNode.flags & 2 /* TNodeFlags.isComponentHost */) === 2 /* TNodeFlags.isComponentHost */;\n}\nfunction isDirectiveHost(tNode) {\n    return (tNode.flags & 1 /* TNodeFlags.isDirectiveHost */) === 1 /* TNodeFlags.isDirectiveHost */;\n}\nfunction isComponentDef(def) {\n    return def.template !== null;\n}\nfunction isRootView(target) {\n    return (target[FLAGS] & 256 /* LViewFlags.IsRoot */) !== 0;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// [Assert functions do not constraint type when they are guarded by a truthy\n// expression.](https://github.com/microsoft/TypeScript/issues/37295)\nfunction assertTNodeForLView(tNode, lView) {\n    assertTNodeForTView(tNode, lView[TVIEW]);\n}\nfunction assertTNodeForTView(tNode, tView) {\n    assertTNode(tNode);\n    tNode.hasOwnProperty('tView_') &&\n        assertEqual(tNode.tView_, tView, 'This TNode does not belong to this TView.');\n}\nfunction assertTNode(tNode) {\n    assertDefined(tNode, 'TNode must be defined');\n    if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n        throwError('Not of type TNode, got: ' + tNode);\n    }\n}\nfunction assertTIcu(tIcu) {\n    assertDefined(tIcu, 'Expected TIcu to be defined');\n    if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n        throwError('Object is not of TIcu type.');\n    }\n}\nfunction assertComponentType(actual, msg = 'Type passed in is not ComponentType, it does not have \\'\u0275cmp\\' property.') {\n    if (!getComponentDef$1(actual)) {\n        throwError(msg);\n    }\n}\nfunction assertNgModuleType(actual, msg = 'Type passed in is not NgModuleType, it does not have \\'\u0275mod\\' property.') {\n    if (!getNgModuleDef(actual)) {\n        throwError(msg);\n    }\n}\nfunction assertCurrentTNodeIsParent(isParent) {\n    assertEqual(isParent, true, 'currentTNode should be a parent');\n}\nfunction assertHasParent(tNode) {\n    assertDefined(tNode, 'currentTNode should exist!');\n    assertDefined(tNode.parent, 'currentTNode should have a parent');\n}\nfunction assertDataNext(lView, index, arr) {\n    if (arr == null)\n        arr = lView;\n    assertEqual(arr.length, index, `index ${index} expected to be at the end of arr (length ${arr.length})`);\n}\nfunction assertLContainer(value) {\n    assertDefined(value, 'LContainer must be defined');\n    assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\nfunction assertLViewOrUndefined(value) {\n    value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\nfunction assertLView(value) {\n    assertDefined(value, 'LView must be defined');\n    assertEqual(isLView(value), true, 'Expecting LView');\n}\nfunction assertFirstCreatePass(tView, errMessage) {\n    assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\n}\nfunction assertFirstUpdatePass(tView, errMessage) {\n    assertEqual(tView.firstUpdatePass, true, errMessage || 'Should only be called in first update pass.');\n}\n/**\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\n * an interface, so we can't do a direct instanceof check.\n */\nfunction assertDirectiveDef(obj) {\n    if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n        throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n    }\n}\nfunction assertIndexInDeclRange(lView, index) {\n    const tView = lView[1];\n    assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\nfunction assertIndexInVarsRange(lView, index) {\n    const tView = lView[1];\n    assertBetween(tView.bindingStartIndex, tView.expandoStartIndex, index);\n}\nfunction assertIndexInExpandoRange(lView, index) {\n    const tView = lView[1];\n    assertBetween(tView.expandoStartIndex, lView.length, index);\n}\nfunction assertBetween(lower, upper, index) {\n    if (!(lower <= index && index < upper)) {\n        throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n    }\n}\nfunction assertProjectionSlots(lView, errMessage) {\n    assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');\n    assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage ||\n        'Components with projection nodes (<ng-content>) must have projection slots defined.');\n}\nfunction assertParentView(lView, errMessage) {\n    assertDefined(lView, errMessage || 'Component views should always have a parent view (component\\'s host view)');\n}\n/**\n * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a\n * NodeInjector data structure.\n *\n * @param lView `LView` which should be checked.\n * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.\n */\nfunction assertNodeInjector(lView, injectorIndex) {\n    assertIndexInExpandoRange(lView, injectorIndex);\n    assertIndexInExpandoRange(lView, injectorIndex + 8 /* NodeInjectorOffset.PARENT */);\n    assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\n    assertNumber(lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */], 'injectorIndex should point to parent injector');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction getFactoryDef(type, throwNotFound) {\n    const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n    if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n        throw new Error(`Type ${stringify(type)} does not have '\u0275fac' property.`);\n    }\n    return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Represents a basic change from a previous to a new value for a single\n * property on a directive instance. Passed as a value in a\n * {@link SimpleChanges} object to the `ngOnChanges` hook.\n *\n * @see `OnChanges`\n *\n * @publicApi\n */\nclass SimpleChange {\n    constructor(previousValue, currentValue, firstChange) {\n        this.previousValue = previousValue;\n        this.currentValue = currentValue;\n        this.firstChange = firstChange;\n    }\n    /**\n     * Check whether the new value is the first value assigned.\n     */\n    isFirstChange() {\n        return this.firstChange;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The NgOnChangesFeature decorates a component with support for the ngOnChanges\n * lifecycle hook, so it should be included in any component that implements\n * that hook.\n *\n * If the component or directive uses inheritance, the NgOnChangesFeature MUST\n * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\n * inherited properties will not be propagated to the ngOnChanges lifecycle\n * hook.\n *\n * Example usage:\n *\n * ```\n * static \u0275cmp = defineComponent({\n *   ...\n *   inputs: {name: 'publicName'},\n *   features: [NgOnChangesFeature]\n * });\n * ```\n *\n * @codeGenApi\n */\nfunction \u0275\u0275NgOnChangesFeature() {\n    return NgOnChangesFeatureImpl;\n}\nfunction NgOnChangesFeatureImpl(definition) {\n    if (definition.type.prototype.ngOnChanges) {\n        definition.setInput = ngOnChangesSetInput;\n    }\n    return rememberChangeHistoryAndInvokeOnChangesHook;\n}\n// This option ensures that the ngOnChanges lifecycle hook will be inherited\n// from superclasses (in InheritDefinitionFeature).\n/** @nocollapse */\n// tslint:disable-next-line:no-toplevel-property-access\n\u0275\u0275NgOnChangesFeature.ngInherit = true;\n/**\n * This is a synthetic lifecycle hook which gets inserted into `TView.preOrderHooks` to simulate\n * `ngOnChanges`.\n *\n * The hook reads the `NgSimpleChangesStore` data from the component instance and if changes are\n * found it invokes `ngOnChanges` on the component instance.\n *\n * @param this Component instance. Because this function gets inserted into `TView.preOrderHooks`,\n *     it is guaranteed to be called with component instance.\n */\nfunction rememberChangeHistoryAndInvokeOnChangesHook() {\n    const simpleChangesStore = getSimpleChangesStore(this);\n    const current = simpleChangesStore?.current;\n    if (current) {\n        const previous = simpleChangesStore.previous;\n        if (previous === EMPTY_OBJ) {\n            simpleChangesStore.previous = current;\n        }\n        else {\n            // New changes are copied to the previous store, so that we don't lose history for inputs\n            // which were not changed this time\n            for (let key in current) {\n                previous[key] = current[key];\n            }\n        }\n        simpleChangesStore.current = null;\n        this.ngOnChanges(current);\n    }\n}\nfunction ngOnChangesSetInput(instance, value, publicName, privateName) {\n    const simpleChangesStore = getSimpleChangesStore(instance) ||\n        setSimpleChangesStore(instance, { previous: EMPTY_OBJ, current: null });\n    const current = simpleChangesStore.current || (simpleChangesStore.current = {});\n    const previous = simpleChangesStore.previous;\n    const declaredName = this.declaredInputs[publicName];\n    const previousChange = previous[declaredName];\n    current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);\n    instance[privateName] = value;\n}\nconst SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';\nfunction getSimpleChangesStore(instance) {\n    return instance[SIMPLE_CHANGES_STORE] || null;\n}\nfunction setSimpleChangesStore(instance, store) {\n    return instance[SIMPLE_CHANGES_STORE] = store;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet profilerCallback = null;\n/**\n * Sets the callback function which will be invoked before and after performing certain actions at\n * runtime (for example, before and after running change detection).\n *\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n * The contract of the function might be changed in any release and/or the function can be removed\n * completely.\n *\n * @param profiler function provided by the caller or null value to disable profiling.\n */\nconst setProfiler = (profiler) => {\n    profilerCallback = profiler;\n};\n/**\n * Profiler function which wraps user code executed by the runtime.\n *\n * @param event ProfilerEvent corresponding to the execution context\n * @param instance component instance\n * @param hookOrListener lifecycle hook function or output listener. The value depends on the\n *  execution context\n * @returns\n */\nconst profiler = function (event, instance, hookOrListener) {\n    if (profilerCallback != null /* both `null` and `undefined` */) {\n        profilerCallback(event, instance, hookOrListener);\n    }\n};\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst SVG_NAMESPACE = 'svg';\nconst SVG_NAMESPACE_URI = 'http://www.w3.org/2000/svg';\nconst MATH_ML_NAMESPACE = 'math';\nconst MATH_ML_NAMESPACE_URI = 'http://www.w3.org/1998/MathML/';\nfunction getNamespaceUri(namespace) {\n    const name = namespace.toLowerCase();\n    return name === SVG_NAMESPACE ? SVG_NAMESPACE_URI :\n        (name === MATH_ML_NAMESPACE ? MATH_ML_NAMESPACE_URI : null);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\n * in same location in `LView`. This is because we don't want to pre-allocate space for it\n * because the storage is sparse. This file contains utilities for dealing with such data types.\n *\n * How do we know what is stored at a given location in `LView`.\n * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\n * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\n *   - `typeof value[TYPE] === 'object'` => `LView`\n *      - This happens when we have a component at a given location\n *   - `typeof value[TYPE] === true` => `LContainer`\n *      - This happens when we have `LContainer` binding at a given location.\n *\n *\n * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\n */\n/**\n * Returns `RNode`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapRNode(value) {\n    while (Array.isArray(value)) {\n        value = value[HOST];\n    }\n    return value;\n}\n/**\n * Returns `LView` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapLView(value) {\n    while (Array.isArray(value)) {\n        // This check is same as `isLView()` but we don't call at as we don't want to call\n        // `Array.isArray()` twice and give JITer more work for inlining.\n        if (typeof value[TYPE] === 'object')\n            return value;\n        value = value[HOST];\n    }\n    return null;\n}\n/**\n * Returns `LContainer` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nfunction unwrapLContainer(value) {\n    while (Array.isArray(value)) {\n        // This check is same as `isLContainer()` but we don't call at as we don't want to call\n        // `Array.isArray()` twice and give JITer more work for inlining.\n        if (value[TYPE] === true)\n            return value;\n        value = value[HOST];\n    }\n    return null;\n}\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nfunction getNativeByIndex(index, lView) {\n    ngDevMode && assertIndexInRange(lView, index);\n    ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');\n    return unwrapRNode(lView[index]);\n}\n/**\n * Retrieve an `RNode` for a given `TNode` and `LView`.\n *\n * This function guarantees in dev mode to retrieve a non-null `RNode`.\n *\n * @param tNode\n * @param lView\n */\nfunction getNativeByTNode(tNode, lView) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    ngDevMode && assertIndexInRange(lView, tNode.index);\n    const node = unwrapRNode(lView[tNode.index]);\n    return node;\n}\n/**\n * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\n *\n * Some `TNode`s don't have associated `RNode`s. For example `Projection`\n *\n * @param tNode\n * @param lView\n */\nfunction getNativeByTNodeOrNull(tNode, lView) {\n    const index = tNode === null ? -1 : tNode.index;\n    if (index !== -1) {\n        ngDevMode && assertTNodeForLView(tNode, lView);\n        const node = unwrapRNode(lView[index]);\n        return node;\n    }\n    return null;\n}\n// fixme(misko): The return Type should be `TNode|null`\nfunction getTNode(tView, index) {\n    ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n    ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n    const tNode = tView.data[index];\n    ngDevMode && tNode !== null && assertTNode(tNode);\n    return tNode;\n}\n/** Retrieves a value from any `LView` or `TData`. */\nfunction load(view, index) {\n    ngDevMode && assertIndexInRange(view, index);\n    return view[index];\n}\nfunction getComponentLViewByIndex(nodeIndex, hostView) {\n    // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n    ngDevMode && assertIndexInRange(hostView, nodeIndex);\n    const slotValue = hostView[nodeIndex];\n    const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n    return lView;\n}\n/** Checks whether a given view is in creation mode */\nfunction isCreationMode(view) {\n    return (view[FLAGS] & 4 /* LViewFlags.CreationMode */) === 4 /* LViewFlags.CreationMode */;\n}\n/**\n * Returns a boolean for whether the view is attached to the change detection tree.\n *\n * Note: This determines whether a view should be checked, not whether it's inserted\n * into a container. For that, you'll want `viewAttachedToContainer` below.\n */\nfunction viewAttachedToChangeDetector(view) {\n    return (view[FLAGS] & 64 /* LViewFlags.Attached */) === 64 /* LViewFlags.Attached */;\n}\n/** Returns a boolean for whether the view is attached to a container. */\nfunction viewAttachedToContainer(view) {\n    return isLContainer(view[PARENT]);\n}\nfunction getConstant(consts, index) {\n    if (index === null || index === undefined)\n        return null;\n    ngDevMode && assertIndexInRange(consts, index);\n    return consts[index];\n}\n/**\n * Resets the pre-order hook flags of the view.\n * @param lView the LView on which the flags are reset\n */\nfunction resetPreOrderHookFlags(lView) {\n    lView[PREORDER_HOOK_FLAGS] = 0;\n}\n/**\n * Updates the `TRANSPLANTED_VIEWS_TO_REFRESH` counter on the `LContainer` as well as the parents\n * whose\n *  1. counter goes from 0 to 1, indicating that there is a new child that has a view to refresh\n *  or\n *  2. counter goes from 1 to 0, indicating there are no more descendant views to refresh\n */\nfunction updateTransplantedViewCount(lContainer, amount) {\n    lContainer[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;\n    let viewOrContainer = lContainer;\n    let parent = lContainer[PARENT];\n    while (parent !== null &&\n        ((amount === 1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 1) ||\n            (amount === -1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 0))) {\n        parent[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;\n        viewOrContainer = parent;\n        parent = parent[PARENT];\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst instructionState = {\n    lFrame: createLFrame(null),\n    bindingsEnabled: true,\n};\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n *\n * The `checkNoChanges` function is invoked only in ngDevMode=true and verifies that no unintended\n * changes exist in the change detector or its children.\n */\nlet _isInCheckNoChangesMode = false;\n/**\n * Returns true if the instruction state stack is empty.\n *\n * Intended to be called from tests only (tree shaken otherwise).\n */\nfunction specOnlyIsInstructionStateEmpty() {\n    return instructionState.lFrame.parent === null;\n}\nfunction getElementDepthCount() {\n    return instructionState.lFrame.elementDepthCount;\n}\nfunction increaseElementDepthCount() {\n    instructionState.lFrame.elementDepthCount++;\n}\nfunction decreaseElementDepthCount() {\n    instructionState.lFrame.elementDepthCount--;\n}\nfunction getBindingsEnabled() {\n    return instructionState.bindingsEnabled;\n}\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- \u0275\u0275disableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- \u0275\u0275enableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nfunction \u0275\u0275enableBindings() {\n    instructionState.bindingsEnabled = true;\n}\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- \u0275\u0275disableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- \u0275\u0275enableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nfunction \u0275\u0275disableBindings() {\n    instructionState.bindingsEnabled = false;\n}\n/**\n * Return the current `LView`.\n */\nfunction getLView() {\n    return instructionState.lFrame.lView;\n}\n/**\n * Return the current `TView`.\n */\nfunction getTView() {\n    return instructionState.lFrame.tView;\n}\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n * @returns Context of the restored OpaqueViewState instance.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275restoreView(viewToRestore) {\n    instructionState.lFrame.contextLView = viewToRestore;\n    return viewToRestore[CONTEXT];\n}\n/**\n * Clears the view set in `\u0275\u0275restoreView` from memory. Returns the passed in\n * value so that it can be used as a return value of an instruction.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275resetView(value) {\n    instructionState.lFrame.contextLView = null;\n    return value;\n}\nfunction getCurrentTNode() {\n    let currentTNode = getCurrentTNodePlaceholderOk();\n    while (currentTNode !== null && currentTNode.type === 64 /* TNodeType.Placeholder */) {\n        currentTNode = currentTNode.parent;\n    }\n    return currentTNode;\n}\nfunction getCurrentTNodePlaceholderOk() {\n    return instructionState.lFrame.currentTNode;\n}\nfunction getCurrentParentTNode() {\n    const lFrame = instructionState.lFrame;\n    const currentTNode = lFrame.currentTNode;\n    return lFrame.isParent ? currentTNode : currentTNode.parent;\n}\nfunction setCurrentTNode(tNode, isParent) {\n    ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n    const lFrame = instructionState.lFrame;\n    lFrame.currentTNode = tNode;\n    lFrame.isParent = isParent;\n}\nfunction isCurrentTNodeParent() {\n    return instructionState.lFrame.isParent;\n}\nfunction setCurrentTNodeAsNotParent() {\n    instructionState.lFrame.isParent = false;\n}\nfunction setCurrentTNodeAsParent() {\n    instructionState.lFrame.isParent = true;\n}\nfunction getContextLView() {\n    const contextLView = instructionState.lFrame.contextLView;\n    ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');\n    return contextLView;\n}\nfunction isInCheckNoChangesMode() {\n    !ngDevMode && throwError('Must never be called in production mode');\n    return _isInCheckNoChangesMode;\n}\nfunction setIsInCheckNoChangesMode(mode) {\n    !ngDevMode && throwError('Must never be called in production mode');\n    _isInCheckNoChangesMode = mode;\n}\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nfunction getBindingRoot() {\n    const lFrame = instructionState.lFrame;\n    let index = lFrame.bindingRootIndex;\n    if (index === -1) {\n        index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n    }\n    return index;\n}\nfunction getBindingIndex() {\n    return instructionState.lFrame.bindingIndex;\n}\nfunction setBindingIndex(value) {\n    return instructionState.lFrame.bindingIndex = value;\n}\nfunction nextBindingIndex() {\n    return instructionState.lFrame.bindingIndex++;\n}\nfunction incrementBindingIndex(count) {\n    const lFrame = instructionState.lFrame;\n    const index = lFrame.bindingIndex;\n    lFrame.bindingIndex = lFrame.bindingIndex + count;\n    return index;\n}\nfunction isInI18nBlock() {\n    return instructionState.lFrame.inI18n;\n}\nfunction setInI18nBlock(isInI18nBlock) {\n    instructionState.lFrame.inI18n = isInI18nBlock;\n}\n/**\n * Set a new binding root index so that host template functions can execute.\n *\n * Bindings inside the host template are 0 index. But because we don't know ahead of time\n * how many host bindings we have we can't pre-compute them. For this reason they are all\n * 0 index and we just shift the root so that they match next available location in the LView.\n *\n * @param bindingRootIndex Root index for `hostBindings`\n * @param currentDirectiveIndex `TData[currentDirectiveIndex]` will point to the current directive\n *        whose `hostBindings` are being processed.\n */\nfunction setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {\n    const lFrame = instructionState.lFrame;\n    lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n    setCurrentDirectiveIndex(currentDirectiveIndex);\n}\n/**\n * When host binding is executing this points to the directive index.\n * `TView.data[getCurrentDirectiveIndex()]` is `DirectiveDef`\n * `LView[getCurrentDirectiveIndex()]` is directive instance.\n */\nfunction getCurrentDirectiveIndex() {\n    return instructionState.lFrame.currentDirectiveIndex;\n}\n/**\n * Sets an index of a directive whose `hostBindings` are being processed.\n *\n * @param currentDirectiveIndex `TData` index where current directive instance can be found.\n */\nfunction setCurrentDirectiveIndex(currentDirectiveIndex) {\n    instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\n/**\n * Retrieve the current `DirectiveDef` which is active when `hostBindings` instruction is being\n * executed.\n *\n * @param tData Current `TData` where the `DirectiveDef` will be looked up at.\n */\nfunction getCurrentDirectiveDef(tData) {\n    const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\n    return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];\n}\nfunction getCurrentQueryIndex() {\n    return instructionState.lFrame.currentQueryIndex;\n}\nfunction setCurrentQueryIndex(value) {\n    instructionState.lFrame.currentQueryIndex = value;\n}\n/**\n * Returns a `TNode` of the location where the current `LView` is declared at.\n *\n * @param lView an `LView` that we want to find parent `TNode` for.\n */\nfunction getDeclarationTNode(lView) {\n    const tView = lView[TVIEW];\n    // Return the declaration parent for embedded views\n    if (tView.type === 2 /* TViewType.Embedded */) {\n        ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n        return tView.declTNode;\n    }\n    // Components don't have `TView.declTNode` because each instance of component could be\n    // inserted in different location, hence `TView.declTNode` is meaningless.\n    // Falling back to `T_HOST` in case we cross component boundary.\n    if (tView.type === 1 /* TViewType.Component */) {\n        return lView[T_HOST];\n    }\n    // Remaining TNode type is `TViewType.Root` which doesn't have a parent TNode.\n    return null;\n}\n/**\n * This is a light weight version of the `enterView` which is needed by the DI system.\n *\n * @param lView `LView` location of the DI context.\n * @param tNode `TNode` for DI context\n * @param flags DI context flags. if `SkipSelf` flag is set than we walk up the declaration\n *     tree from `tNode`  until we find parent declared `TElementNode`.\n * @returns `true` if we have successfully entered DI associated with `tNode` (or with declared\n *     `TNode` if `flags` has  `SkipSelf`). Failing to enter DI implies that no associated\n *     `NodeInjector` can be found and we should instead use `ModuleInjector`.\n *     - If `true` than this call must be fallowed by `leaveDI`\n *     - If `false` than this call failed and we should NOT call `leaveDI`\n */\nfunction enterDI(lView, tNode, flags) {\n    ngDevMode && assertLViewOrUndefined(lView);\n    if (flags & InjectFlags.SkipSelf) {\n        ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n        let parentTNode = tNode;\n        let parentLView = lView;\n        while (true) {\n            ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\n            parentTNode = parentTNode.parent;\n            if (parentTNode === null && !(flags & InjectFlags.Host)) {\n                parentTNode = getDeclarationTNode(parentLView);\n                if (parentTNode === null)\n                    break;\n                // In this case, a parent exists and is definitely an element. So it will definitely\n                // have an existing lView as the declaration view, which is why we can assume it's defined.\n                ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\n                parentLView = parentLView[DECLARATION_VIEW];\n                // In Ivy there are Comment nodes that correspond to ngIf and NgFor embedded directives\n                // We want to skip those and look only at Elements and ElementContainers to ensure\n                // we're looking at true parent nodes, and not content or other types.\n                if (parentTNode.type & (2 /* TNodeType.Element */ | 8 /* TNodeType.ElementContainer */)) {\n                    break;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        if (parentTNode === null) {\n            // If we failed to find a parent TNode this means that we should use module injector.\n            return false;\n        }\n        else {\n            tNode = parentTNode;\n            lView = parentLView;\n        }\n    }\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    const lFrame = instructionState.lFrame = allocLFrame();\n    lFrame.currentTNode = tNode;\n    lFrame.lView = lView;\n    return true;\n}\n/**\n * Swap the current lView with a new lView.\n *\n * For performance reasons we store the lView in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the lView for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New lView to become active\n * @returns the previously active lView;\n */\nfunction enterView(newView) {\n    ngDevMode && assertNotEqual(newView[0], newView[1], '????');\n    ngDevMode && assertLViewOrUndefined(newView);\n    const newLFrame = allocLFrame();\n    if (ngDevMode) {\n        assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');\n        assertEqual(newLFrame.lView, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.tView, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');\n        assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');\n        assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');\n    }\n    const tView = newView[TVIEW];\n    instructionState.lFrame = newLFrame;\n    ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\n    newLFrame.currentTNode = tView.firstChild;\n    newLFrame.lView = newView;\n    newLFrame.tView = tView;\n    newLFrame.contextLView = newView;\n    newLFrame.bindingIndex = tView.bindingStartIndex;\n    newLFrame.inI18n = false;\n}\n/**\n * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.\n */\nfunction allocLFrame() {\n    const currentLFrame = instructionState.lFrame;\n    const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n    const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n    return newLFrame;\n}\nfunction createLFrame(parent) {\n    const lFrame = {\n        currentTNode: null,\n        isParent: true,\n        lView: null,\n        tView: null,\n        selectedIndex: -1,\n        contextLView: null,\n        elementDepthCount: 0,\n        currentNamespace: null,\n        currentDirectiveIndex: -1,\n        bindingRootIndex: -1,\n        bindingIndex: -1,\n        currentQueryIndex: 0,\n        parent: parent,\n        child: null,\n        inI18n: false,\n    };\n    parent !== null && (parent.child = lFrame); // link the new LFrame for reuse.\n    return lFrame;\n}\n/**\n * A lightweight version of leave which is used with DI.\n *\n * This function only resets `currentTNode` and `LView` as those are the only properties\n * used with DI (`enterDI()`).\n *\n * NOTE: This function is reexported as `leaveDI`. However `leaveDI` has return type of `void` where\n * as `leaveViewLight` has `LFrame`. This is so that `leaveViewLight` can be used in `leaveView`.\n */\nfunction leaveViewLight() {\n    const oldLFrame = instructionState.lFrame;\n    instructionState.lFrame = oldLFrame.parent;\n    oldLFrame.currentTNode = null;\n    oldLFrame.lView = null;\n    return oldLFrame;\n}\n/**\n * This is a lightweight version of the `leaveView` which is needed by the DI system.\n *\n * NOTE: this function is an alias so that we can change the type of the function to have `void`\n * return type.\n */\nconst leaveDI = leaveViewLight;\n/**\n * Leave the current `LView`\n *\n * This pops the `LFrame` with the associated `LView` from the stack.\n *\n * IMPORTANT: We must zero out the `LFrame` values here otherwise they will be retained. This is\n * because for performance reasons we don't release `LFrame` but rather keep it for next use.\n */\nfunction leaveView() {\n    const oldLFrame = leaveViewLight();\n    oldLFrame.isParent = true;\n    oldLFrame.tView = null;\n    oldLFrame.selectedIndex = -1;\n    oldLFrame.contextLView = null;\n    oldLFrame.elementDepthCount = 0;\n    oldLFrame.currentDirectiveIndex = -1;\n    oldLFrame.currentNamespace = null;\n    oldLFrame.bindingRootIndex = -1;\n    oldLFrame.bindingIndex = -1;\n    oldLFrame.currentQueryIndex = 0;\n}\nfunction nextContextImpl(level) {\n    const contextLView = instructionState.lFrame.contextLView =\n        walkUpViews(level, instructionState.lFrame.contextLView);\n    return contextLView[CONTEXT];\n}\nfunction walkUpViews(nestingLevel, currentView) {\n    while (nestingLevel > 0) {\n        ngDevMode &&\n            assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');\n        currentView = currentView[DECLARATION_VIEW];\n        nestingLevel--;\n    }\n    return currentView;\n}\n/**\n * Gets the currently selected element index.\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n */\nfunction getSelectedIndex() {\n    return instructionState.lFrame.selectedIndex;\n}\n/**\n * Sets the most recent index passed to {@link select}\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n *\n * (Note that if an \"exit function\" was set earlier (via `setElementExitFn()`) then that will be\n * run if and when the provided `index` value is different from the current selected index value.)\n */\nfunction setSelectedIndex(index) {\n    ngDevMode && index !== -1 &&\n        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');\n    ngDevMode &&\n        assertLessThan(index, instructionState.lFrame.lView.length, 'Can\\'t set index passed end of LView');\n    instructionState.lFrame.selectedIndex = index;\n}\n/**\n * Gets the `tNode` that represents currently selected element.\n */\nfunction getSelectedTNode() {\n    const lFrame = instructionState.lFrame;\n    return getTNode(lFrame.tView, lFrame.selectedIndex);\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275namespaceSVG() {\n    instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275namespaceMathML() {\n    instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275namespaceHTML() {\n    namespaceHTMLInternal();\n}\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n */\nfunction namespaceHTMLInternal() {\n    instructionState.lFrame.currentNamespace = null;\n}\nfunction getNamespace$1() {\n    return instructionState.lFrame.currentNamespace;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Adds all directive lifecycle hooks from the given `DirectiveDef` to the given `TView`.\n *\n * Must be run *only* on the first template pass.\n *\n * Sets up the pre-order hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * @param directiveIndex The index of the directive in LView\n * @param directiveDef The definition containing the hooks to setup in tView\n * @param tView The current TView\n */\nfunction registerPreOrderHooks(directiveIndex, directiveDef, tView) {\n    ngDevMode && assertFirstCreatePass(tView);\n    const { ngOnChanges, ngOnInit, ngDoCheck } = directiveDef.type.prototype;\n    if (ngOnChanges) {\n        const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);\n        (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, wrappedOnChanges);\n        (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = []))\n            .push(directiveIndex, wrappedOnChanges);\n    }\n    if (ngOnInit) {\n        (tView.preOrderHooks || (tView.preOrderHooks = [])).push(0 - directiveIndex, ngOnInit);\n    }\n    if (ngDoCheck) {\n        (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, ngDoCheck);\n        (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, ngDoCheck);\n    }\n}\n/**\n *\n * Loops through the directives on the provided `tNode` and queues hooks to be\n * run that are not initialization hooks.\n *\n * Should be executed during `elementEnd()` and similar to\n * preserve hook execution order. Content, view, and destroy hooks for projected\n * components and directives must be called *before* their hosts.\n *\n * Sets up the content, view, and destroy hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * NOTE: This does not set up `onChanges`, `onInit` or `doCheck`, those are set up\n * separately at `elementStart`.\n *\n * @param tView The current TView\n * @param tNode The TNode whose directives are to be searched for hooks to queue\n */\nfunction registerPostOrderHooks(tView, tNode) {\n    ngDevMode && assertFirstCreatePass(tView);\n    // It's necessary to loop through the directives at elementEnd() (rather than processing in\n    // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\n    // hooks for projected components and directives must be called *before* their hosts.\n    for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {\n        const directiveDef = tView.data[i];\n        ngDevMode && assertDefined(directiveDef, 'Expecting DirectiveDef');\n        const lifecycleHooks = directiveDef.type.prototype;\n        const { ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy } = lifecycleHooks;\n        if (ngAfterContentInit) {\n            (tView.contentHooks || (tView.contentHooks = [])).push(-i, ngAfterContentInit);\n        }\n        if (ngAfterContentChecked) {\n            (tView.contentHooks || (tView.contentHooks = [])).push(i, ngAfterContentChecked);\n            (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, ngAfterContentChecked);\n        }\n        if (ngAfterViewInit) {\n            (tView.viewHooks || (tView.viewHooks = [])).push(-i, ngAfterViewInit);\n        }\n        if (ngAfterViewChecked) {\n            (tView.viewHooks || (tView.viewHooks = [])).push(i, ngAfterViewChecked);\n            (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, ngAfterViewChecked);\n        }\n        if (ngOnDestroy != null) {\n            (tView.destroyHooks || (tView.destroyHooks = [])).push(i, ngOnDestroy);\n        }\n    }\n}\n/**\n * Executing hooks requires complex logic as we need to deal with 2 constraints.\n *\n * 1. Init hooks (ngOnInit, ngAfterContentInit, ngAfterViewInit) must all be executed once and only\n * once, across many change detection cycles. This must be true even if some hooks throw, or if\n * some recursively trigger a change detection cycle.\n * To solve that, it is required to track the state of the execution of these init hooks.\n * This is done by storing and maintaining flags in the view: the {@link InitPhaseState},\n * and the index within that phase. They can be seen as a cursor in the following structure:\n * [[onInit1, onInit2], [afterContentInit1], [afterViewInit1, afterViewInit2, afterViewInit3]]\n * They are are stored as flags in LView[FLAGS].\n *\n * 2. Pre-order hooks can be executed in batches, because of the select instruction.\n * To be able to pause and resume their execution, we also need some state about the hook's array\n * that is being processed:\n * - the index of the next hook to be executed\n * - the number of init hooks already found in the processed part of the  array\n * They are are stored as flags in LView[PREORDER_HOOK_FLAGS].\n */\n/**\n * Executes pre-order check hooks ( OnChanges, DoChanges) given a view where all the init hooks were\n * executed once. This is a light version of executeInitAndCheckPreOrderHooks where we can skip read\n * / write of the init-hooks related flags.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction executeCheckHooks(lView, hooks, nodeIndex) {\n    callHooks(lView, hooks, 3 /* InitPhaseState.InitPhaseCompleted */, nodeIndex);\n}\n/**\n * Executes post-order init and check hooks (one of AfterContentInit, AfterContentChecked,\n * AfterViewInit, AfterViewChecked) given a view where there are pending init hooks to be executed.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param initPhase A phase for which hooks should be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {\n    ngDevMode &&\n        assertNotEqual(initPhase, 3 /* InitPhaseState.InitPhaseCompleted */, 'Init pre-order hooks should not be called more than once');\n    if ((lView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n        callHooks(lView, hooks, initPhase, nodeIndex);\n    }\n}\nfunction incrementInitPhaseFlags(lView, initPhase) {\n    ngDevMode &&\n        assertNotEqual(initPhase, 3 /* InitPhaseState.InitPhaseCompleted */, 'Init hooks phase should not be incremented after all init hooks have been run.');\n    let flags = lView[FLAGS];\n    if ((flags & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n        flags &= 2047 /* LViewFlags.IndexWithinInitPhaseReset */;\n        flags += 1 /* LViewFlags.InitPhaseStateIncrementer */;\n        lView[FLAGS] = flags;\n    }\n}\n/**\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\n * the first LView pass\n *\n * @param currentView The current view\n * @param arr The array in which the hooks are found\n * @param initPhaseState the current state of the init phase\n * @param currentNodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction callHooks(currentView, arr, initPhase, currentNodeIndex) {\n    ngDevMode &&\n        assertEqual(isInCheckNoChangesMode(), false, 'Hooks should never be run when in check no changes mode.');\n    const startIndex = currentNodeIndex !== undefined ?\n        (currentView[PREORDER_HOOK_FLAGS] & 65535 /* PreOrderHookFlags.IndexOfTheNextPreOrderHookMaskMask */) :\n        0;\n    const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;\n    const max = arr.length - 1; // Stop the loop at length - 1, because we look for the hook at i + 1\n    let lastNodeIndexFound = 0;\n    for (let i = startIndex; i < max; i++) {\n        const hook = arr[i + 1];\n        if (typeof hook === 'number') {\n            lastNodeIndexFound = arr[i];\n            if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {\n                break;\n            }\n        }\n        else {\n            const isInitHook = arr[i] < 0;\n            if (isInitHook)\n                currentView[PREORDER_HOOK_FLAGS] += 65536 /* PreOrderHookFlags.NumberOfInitHooksCalledIncrementer */;\n            if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {\n                callHook(currentView, initPhase, arr, i);\n                currentView[PREORDER_HOOK_FLAGS] =\n                    (currentView[PREORDER_HOOK_FLAGS] & 4294901760 /* PreOrderHookFlags.NumberOfInitHooksCalledMask */) + i +\n                        2;\n            }\n            i++;\n        }\n    }\n}\n/**\n * Execute one hook against the current `LView`.\n *\n * @param currentView The current view\n * @param initPhaseState the current state of the init phase\n * @param arr The array in which the hooks are found\n * @param i The current index within the hook data array\n */\nfunction callHook(currentView, initPhase, arr, i) {\n    const isInitHook = arr[i] < 0;\n    const hook = arr[i + 1];\n    const directiveIndex = isInitHook ? -arr[i] : arr[i];\n    const directive = currentView[directiveIndex];\n    if (isInitHook) {\n        const indexWithintInitPhase = currentView[FLAGS] >> 11 /* LViewFlags.IndexWithinInitPhaseShift */;\n        // The init phase state must be always checked here as it may have been recursively updated.\n        if (indexWithintInitPhase <\n            (currentView[PREORDER_HOOK_FLAGS] >> 16 /* PreOrderHookFlags.NumberOfInitHooksCalledShift */) &&\n            (currentView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === initPhase) {\n            currentView[FLAGS] += 2048 /* LViewFlags.IndexWithinInitPhaseIncrementer */;\n            profiler(4 /* ProfilerEvent.LifecycleHookStart */, directive, hook);\n            try {\n                hook.call(directive);\n            }\n            finally {\n                profiler(5 /* ProfilerEvent.LifecycleHookEnd */, directive, hook);\n            }\n        }\n    }\n    else {\n        profiler(4 /* ProfilerEvent.LifecycleHookStart */, directive, hook);\n        try {\n            hook.call(directive);\n        }\n        finally {\n            profiler(5 /* ProfilerEvent.LifecycleHookEnd */, directive, hook);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst NO_PARENT_INJECTOR = -1;\n/**\n * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in\n * `TView.data`. This allows us to store information about the current node's tokens (which\n * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be\n * shared, so they live in `LView`).\n *\n * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter\n * determines whether a directive is available on the associated node or not. This prevents us\n * from searching the directives array at this level unless it's probable the directive is in it.\n *\n * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\n *\n * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed\n * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`\n * will differ based on where it is flattened into the main array, so it's not possible to know\n * the indices ahead of time and save their types here. The interfaces are still included here\n * for documentation purposes.\n *\n * export interface LInjector extends Array<any> {\n *\n *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Cumulative bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Cumulative bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Cumulative bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Cumulative bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Cumulative bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Cumulative bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Cumulative bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // We need to store a reference to the injector's parent so DI can keep looking up\n *    // the injector tree until it finds the dependency it's looking for.\n *    [PARENT_INJECTOR]: number;\n * }\n *\n * export interface TInjector extends Array<any> {\n *\n *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Shared node bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Shared node bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Shared node bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Shared node bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Shared node bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Shared node bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Shared node bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // Necessary to find directive indices for a particular node.\n *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;\n *  }\n */\n/**\n * Factory for creating instances of injectors in the NodeInjector.\n *\n * This factory is complicated by the fact that it can resolve `multi` factories as well.\n *\n * NOTE: Some of the fields are optional which means that this class has two hidden classes.\n * - One without `multi` support (most common)\n * - One with `multi` values, (rare).\n *\n * Since VMs can cache up to 4 inline hidden classes this is OK.\n *\n * - Single factory: Only `resolving` and `factory` is defined.\n * - `providers` factory: `componentProviders` is a number and `index = -1`.\n * - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.\n */\nclass NodeInjectorFactory {\n    constructor(\n    /**\n     * Factory to invoke in order to create a new instance.\n     */\n    factory, \n    /**\n     * Set to `true` if the token is declared in `viewProviders` (or if it is component).\n     */\n    isViewProvider, injectImplementation) {\n        this.factory = factory;\n        /**\n         * Marker set to true during factory invocation to see if we get into recursive loop.\n         * Recursive loop causes an error to be displayed.\n         */\n        this.resolving = false;\n        ngDevMode && assertDefined(factory, 'Factory not specified');\n        ngDevMode && assertEqual(typeof factory, 'function', 'Expected factory function.');\n        this.canSeeViewProviders = isViewProvider;\n        this.injectImpl = injectImplementation;\n    }\n}\nfunction isFactory(obj) {\n    return obj instanceof NodeInjectorFactory;\n}\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$6 = 1;\n\n/**\n * Converts `TNodeType` into human readable text.\n * Make sure this matches with `TNodeType`\n */\nfunction toTNodeTypeAsString(tNodeType) {\n    let text = '';\n    (tNodeType & 1 /* TNodeType.Text */) && (text += '|Text');\n    (tNodeType & 2 /* TNodeType.Element */) && (text += '|Element');\n    (tNodeType & 4 /* TNodeType.Container */) && (text += '|Container');\n    (tNodeType & 8 /* TNodeType.ElementContainer */) && (text += '|ElementContainer');\n    (tNodeType & 16 /* TNodeType.Projection */) && (text += '|Projection');\n    (tNodeType & 32 /* TNodeType.Icu */) && (text += '|IcuContainer');\n    (tNodeType & 64 /* TNodeType.Placeholder */) && (text += '|Placeholder');\n    return text.length > 0 ? text.substring(1) : text;\n}\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$5 = 1;\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `class` binding.\n *\n * ```\n * <div my-dir [class]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nfunction hasClassInput(tNode) {\n    return (tNode.flags & 16 /* TNodeFlags.hasClassInput */) !== 0;\n}\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `style` binding.\n *\n * ```\n * <div my-dir [style]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nfunction hasStyleInput(tNode) {\n    return (tNode.flags & 32 /* TNodeFlags.hasStyleInput */) !== 0;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction assertTNodeType(tNode, expectedTypes, message) {\n    assertDefined(tNode, 'should be called with a TNode');\n    if ((tNode.type & expectedTypes) === 0) {\n        throwError(message ||\n            `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);\n    }\n}\nfunction assertPureTNodeType(type) {\n    if (!(type === 2 /* TNodeType.Element */ || //\n        type === 1 /* TNodeType.Text */ || //\n        type === 4 /* TNodeType.Container */ || //\n        type === 8 /* TNodeType.ElementContainer */ || //\n        type === 32 /* TNodeType.Icu */ || //\n        type === 16 /* TNodeType.Projection */ || //\n        type === 64 /* TNodeType.Placeholder */)) {\n        throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);\n    }\n}\n\n/**\n * Assigns all attribute values to the provided element via the inferred renderer.\n *\n * This function accepts two forms of attribute entries:\n *\n * default: (key, value):\n *  attrs = [key1, value1, key2, value2]\n *\n * namespaced: (NAMESPACE_MARKER, uri, name, value)\n *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]\n *\n * The `attrs` array can contain a mix of both the default and namespaced entries.\n * The \"default\" values are set without a marker, but if the function comes across\n * a marker value then it will attempt to set a namespaced value. If the marker is\n * not of a namespaced value then the function will quit and return the index value\n * where it stopped during the iteration of the attrs array.\n *\n * See [AttributeMarker] to understand what the namespace marker value is.\n *\n * Note that this instruction does not support assigning style and class values to\n * an element. See `elementStart` and `elementHostAttrs` to learn how styling values\n * are applied to an element.\n * @param renderer The renderer to be used\n * @param native The element that the attributes will be assigned to\n * @param attrs The attribute array of values that will be assigned to the element\n * @returns the index value that was last accessed in the attributes array\n */\nfunction setUpAttributes(renderer, native, attrs) {\n    let i = 0;\n    while (i < attrs.length) {\n        const value = attrs[i];\n        if (typeof value === 'number') {\n            // only namespaces are supported. Other value types (such as style/class\n            // entries) are not supported in this function.\n            if (value !== 0 /* AttributeMarker.NamespaceURI */) {\n                break;\n            }\n            // we just landed on the marker value ... therefore\n            // we should skip to the next entry\n            i++;\n            const namespaceURI = attrs[i++];\n            const attrName = attrs[i++];\n            const attrVal = attrs[i++];\n            ngDevMode && ngDevMode.rendererSetAttribute++;\n            renderer.setAttribute(native, attrName, attrVal, namespaceURI);\n        }\n        else {\n            // attrName is string;\n            const attrName = value;\n            const attrVal = attrs[++i];\n            // Standard attributes\n            ngDevMode && ngDevMode.rendererSetAttribute++;\n            if (isAnimationProp(attrName)) {\n                renderer.setProperty(native, attrName, attrVal);\n            }\n            else {\n                renderer.setAttribute(native, attrName, attrVal);\n            }\n            i++;\n        }\n    }\n    // another piece of code may iterate over the same attributes array. Therefore\n    // it may be helpful to return the exact spot where the attributes array exited\n    // whether by running into an unsupported marker or if all the static values were\n    // iterated over.\n    return i;\n}\n/**\n * Test whether the given value is a marker that indicates that the following\n * attribute values in a `TAttributes` array are only the names of attributes,\n * and not name-value pairs.\n * @param marker The attribute marker to test.\n * @returns true if the marker is a \"name-only\" marker (e.g. `Bindings`, `Template` or `I18n`).\n */\nfunction isNameOnlyAttributeMarker(marker) {\n    return marker === 3 /* AttributeMarker.Bindings */ || marker === 4 /* AttributeMarker.Template */ ||\n        marker === 6 /* AttributeMarker.I18n */;\n}\nfunction isAnimationProp(name) {\n    // Perf note: accessing charCodeAt to check for the first character of a string is faster as\n    // compared to accessing a character at index 0 (ex. name[0]). The main reason for this is that\n    // charCodeAt doesn't allocate memory to return a substring.\n    return name.charCodeAt(0) === 64 /* CharCode.AT_SIGN */;\n}\n/**\n * Merges `src` `TAttributes` into `dst` `TAttributes` removing any duplicates in the process.\n *\n * This merge function keeps the order of attrs same.\n *\n * @param dst Location of where the merged `TAttributes` should end up.\n * @param src `TAttributes` which should be appended to `dst`\n */\nfunction mergeHostAttrs(dst, src) {\n    if (src === null || src.length === 0) {\n        // do nothing\n    }\n    else if (dst === null || dst.length === 0) {\n        // We have source, but dst is empty, just make a copy.\n        dst = src.slice();\n    }\n    else {\n        let srcMarker = -1 /* AttributeMarker.ImplicitAttributes */;\n        for (let i = 0; i < src.length; i++) {\n            const item = src[i];\n            if (typeof item === 'number') {\n                srcMarker = item;\n            }\n            else {\n                if (srcMarker === 0 /* AttributeMarker.NamespaceURI */) {\n                    // Case where we need to consume `key1`, `key2`, `value` items.\n                }\n                else if (srcMarker === -1 /* AttributeMarker.ImplicitAttributes */ ||\n                    srcMarker === 2 /* AttributeMarker.Styles */) {\n                    // Case where we have to consume `key1` and `value` only.\n                    mergeHostAttribute(dst, srcMarker, item, null, src[++i]);\n                }\n                else {\n                    // Case where we have to consume `key1` only.\n                    mergeHostAttribute(dst, srcMarker, item, null, null);\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Append `key`/`value` to existing `TAttributes` taking region marker and duplicates into account.\n *\n * @param dst `TAttributes` to append to.\n * @param marker Region where the `key`/`value` should be added.\n * @param key1 Key to add to `TAttributes`\n * @param key2 Key to add to `TAttributes` (in case of `AttributeMarker.NamespaceURI`)\n * @param value Value to add or to overwrite to `TAttributes` Only used if `marker` is not Class.\n */\nfunction mergeHostAttribute(dst, marker, key1, key2, value) {\n    let i = 0;\n    // Assume that new markers will be inserted at the end.\n    let markerInsertPosition = dst.length;\n    // scan until correct type.\n    if (marker === -1 /* AttributeMarker.ImplicitAttributes */) {\n        markerInsertPosition = -1;\n    }\n    else {\n        while (i < dst.length) {\n            const dstValue = dst[i++];\n            if (typeof dstValue === 'number') {\n                if (dstValue === marker) {\n                    markerInsertPosition = -1;\n                    break;\n                }\n                else if (dstValue > marker) {\n                    // We need to save this as we want the markers to be inserted in specific order.\n                    markerInsertPosition = i - 1;\n                    break;\n                }\n            }\n        }\n    }\n    // search until you find place of insertion\n    while (i < dst.length) {\n        const item = dst[i];\n        if (typeof item === 'number') {\n            // since `i` started as the index after the marker, we did not find it if we are at the next\n            // marker\n            break;\n        }\n        else if (item === key1) {\n            // We already have same token\n            if (key2 === null) {\n                if (value !== null) {\n                    dst[i + 1] = value;\n                }\n                return;\n            }\n            else if (key2 === dst[i + 1]) {\n                dst[i + 2] = value;\n                return;\n            }\n        }\n        // Increment counter.\n        i++;\n        if (key2 !== null)\n            i++;\n        if (value !== null)\n            i++;\n    }\n    // insert at location.\n    if (markerInsertPosition !== -1) {\n        dst.splice(markerInsertPosition, 0, marker);\n        i = markerInsertPosition + 1;\n    }\n    dst.splice(i++, 0, key1);\n    if (key2 !== null) {\n        dst.splice(i++, 0, key2);\n    }\n    if (value !== null) {\n        dst.splice(i++, 0, value);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// Parent Injector Utils ///////////////////////////////////////////////////////////////\nfunction hasParentInjector(parentLocation) {\n    return parentLocation !== NO_PARENT_INJECTOR;\n}\nfunction getParentInjectorIndex(parentLocation) {\n    ngDevMode && assertNumber(parentLocation, 'Number expected');\n    ngDevMode && assertNotEqual(parentLocation, -1, 'Not a valid state.');\n    const parentInjectorIndex = parentLocation & 32767 /* RelativeInjectorLocationFlags.InjectorIndexMask */;\n    ngDevMode &&\n        assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, 'Parent injector must be pointing past HEADER_OFFSET.');\n    return parentLocation & 32767 /* RelativeInjectorLocationFlags.InjectorIndexMask */;\n}\nfunction getParentInjectorViewOffset(parentLocation) {\n    return parentLocation >> 16 /* RelativeInjectorLocationFlags.ViewOffsetShift */;\n}\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @returns The LView instance that contains the parent injector\n */\nfunction getParentInjectorView(location, startView) {\n    let viewOffset = getParentInjectorViewOffset(location);\n    let parentView = startView;\n    // For most cases, the parent injector can be found on the host node (e.g. for component\n    // or container), but we must keep the loop here to support the rarer case of deeply nested\n    // <ng-template> tags or inline views, where the parent injector might live many views\n    // above the child injector.\n    while (viewOffset > 0) {\n        parentView = parentView[DECLARATION_VIEW];\n        viewOffset--;\n    }\n    return parentView;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Defines if the call to `inject` should include `viewProviders` in its resolution.\n *\n * This is set to true when we try to instantiate a component. This value is reset in\n * `getNodeInjectable` to a value which matches the declaration location of the token about to be\n * instantiated. This is done so that if we are injecting a token which was declared outside of\n * `viewProviders` we don't accidentally pull `viewProviders` in.\n *\n * Example:\n *\n * ```\n * @Injectable()\n * class MyService {\n *   constructor(public value: String) {}\n * }\n *\n * @Component({\n *   providers: [\n *     MyService,\n *     {provide: String, value: 'providers' }\n *   ]\n *   viewProviders: [\n *     {provide: String, value: 'viewProviders'}\n *   ]\n * })\n * class MyComponent {\n *   constructor(myService: MyService, value: String) {\n *     // We expect that Component can see into `viewProviders`.\n *     expect(value).toEqual('viewProviders');\n *     // `MyService` was not declared in `viewProviders` hence it can't see it.\n *     expect(myService.value).toEqual('providers');\n *   }\n * }\n *\n * ```\n */\nlet includeViewProviders = true;\nfunction setIncludeViewProviders(v) {\n    const oldValue = includeViewProviders;\n    includeViewProviders = v;\n    return oldValue;\n}\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n/**\n * The number of bits that is represented by a single bloom bucket. JS bit operations are 32 bits,\n * so each bucket represents 32 distinct tokens which accounts for log2(32) = 5 bits of a bloom hash\n * number.\n */\nconst BLOOM_BUCKET_BITS = 5;\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n/** Value used when something wasn't found by an injector. */\nconst NOT_FOUND = {};\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nfunction bloomAdd(injectorIndex, tView, type) {\n    ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');\n    let id;\n    if (typeof type === 'string') {\n        id = type.charCodeAt(0) || 0;\n    }\n    else if (type.hasOwnProperty(NG_ELEMENT_ID)) {\n        id = type[NG_ELEMENT_ID];\n    }\n    // Set a unique ID on the directive type, so if something tries to inject the directive,\n    // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n    if (id == null) {\n        id = type[NG_ELEMENT_ID] = nextNgElementId++;\n    }\n    // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n    // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n    const bloomHash = id & BLOOM_MASK;\n    // Create a mask that targets the specific bit associated with the directive.\n    // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n    // to bit positions 0 - 31 in a 32 bit integer.\n    const mask = 1 << bloomHash;\n    // Each bloom bucket in `tData` represents `BLOOM_BUCKET_BITS` number of bits of `bloomHash`.\n    // Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset that the mask\n    // should be written to.\n    tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;\n}\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param lView View where the node is stored\n * @returns Node injector\n */\nfunction getOrCreateNodeInjectorForNode(tNode, lView) {\n    const existingInjectorIndex = getInjectorIndex(tNode, lView);\n    if (existingInjectorIndex !== -1) {\n        return existingInjectorIndex;\n    }\n    const tView = lView[TVIEW];\n    if (tView.firstCreatePass) {\n        tNode.injectorIndex = lView.length;\n        insertBloom(tView.data, tNode); // foundation for node bloom\n        insertBloom(lView, null); // foundation for cumulative bloom\n        insertBloom(tView.blueprint, null);\n    }\n    const parentLoc = getParentInjectorLocation(tNode, lView);\n    const injectorIndex = tNode.injectorIndex;\n    // If a parent injector can't be found, its location is set to -1.\n    // In that case, we don't need to set up a cumulative bloom\n    if (hasParentInjector(parentLoc)) {\n        const parentIndex = getParentInjectorIndex(parentLoc);\n        const parentLView = getParentInjectorView(parentLoc, lView);\n        const parentData = parentLView[TVIEW].data;\n        // Creates a cumulative bloom filter that merges the parent's bloom filter\n        // and its own cumulative bloom (which contains tokens for all ancestors)\n        for (let i = 0; i < 8 /* NodeInjectorOffset.BLOOM_SIZE */; i++) {\n            lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n        }\n    }\n    lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */] = parentLoc;\n    return injectorIndex;\n}\nfunction insertBloom(arr, footer) {\n    arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\nfunction getInjectorIndex(tNode, lView) {\n    if (tNode.injectorIndex === -1 ||\n        // If the injector index is the same as its parent's injector index, then the index has been\n        // copied down from the parent node. No injector has been created yet on this node.\n        (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||\n        // After the first template pass, the injector index might exist but the parent values\n        // might not have been calculated yet for this instance\n        lView[tNode.injectorIndex + 8 /* NodeInjectorOffset.PARENT */] === null) {\n        return -1;\n    }\n    else {\n        ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);\n        return tNode.injectorIndex;\n    }\n}\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * @returns Returns a number that is the combination of the number of LViews that we have to go up\n * to find the LView containing the parent inject AND the index of the injector within that LView.\n */\nfunction getParentInjectorLocation(tNode, lView) {\n    if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n        // If we have a parent `TNode` and there is an injector associated with it we are done, because\n        // the parent injector is within the current `LView`.\n        return tNode.parent.injectorIndex; // ViewOffset is 0\n    }\n    // When parent injector location is computed it may be outside of the current view. (ie it could\n    // be pointing to a declared parent location). This variable stores number of declaration parents\n    // we need to walk up in order to find the parent injector location.\n    let declarationViewOffset = 0;\n    let parentTNode = null;\n    let lViewCursor = lView;\n    // The parent injector is not in the current `LView`. We will have to walk the declared parent\n    // `LView` hierarchy and look for it. If we walk of the top, that means that there is no parent\n    // `NodeInjector`.\n    while (lViewCursor !== null) {\n        parentTNode = getTNodeFromLView(lViewCursor);\n        if (parentTNode === null) {\n            // If we have no parent, than we are done.\n            return NO_PARENT_INJECTOR;\n        }\n        ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);\n        // Every iteration of the loop requires that we go to the declared parent.\n        declarationViewOffset++;\n        lViewCursor = lViewCursor[DECLARATION_VIEW];\n        if (parentTNode.injectorIndex !== -1) {\n            // We found a NodeInjector which points to something.\n            return (parentTNode.injectorIndex |\n                (declarationViewOffset << 16 /* RelativeInjectorLocationFlags.ViewOffsetShift */));\n        }\n    }\n    return NO_PARENT_INJECTOR;\n}\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\nfunction diPublicInInjector(injectorIndex, tView, token) {\n    bloomAdd(injectorIndex, tView, token);\n}\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.\u0275cmp = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\nfunction injectAttributeImpl(tNode, attrNameToInject) {\n    ngDevMode && assertTNodeType(tNode, 12 /* TNodeType.AnyContainer */ | 3 /* TNodeType.AnyRNode */);\n    ngDevMode && assertDefined(tNode, 'expecting tNode');\n    if (attrNameToInject === 'class') {\n        return tNode.classes;\n    }\n    if (attrNameToInject === 'style') {\n        return tNode.styles;\n    }\n    const attrs = tNode.attrs;\n    if (attrs) {\n        const attrsLength = attrs.length;\n        let i = 0;\n        while (i < attrsLength) {\n            const value = attrs[i];\n            // If we hit a `Bindings` or `Template` marker then we are done.\n            if (isNameOnlyAttributeMarker(value))\n                break;\n            // Skip namespaced attributes\n            if (value === 0 /* AttributeMarker.NamespaceURI */) {\n                // we skip the next two values\n                // as namespaced attributes looks like\n                // [..., AttributeMarker.NamespaceURI, 'http://someuri.com/test', 'test:exist',\n                // 'existValue', ...]\n                i = i + 2;\n            }\n            else if (typeof value === 'number') {\n                // Skip to the first value of the marked attribute.\n                i++;\n                while (i < attrsLength && typeof attrs[i] === 'string') {\n                    i++;\n                }\n            }\n            else if (value === attrNameToInject) {\n                return attrs[i + 1];\n            }\n            else {\n                i = i + 2;\n            }\n        }\n    }\n    return null;\n}\nfunction notFoundValueOrThrow(notFoundValue, token, flags) {\n    if ((flags & InjectFlags.Optional) || notFoundValue !== undefined) {\n        return notFoundValue;\n    }\n    else {\n        throwProviderNotFoundError(token, 'NodeInjector');\n    }\n}\n/**\n * Returns the value associated to the given token from the ModuleInjector or throws exception\n *\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector or throws an exception\n */\nfunction lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {\n    if ((flags & InjectFlags.Optional) && notFoundValue === undefined) {\n        // This must be set or the NullInjector will throw for optional deps\n        notFoundValue = null;\n    }\n    if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n        const moduleInjector = lView[INJECTOR$1];\n        // switch to `injectInjectorOnly` implementation for module injector, since module injector\n        // should not have access to Component/Directive DI scope (that may happen through\n        // `directiveInject` implementation)\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        try {\n            if (moduleInjector) {\n                return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n            }\n            else {\n                return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n            }\n        }\n        finally {\n            setInjectImplementation(previousInjectImplementation);\n        }\n    }\n    return notFoundValueOrThrow(notFoundValue, token, flags);\n}\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom\n * filter. `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {\n    if (tNode !== null) {\n        // If the view or any of its ancestors have an embedded\n        // view injector, we have to look it up there first.\n        if (lView[FLAGS] & 1024 /* LViewFlags.HasEmbeddedViewInjector */) {\n            const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);\n            if (embeddedInjectorValue !== NOT_FOUND) {\n                return embeddedInjectorValue;\n            }\n        }\n        // Otherwise try the node injector.\n        const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);\n        if (value !== NOT_FOUND) {\n            return value;\n        }\n    }\n    // Finally, fall back to the module injector.\n    return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n}\n/**\n * Returns the value associated to the given token from the node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {\n    const bloomHash = bloomHashBitOrFactory(token);\n    // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n    // so just call the factory function to create it.\n    if (typeof bloomHash === 'function') {\n        if (!enterDI(lView, tNode, flags)) {\n            // Failed to enter DI, try module injector instead. If a token is injected with the @Host\n            // flag, the module injector is not searched for that token in Ivy.\n            return (flags & InjectFlags.Host) ?\n                notFoundValueOrThrow(notFoundValue, token, flags) :\n                lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n        }\n        try {\n            const value = bloomHash(flags);\n            if (value == null && !(flags & InjectFlags.Optional)) {\n                throwProviderNotFoundError(token);\n            }\n            else {\n                return value;\n            }\n        }\n        finally {\n            leaveDI();\n        }\n    }\n    else if (typeof bloomHash === 'number') {\n        // A reference to the previous injector TView that was found while climbing the element\n        // injector tree. This is used to know if viewProviders can be accessed on the current\n        // injector.\n        let previousTView = null;\n        let injectorIndex = getInjectorIndex(tNode, lView);\n        let parentLocation = NO_PARENT_INJECTOR;\n        let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;\n        // If we should skip this injector, or if there is no injector on this node, start by\n        // searching the parent injector.\n        if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {\n            parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) :\n                lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */];\n            if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {\n                injectorIndex = -1;\n            }\n            else {\n                previousTView = lView[TVIEW];\n                injectorIndex = getParentInjectorIndex(parentLocation);\n                lView = getParentInjectorView(parentLocation, lView);\n            }\n        }\n        // Traverse up the injector tree until we find a potential match or until we know there\n        // *isn't* a match.\n        while (injectorIndex !== -1) {\n            ngDevMode && assertNodeInjector(lView, injectorIndex);\n            // Check the current injector. If it matches, see if it contains token.\n            const tView = lView[TVIEW];\n            ngDevMode &&\n                assertTNodeForLView(tView.data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */], lView);\n            if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n                // At this point, we have an injector which *may* contain the token, so we step through\n                // the providers and directives associated with the injector's corresponding node to get\n                // the instance.\n                const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);\n                if (instance !== NOT_FOUND) {\n                    return instance;\n                }\n            }\n            parentLocation = lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */];\n            if (parentLocation !== NO_PARENT_INJECTOR &&\n                shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */] === hostTElementNode) &&\n                bloomHasToken(bloomHash, injectorIndex, lView)) {\n                // The def wasn't found anywhere on this node, so it was a false positive.\n                // Traverse up the tree and continue searching.\n                previousTView = tView;\n                injectorIndex = getParentInjectorIndex(parentLocation);\n                lView = getParentInjectorView(parentLocation, lView);\n            }\n            else {\n                // If we should not search parent OR If the ancestor bloom filter value does not have the\n                // bit corresponding to the directive we can give up on traversing up to find the specific\n                // injector.\n                injectorIndex = -1;\n            }\n        }\n    }\n    return notFoundValue;\n}\nfunction searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {\n    const currentTView = lView[TVIEW];\n    const tNode = currentTView.data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */];\n    // First, we need to determine if view providers can be accessed by the starting element.\n    // There are two possibilities\n    const canAccessViewProviders = previousTView == null ?\n        // 1) This is the first invocation `previousTView == null` which means that we are at the\n        // `TNode` of where injector is starting to look. In such a case the only time we are allowed\n        // to look into the ViewProviders is if:\n        // - we are on a component\n        // - AND the injector set `includeViewProviders` to true (implying that the token can see\n        // ViewProviders because it is the Component or a Service which itself was declared in\n        // ViewProviders)\n        (isComponentHost(tNode) && includeViewProviders) :\n        // 2) `previousTView != null` which means that we are now walking across the parent nodes.\n        // In such a case we are only allowed to look into the ViewProviders if:\n        // - We just crossed from child View to Parent View `previousTView != currentTView`\n        // - AND the parent TNode is an Element.\n        // This means that we just came from the Component's View and therefore are allowed to see\n        // into the ViewProviders.\n        (previousTView != currentTView && ((tNode.type & 3 /* TNodeType.AnyRNode */) !== 0));\n    // This special case happens when there is a @host on the inject and when we are searching\n    // on the host element node.\n    const isHostSpecialCase = (flags & InjectFlags.Host) && hostTElementNode === tNode;\n    const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);\n    if (injectableIdx !== null) {\n        return getNodeInjectable(lView, currentTView, injectableIdx, tNode);\n    }\n    else {\n        return NOT_FOUND;\n    }\n}\n/**\n * Searches for the given token among the node's directives and providers.\n *\n * @param tNode TNode on which directives are present.\n * @param tView The tView we are currently processing\n * @param token Provider token or type of a directive to look for.\n * @param canAccessViewProviders Whether view providers should be considered.\n * @param isHostSpecialCase Whether the host special case applies.\n * @returns Index of a found directive or provider, or null when none found.\n */\nfunction locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {\n    const nodeProviderIndexes = tNode.providerIndexes;\n    const tInjectables = tView.data;\n    const injectablesStart = nodeProviderIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n    const directivesStart = tNode.directiveStart;\n    const directiveEnd = tNode.directiveEnd;\n    const cptViewProvidersCount = nodeProviderIndexes >> 20 /* TNodeProviderIndexes.CptViewProvidersCountShift */;\n    const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;\n    // When the host special case applies, only the viewProviders and the component are visible\n    const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\n    for (let i = startingIndex; i < endIndex; i++) {\n        const providerTokenOrDef = tInjectables[i];\n        if (i < directivesStart && token === providerTokenOrDef ||\n            i >= directivesStart && providerTokenOrDef.type === token) {\n            return i;\n        }\n    }\n    if (isHostSpecialCase) {\n        const dirDef = tInjectables[directivesStart];\n        if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\n            return directivesStart;\n        }\n    }\n    return null;\n}\n/**\n * Retrieve or instantiate the injectable from the `LView` at particular `index`.\n *\n * This function checks to see if the value has already been instantiated and if so returns the\n * cached `injectable`. Otherwise if it detects that the value is still a factory it\n * instantiates the `injectable` and caches the value.\n */\nfunction getNodeInjectable(lView, tView, index, tNode) {\n    let value = lView[index];\n    const tData = tView.data;\n    if (isFactory(value)) {\n        const factory = value;\n        if (factory.resolving) {\n            throwCyclicDependencyError(stringifyForError(tData[index]));\n        }\n        const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n        factory.resolving = true;\n        const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;\n        const success = enterDI(lView, tNode, InjectFlags.Default);\n        ngDevMode &&\n            assertEqual(success, true, 'Because flags do not contain \\`SkipSelf\\' we expect this to always succeed.');\n        try {\n            value = lView[index] = factory.factory(undefined, tData, lView, tNode);\n            // This code path is hit for both directives and providers.\n            // For perf reasons, we want to avoid searching for hooks on providers.\n            // It does no harm to try (the hooks just won't exist), but the extra\n            // checks are unnecessary and this is a hot path. So we check to see\n            // if the index of the dependency is in the directive range for this\n            // tNode. If it's not, we know it's a provider and skip hook registration.\n            if (tView.firstCreatePass && index >= tNode.directiveStart) {\n                ngDevMode && assertDirectiveDef(tData[index]);\n                registerPreOrderHooks(index, tData[index], tView);\n            }\n        }\n        finally {\n            previousInjectImplementation !== null &&\n                setInjectImplementation(previousInjectImplementation);\n            setIncludeViewProviders(previousIncludeViewProviders);\n            factory.resolving = false;\n            leaveDI();\n        }\n    }\n    return value;\n}\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n *   When the returned value is negative then it represents special values such as `Injector`.\n */\nfunction bloomHashBitOrFactory(token) {\n    ngDevMode && assertDefined(token, 'token must be defined');\n    if (typeof token === 'string') {\n        return token.charCodeAt(0) || 0;\n    }\n    const tokenId = \n    // First check with `hasOwnProperty` so we don't get an inherited ID.\n    token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : undefined;\n    // Negative token IDs are used for special objects such as `Injector`\n    if (typeof tokenId === 'number') {\n        if (tokenId >= 0) {\n            return tokenId & BLOOM_MASK;\n        }\n        else {\n            ngDevMode &&\n                assertEqual(tokenId, -1 /* InjectorMarkers.Injector */, 'Expecting to get Special Injector Id');\n            return createNodeInjector;\n        }\n    }\n    else {\n        return tokenId;\n    }\n}\nfunction bloomHasToken(bloomHash, injectorIndex, injectorView) {\n    // Create a mask that targets the specific bit associated with the directive we're looking for.\n    // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n    // to bit positions 0 - 31 in a 32 bit integer.\n    const mask = 1 << bloomHash;\n    // Each bloom bucket in `injectorView` represents `BLOOM_BUCKET_BITS` number of bits of\n    // `bloomHash`. Any bits in `bloomHash` beyond `BLOOM_BUCKET_BITS` indicate the bucket offset\n    // that should be used.\n    const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];\n    // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n    // this injector is a potential match.\n    return !!(value & mask);\n}\n/** Returns true if flags prevent parent injector from being searched for tokens */\nfunction shouldSearchParent(flags, isFirstHostTNode) {\n    return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);\n}\nclass NodeInjector {\n    constructor(_tNode, _lView) {\n        this._tNode = _tNode;\n        this._lView = _lView;\n    }\n    get(token, notFoundValue, flags) {\n        return getOrCreateInjectable(this._tNode, this._lView, token, flags, notFoundValue);\n    }\n}\n/** Creates a `NodeInjector` for the current node. */\nfunction createNodeInjector() {\n    return new NodeInjector(getCurrentTNode(), getLView());\n}\n/**\n * @codeGenApi\n */\nfunction \u0275\u0275getInheritedFactory(type) {\n    return noSideEffects(() => {\n        const ownConstructor = type.prototype.constructor;\n        const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);\n        const objectPrototype = Object.prototype;\n        let parent = Object.getPrototypeOf(type.prototype).constructor;\n        // Go up the prototype until we hit `Object`.\n        while (parent && parent !== objectPrototype) {\n            const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);\n            // If we hit something that has a factory and the factory isn't the same as the type,\n            // we've found the inherited factory. Note the check that the factory isn't the type's\n            // own factory is redundant in most cases, but if the user has custom decorators on the\n            // class, this lookup will start one level down in the prototype chain, causing us to\n            // find the own factory first and potentially triggering an infinite loop downstream.\n            if (factory && factory !== ownFactory) {\n                return factory;\n            }\n            parent = Object.getPrototypeOf(parent);\n        }\n        // There is no factory defined. Either this was improper usage of inheritance\n        // (no Angular decorator on the superclass) or there is no constructor at all\n        // in the inheritance chain. Since the two cases cannot be distinguished, the\n        // latter has to be assumed.\n        return t => new t();\n    });\n}\nfunction getFactoryOf(type) {\n    if (isForwardRef(type)) {\n        return () => {\n            const factory = getFactoryOf(resolveForwardRef(type));\n            return factory && factory();\n        };\n    }\n    return getFactoryDef(type);\n}\n/**\n * Returns a value from the closest embedded or node injector.\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nfunction lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {\n    let currentTNode = tNode;\n    let currentLView = lView;\n    // When an LView with an embedded view injector is inserted, it'll likely be interlaced with\n    // nodes who may have injectors (e.g. node injector -> embedded view injector -> node injector).\n    // Since the bloom filters for the node injectors have already been constructed and we don't\n    // have a way of extracting the records from an injector, the only way to maintain the correct\n    // hierarchy when resolving the value is to walk it node-by-node while attempting to resolve\n    // the token at each level.\n    while (currentTNode !== null && currentLView !== null &&\n        (currentLView[FLAGS] & 1024 /* LViewFlags.HasEmbeddedViewInjector */) &&\n        !(currentLView[FLAGS] & 256 /* LViewFlags.IsRoot */)) {\n        ngDevMode && assertTNodeForLView(currentTNode, currentLView);\n        // Note that this lookup on the node injector is using the `Self` flag, because\n        // we don't want the node injector to look at any parent injectors since we\n        // may hit the embedded view injector first.\n        const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND);\n        if (nodeInjectorValue !== NOT_FOUND) {\n            return nodeInjectorValue;\n        }\n        // Has an explicit type due to a TS bug: https://github.com/microsoft/TypeScript/issues/33191\n        let parentTNode = currentTNode.parent;\n        // `TNode.parent` includes the parent within the current view only. If it doesn't exist,\n        // it means that we've hit the view boundary and we need to go up to the next view.\n        if (!parentTNode) {\n            // Before we go to the next LView, check if the token exists on the current embedded injector.\n            const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];\n            if (embeddedViewInjector) {\n                const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);\n                if (embeddedViewInjectorValue !== NOT_FOUND) {\n                    return embeddedViewInjectorValue;\n                }\n            }\n            // Otherwise keep going up the tree.\n            parentTNode = getTNodeFromLView(currentLView);\n            currentLView = currentLView[DECLARATION_VIEW];\n        }\n        currentTNode = parentTNode;\n    }\n    return notFoundValue;\n}\n/** Gets the TNode associated with an LView inside of the declaration view. */\nfunction getTNodeFromLView(lView) {\n    const tView = lView[TVIEW];\n    const tViewType = tView.type;\n    // The parent pointer differs based on `TView.type`.\n    if (tViewType === 2 /* TViewType.Embedded */) {\n        ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n        return tView.declTNode;\n    }\n    else if (tViewType === 1 /* TViewType.Component */) {\n        // Components don't have `TView.declTNode` because each instance of component could be\n        // inserted in different location, hence `TView.declTNode` is meaningless.\n        return lView[T_HOST];\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Facade for the attribute injection from DI.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275injectAttribute(attrNameToInject) {\n    return injectAttributeImpl(getCurrentTNode(), attrNameToInject);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Attribute = makeParamDecorator('Attribute', (attributeName) => ({ attributeName, __NG_ELEMENT_ID__: () => \u0275\u0275injectAttribute(attributeName) }));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _reflect = null;\nfunction getReflect() {\n    return (_reflect = _reflect || new ReflectionCapabilities());\n}\nfunction reflectDependencies(type) {\n    return convertDependencies(getReflect().parameters(type));\n}\nfunction convertDependencies(deps) {\n    return deps.map(dep => reflectDependency(dep));\n}\nfunction reflectDependency(dep) {\n    const meta = {\n        token: null,\n        attribute: null,\n        host: false,\n        optional: false,\n        self: false,\n        skipSelf: false,\n    };\n    if (Array.isArray(dep) && dep.length > 0) {\n        for (let j = 0; j < dep.length; j++) {\n            const param = dep[j];\n            if (param === undefined) {\n                // param may be undefined if type of dep is not set by ngtsc\n                continue;\n            }\n            const proto = Object.getPrototypeOf(param);\n            if (param instanceof Optional || proto.ngMetadataName === 'Optional') {\n                meta.optional = true;\n            }\n            else if (param instanceof SkipSelf || proto.ngMetadataName === 'SkipSelf') {\n                meta.skipSelf = true;\n            }\n            else if (param instanceof Self || proto.ngMetadataName === 'Self') {\n                meta.self = true;\n            }\n            else if (param instanceof Host || proto.ngMetadataName === 'Host') {\n                meta.host = true;\n            }\n            else if (param instanceof Inject) {\n                meta.token = param.token;\n            }\n            else if (param instanceof Attribute) {\n                if (param.attributeName === undefined) {\n                    throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Attribute name must be defined.`);\n                }\n                meta.attribute = param.attributeName;\n            }\n            else {\n                meta.token = param;\n            }\n        }\n    }\n    else if (dep === undefined || (Array.isArray(dep) && dep.length === 0)) {\n        meta.token = null;\n    }\n    else {\n        meta.token = dep;\n    }\n    return meta;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Map of module-id to the corresponding NgModule.\n */\nconst modules = new Map();\n/**\n * Whether to check for duplicate NgModule registrations.\n *\n * This can be disabled for testing.\n */\nlet checkForDuplicateNgModules = true;\nfunction assertSameOrNotExisting(id, type, incoming) {\n    if (type && type !== incoming && checkForDuplicateNgModules) {\n        throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);\n    }\n}\n/**\n * Adds the given NgModule type to Angular's NgModule registry.\n *\n * This is generated as a side-effect of NgModule compilation. Note that the `id` is passed in\n * explicitly and not read from the NgModule definition. This is for two reasons: it avoids a\n * megamorphic read, and in JIT there's a chicken-and-egg problem where the NgModule may not be\n * fully resolved when it's registered.\n *\n * @codeGenApi\n */\nfunction registerNgModuleType(ngModuleType, id) {\n    const existing = modules.get(id) || null;\n    assertSameOrNotExisting(id, existing, ngModuleType);\n    modules.set(id, ngModuleType);\n}\nfunction clearModulesForTest() {\n    modules.clear();\n}\nfunction getRegisteredNgModuleType(id) {\n    return modules.get(id);\n}\n/**\n * Control whether the NgModule registration system enforces that each NgModule type registered has\n * a unique id.\n *\n * This is useful for testing as the NgModule registry cannot be properly reset between tests with\n * Angular's current API.\n */\nfunction setAllowDuplicateNgModuleIdsForTest(allowDuplicates) {\n    checkForDuplicateNgModules = !allowDuplicates;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n *\n * @codeGenApi\n */\nfunction \u0275\u0275resolveWindow(element) {\n    return element.ownerDocument.defaultView;\n}\n/**\n *\n * @codeGenApi\n */\nfunction \u0275\u0275resolveDocument(element) {\n    return element.ownerDocument;\n}\n/**\n *\n * @codeGenApi\n */\nfunction \u0275\u0275resolveBody(element) {\n    return element.ownerDocument.body;\n}\n/**\n * The special delimiter we use to separate property names, prefixes, and suffixes\n * in property binding metadata. See storeBindingMetadata().\n *\n * We intentionally use the Unicode \"REPLACEMENT CHARACTER\" (U+FFFD) as a delimiter\n * because it is a very uncommon character that is unlikely to be part of a user's\n * property names or interpolation strings. If it is in fact used in a property\n * binding, DebugElement.properties will not return the correct value for that\n * binding. However, there should be no runtime effect for real applications.\n *\n * This character is typically rendered as a question mark inside of a diamond.\n * See https://en.wikipedia.org/wiki/Specials_(Unicode_block)\n *\n */\nconst INTERPOLATION_DELIMITER = `\uFFFD`;\n/**\n * Unwrap a value which might be behind a closure (for forward declaration reasons).\n */\nfunction maybeUnwrapFn$1(value) {\n    if (value instanceof Function) {\n        return value();\n    }\n    else {\n        return value;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Defines a schema that allows an NgModule to contain the following:\n * - Non-Angular elements named with dash case (`-`).\n * - Element properties named with dash case (`-`).\n * Dash case is the naming convention for custom elements.\n *\n * @publicApi\n */\nconst CUSTOM_ELEMENTS_SCHEMA = {\n    name: 'custom-elements'\n};\n/**\n * Defines a schema that allows any property on any element.\n *\n * This schema allows you to ignore the errors related to any unknown elements or properties in a\n * template. The usage of this schema is generally discouraged because it prevents useful validation\n * and may hide real errors in your template. Consider using the `CUSTOM_ELEMENTS_SCHEMA` instead.\n *\n * @publicApi\n */\nconst NO_ERRORS_SCHEMA = {\n    name: 'no-errors-schema'\n};\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet shouldThrowErrorOnUnknownElement = false;\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown elements,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\nfunction \u0275setUnknownElementStrictMode(shouldThrow) {\n    shouldThrowErrorOnUnknownElement = shouldThrow;\n}\n/**\n * Gets the current value of the strict mode.\n */\nfunction \u0275getUnknownElementStrictMode() {\n    return shouldThrowErrorOnUnknownElement;\n}\nlet shouldThrowErrorOnUnknownProperty = false;\n/**\n * Sets a strict mode for JIT-compiled components to throw an error on unknown properties,\n * instead of just logging the error.\n * (for AOT-compiled ones this check happens at build time).\n */\nfunction \u0275setUnknownPropertyStrictMode(shouldThrow) {\n    shouldThrowErrorOnUnknownProperty = shouldThrow;\n}\n/**\n * Gets the current value of the strict mode.\n */\nfunction \u0275getUnknownPropertyStrictMode() {\n    return shouldThrowErrorOnUnknownProperty;\n}\n/**\n * Validates that the element is known at runtime and produces\n * an error if it's not the case.\n * This check is relevant for JIT-compiled components (for AOT-compiled\n * ones this check happens at build time).\n *\n * The element is considered known if either:\n * - it's a known HTML element\n * - it's a known custom element\n * - the element matches any directive\n * - the element is allowed by one of the schemas\n *\n * @param element Element to validate\n * @param lView An `LView` that represents a current component that is being rendered\n * @param tagName Name of the tag to check\n * @param schemas Array of schemas\n * @param hasDirectives Boolean indicating that the element matches any directive\n */\nfunction validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {\n    // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n    // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n    // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n    // execute the check below.\n    if (schemas === null)\n        return;\n    // If the element matches any directive, it's considered as valid.\n    if (!hasDirectives && tagName !== null) {\n        // The element is unknown if it's an instance of HTMLUnknownElement, or it isn't registered\n        // as a custom element. Note that unknown elements with a dash in their name won't be instances\n        // of HTMLUnknownElement in browsers that support web components.\n        const isUnknown = \n        // Note that we can't check for `typeof HTMLUnknownElement === 'function'`,\n        // because while most browsers return 'function', IE returns 'object'.\n        (typeof HTMLUnknownElement !== 'undefined' && HTMLUnknownElement &&\n            element instanceof HTMLUnknownElement) ||\n            (typeof customElements !== 'undefined' && tagName.indexOf('-') > -1 &&\n                !customElements.get(tagName));\n        if (isUnknown && !matchingSchemas(schemas, tagName)) {\n            const isHostStandalone = isHostComponentStandalone(lView);\n            const templateLocation = getTemplateLocationDetails(lView);\n            const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;\n            let message = `'${tagName}' is not a known element${templateLocation}:\\n`;\n            message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? 'included in the \\'@Component.imports\\' of this component' :\n                'a part of an @NgModule where this component is declared'}.\\n`;\n            if (tagName && tagName.indexOf('-') > -1) {\n                message +=\n                    `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;\n            }\n            else {\n                message +=\n                    `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;\n            }\n            if (shouldThrowErrorOnUnknownElement) {\n                throw new RuntimeError(304 /* RuntimeErrorCode.UNKNOWN_ELEMENT */, message);\n            }\n            else {\n                console.error(formatRuntimeError(304 /* RuntimeErrorCode.UNKNOWN_ELEMENT */, message));\n            }\n        }\n    }\n}\n/**\n * Validates that the property of the element is known at runtime and returns\n * false if it's not the case.\n * This check is relevant for JIT-compiled components (for AOT-compiled\n * ones this check happens at build time).\n *\n * The property is considered known if either:\n * - it's a known property of the element\n * - the element is allowed by one of the schemas\n * - the property is used for animations\n *\n * @param element Element to validate\n * @param propName Name of the property to check\n * @param tagName Name of the tag hosting the property\n * @param schemas Array of schemas\n */\nfunction isPropertyValid(element, propName, tagName, schemas) {\n    // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n    // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n    // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n    // execute the check below.\n    if (schemas === null)\n        return true;\n    // The property is considered valid if the element matches the schema, it exists on the element,\n    // or it is synthetic, and we are in a browser context (web worker nodes should be skipped).\n    if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {\n        return true;\n    }\n    // Note: `typeof Node` returns 'function' in most browsers, but on IE it is 'object' so we\n    // need to account for both here, while being careful with `typeof null` also returning 'object'.\n    return typeof Node === 'undefined' || Node === null || !(element instanceof Node);\n}\n/**\n * Logs or throws an error that a property is not supported on an element.\n *\n * @param propName Name of the invalid property\n * @param tagName Name of the tag hosting the property\n * @param nodeType Type of the node hosting the property\n * @param lView An `LView` that represents a current component\n */\nfunction handleUnknownPropertyError(propName, tagName, nodeType, lView) {\n    // Special-case a situation when a structural directive is applied to\n    // an `<ng-template>` element, for example: `<ng-template *ngIf=\"true\">`.\n    // In this case the compiler generates the `\u0275\u0275template` instruction with\n    // the `null` as the tagName. The directive matching logic at runtime relies\n    // on this effect (see `isInlineTemplate`), thus using the 'ng-template' as\n    // a default value of the `tNode.value` is not feasible at this moment.\n    if (!tagName && nodeType === 4 /* TNodeType.Container */) {\n        tagName = 'ng-template';\n    }\n    const isHostStandalone = isHostComponentStandalone(lView);\n    const templateLocation = getTemplateLocationDetails(lView);\n    let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;\n    const schemas = `'${isHostStandalone ? '@Component' : '@NgModule'}.schemas'`;\n    const importLocation = isHostStandalone ?\n        'included in the \\'@Component.imports\\' of this component' :\n        'a part of an @NgModule where this component is declared';\n    if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {\n        // Most likely this is a control flow directive (such as `*ngIf`) used in\n        // a template, but the directive or the `CommonModule` is not imported.\n        const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);\n        message += `\\nIf the '${propName}' is an Angular control flow directive, ` +\n            `please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;\n    }\n    else {\n        // May be an Angular component, which is not imported/declared?\n        message += `\\n1. If '${tagName}' is an Angular component and it has the ` +\n            `'${propName}' input, then verify that it is ${importLocation}.`;\n        // May be a Web Component?\n        if (tagName && tagName.indexOf('-') > -1) {\n            message += `\\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' ` +\n                `to the ${schemas} of this component to suppress this message.`;\n            message += `\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to ` +\n                `the ${schemas} of this component.`;\n        }\n        else {\n            // If it's expected, the error can be suppressed by the `NO_ERRORS_SCHEMA` schema.\n            message += `\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to ` +\n                `the ${schemas} of this component.`;\n        }\n    }\n    reportUnknownPropertyError(message);\n}\nfunction reportUnknownPropertyError(message) {\n    if (shouldThrowErrorOnUnknownProperty) {\n        throw new RuntimeError(303 /* RuntimeErrorCode.UNKNOWN_BINDING */, message);\n    }\n    else {\n        console.error(formatRuntimeError(303 /* RuntimeErrorCode.UNKNOWN_BINDING */, message));\n    }\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode and also it relies on the constructor function being available.\n *\n * Gets a reference to the host component def (where a current component is declared).\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction getDeclarationComponentDef(lView) {\n    !ngDevMode && throwError('Must never be called in production mode');\n    const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n    const context = declarationLView[CONTEXT];\n    // Unable to obtain a context.\n    if (!context)\n        return null;\n    return context.constructor ? getComponentDef$1(context.constructor) : null;\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode.\n *\n * Checks if the current component is declared inside of a standalone component template.\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction isHostComponentStandalone(lView) {\n    !ngDevMode && throwError('Must never be called in production mode');\n    const componentDef = getDeclarationComponentDef(lView);\n    // Treat host component as non-standalone if we can't obtain the def.\n    return !!componentDef?.standalone;\n}\n/**\n * WARNING: this is a **dev-mode only** function (thus should always be guarded by the `ngDevMode`)\n * and must **not** be used in production bundles. The function makes megamorphic reads, which might\n * be too slow for production mode.\n *\n * Constructs a string describing the location of the host component template. The function is used\n * in dev mode to produce error messages.\n *\n * @param lView An `LView` that represents a current component that is being rendered.\n */\nfunction getTemplateLocationDetails(lView) {\n    !ngDevMode && throwError('Must never be called in production mode');\n    const hostComponentDef = getDeclarationComponentDef(lView);\n    const componentClassName = hostComponentDef?.type?.name;\n    return componentClassName ? ` (used in the '${componentClassName}' component template)` : '';\n}\n/**\n * The set of known control flow directives and their corresponding imports.\n * We use this set to produce a more precises error message with a note\n * that the `CommonModule` should also be included.\n */\nconst KNOWN_CONTROL_FLOW_DIRECTIVES = new Map([\n    ['ngIf', 'NgIf'], ['ngFor', 'NgFor'], ['ngSwitchCase', 'NgSwitchCase'],\n    ['ngSwitchDefault', 'NgSwitchDefault']\n]);\n/**\n * Returns true if the tag name is allowed by specified schemas.\n * @param schemas Array of schemas\n * @param tagName Name of the tag\n */\nfunction matchingSchemas(schemas, tagName) {\n    if (schemas !== null) {\n        for (let i = 0; i < schemas.length; i++) {\n            const schema = schemas[i];\n            if (schema === NO_ERRORS_SCHEMA ||\n                schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Flags for renderer-specific style modifiers.\n * @publicApi\n */\nvar RendererStyleFlags2;\n(function (RendererStyleFlags2) {\n    // TODO(misko): This needs to be refactored into a separate file so that it can be imported from\n    // `node_manipulation.ts` Currently doing the import cause resolution order to change and fails\n    // the tests. The work around is to have hard coded value in `node_manipulation.ts` for now.\n    /**\n     * Marks a style as important.\n     */\n    RendererStyleFlags2[RendererStyleFlags2[\"Important\"] = 1] = \"Important\";\n    /**\n     * Marks a style as using dash case naming (this-is-dash-case).\n     */\n    RendererStyleFlags2[RendererStyleFlags2[\"DashCase\"] = 2] = \"DashCase\";\n})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Disallowed strings in the comment.\n *\n * see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n */\nconst COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;\n/**\n * Delimiter in the disallowed strings which needs to be wrapped with zero with character.\n */\nconst COMMENT_DELIMITER = /(<|>)/;\nconst COMMENT_DELIMITER_ESCAPED = '\\u200B$1\\u200B';\n/**\n * Escape the content of comment strings so that it can be safely inserted into a comment node.\n *\n * The issue is that HTML does not specify any way to escape comment end text inside the comment.\n * Consider: `<!-- The way you close a comment is with \">\", and \"->\" at the beginning or by \"-->\" or\n * \"--!>\" at the end. -->`. Above the `\"-->\"` is meant to be text not an end to the comment. This\n * can be created programmatically through DOM APIs. (`<!--` are also disallowed.)\n *\n * see: https://html.spec.whatwg.org/multipage/syntax.html#comments\n *\n * ```\n * div.innerHTML = div.innerHTML\n * ```\n *\n * One would expect that the above code would be safe to do, but it turns out that because comment\n * text is not escaped, the comment may contain text which will prematurely close the comment\n * opening up the application for XSS attack. (In SSR we programmatically create comment nodes which\n * may contain such text and expect them to be safe.)\n *\n * This function escapes the comment text by looking for comment delimiters (`<` and `>`) and\n * surrounding them with `_>_` where the `_` is a zero width space `\\u200B`. The result is that if a\n * comment contains any of the comment start/end delimiters (such as `<!--`, `-->` or `--!>`) the\n * text it will render normally but it will not cause the HTML parser to close/open the comment.\n *\n * @param value text to make safe for comment node by escaping the comment open/close character\n *     sequence.\n */\nfunction escapeCommentText(value) {\n    return value.replace(COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Keeps track of the currently-active LViews.\nconst TRACKED_LVIEWS = new Map();\n// Used for generating unique IDs for LViews.\nlet uniqueIdCounter = 0;\n/** Gets a unique ID that can be assigned to an LView. */\nfunction getUniqueLViewId() {\n    return uniqueIdCounter++;\n}\n/** Starts tracking an LView. */\nfunction registerLView(lView) {\n    ngDevMode && assertNumber(lView[ID], 'LView must have an ID in order to be registered');\n    TRACKED_LVIEWS.set(lView[ID], lView);\n}\n/** Gets an LView by its unique ID. */\nfunction getLViewById(id) {\n    ngDevMode && assertNumber(id, 'ID used for LView lookup must be a number');\n    return TRACKED_LVIEWS.get(id) || null;\n}\n/** Stops tracking an LView. */\nfunction unregisterLView(lView) {\n    ngDevMode && assertNumber(lView[ID], 'Cannot stop tracking an LView that does not have an ID');\n    TRACKED_LVIEWS.delete(lView[ID]);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The internal view context which is specific to a given DOM element, directive or\n * component instance. Each value in here (besides the LView and element node details)\n * can be present, null or undefined. If undefined then it implies the value has not been\n * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.\n *\n * Each value will get filled when the respective value is examined within the getContext\n * function. The component, element and each directive instance will share the same instance\n * of the context.\n */\nclass LContext {\n    constructor(\n    /**\n     * ID of the component's parent view data.\n     */\n    lViewId, \n    /**\n     * The index instance of the node.\n     */\n    nodeIndex, \n    /**\n     * The instance of the DOM node that is attached to the lNode.\n     */\n    native) {\n        this.lViewId = lViewId;\n        this.nodeIndex = nodeIndex;\n        this.native = native;\n    }\n    /** Component's parent view data. */\n    get lView() {\n        return getLViewById(this.lViewId);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LView` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\nfunction getLContext(target) {\n    let mpValue = readPatchedData(target);\n    if (mpValue) {\n        // only when it's an array is it considered an LView instance\n        // ... otherwise it's an already constructed LContext instance\n        if (isLView(mpValue)) {\n            const lView = mpValue;\n            let nodeIndex;\n            let component = undefined;\n            let directives = undefined;\n            if (isComponentInstance(target)) {\n                nodeIndex = findViaComponent(lView, target);\n                if (nodeIndex == -1) {\n                    throw new Error('The provided component was not found in the application');\n                }\n                component = target;\n            }\n            else if (isDirectiveInstance(target)) {\n                nodeIndex = findViaDirective(lView, target);\n                if (nodeIndex == -1) {\n                    throw new Error('The provided directive was not found in the application');\n                }\n                directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);\n            }\n            else {\n                nodeIndex = findViaNativeElement(lView, target);\n                if (nodeIndex == -1) {\n                    return null;\n                }\n            }\n            // the goal is not to fill the entire context full of data because the lookups\n            // are expensive. Instead, only the target data (the element, component, container, ICU\n            // expression or directive details) are filled into the context. If called multiple times\n            // with different target values then the missing target data will be filled in.\n            const native = unwrapRNode(lView[nodeIndex]);\n            const existingCtx = readPatchedData(native);\n            const context = (existingCtx && !Array.isArray(existingCtx)) ?\n                existingCtx :\n                createLContext(lView, nodeIndex, native);\n            // only when the component has been discovered then update the monkey-patch\n            if (component && context.component === undefined) {\n                context.component = component;\n                attachPatchData(context.component, context);\n            }\n            // only when the directives have been discovered then update the monkey-patch\n            if (directives && context.directives === undefined) {\n                context.directives = directives;\n                for (let i = 0; i < directives.length; i++) {\n                    attachPatchData(directives[i], context);\n                }\n            }\n            attachPatchData(context.native, context);\n            mpValue = context;\n        }\n    }\n    else {\n        const rElement = target;\n        ngDevMode && assertDomNode(rElement);\n        // if the context is not found then we need to traverse upwards up the DOM\n        // to find the nearest element that has already been monkey patched with data\n        let parent = rElement;\n        while (parent = parent.parentNode) {\n            const parentContext = readPatchedData(parent);\n            if (parentContext) {\n                const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;\n                // the edge of the app was also reached here through another means\n                // (maybe because the DOM was changed manually).\n                if (!lView) {\n                    return null;\n                }\n                const index = findViaNativeElement(lView, rElement);\n                if (index >= 0) {\n                    const native = unwrapRNode(lView[index]);\n                    const context = createLContext(lView, index, native);\n                    attachPatchData(native, context);\n                    mpValue = context;\n                    break;\n                }\n            }\n        }\n    }\n    return mpValue || null;\n}\n/**\n * Creates an empty instance of a `LContext` context\n */\nfunction createLContext(lView, nodeIndex, native) {\n    return new LContext(lView[ID], nodeIndex, native);\n}\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\nfunction getComponentViewByInstance(componentInstance) {\n    let patchedData = readPatchedData(componentInstance);\n    let lView;\n    if (isLView(patchedData)) {\n        const contextLView = patchedData;\n        const nodeIndex = findViaComponent(contextLView, componentInstance);\n        lView = getComponentLViewByIndex(nodeIndex, contextLView);\n        const context = createLContext(contextLView, nodeIndex, lView[HOST]);\n        context.component = componentInstance;\n        attachPatchData(componentInstance, context);\n        attachPatchData(context.native, context);\n    }\n    else {\n        const context = patchedData;\n        const contextLView = context.lView;\n        ngDevMode && assertLView(contextLView);\n        lView = getComponentLViewByIndex(context.nodeIndex, contextLView);\n    }\n    return lView;\n}\n/**\n * This property will be monkey-patched on elements, components and directives.\n */\nconst MONKEY_PATCH_KEY_NAME = '__ngContext__';\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\nfunction attachPatchData(target, data) {\n    ngDevMode && assertDefined(target, 'Target expected');\n    // Only attach the ID of the view in order to avoid memory leaks (see #41047). We only do this\n    // for `LView`, because we have control over when an `LView` is created and destroyed, whereas\n    // we can't know when to remove an `LContext`.\n    if (isLView(data)) {\n        target[MONKEY_PATCH_KEY_NAME] = data[ID];\n        registerLView(data);\n    }\n    else {\n        target[MONKEY_PATCH_KEY_NAME] = data;\n    }\n}\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\nfunction readPatchedData(target) {\n    ngDevMode && assertDefined(target, 'Target expected');\n    const data = target[MONKEY_PATCH_KEY_NAME];\n    return (typeof data === 'number') ? getLViewById(data) : data || null;\n}\nfunction readPatchedLView(target) {\n    const value = readPatchedData(target);\n    if (value) {\n        return (isLView(value) ? value : value.lView);\n    }\n    return null;\n}\nfunction isComponentInstance(instance) {\n    return instance && instance.constructor && instance.constructor.\u0275cmp;\n}\nfunction isDirectiveInstance(instance) {\n    return instance && instance.constructor && instance.constructor.\u0275dir;\n}\n/**\n * Locates the element within the given LView and returns the matching index\n */\nfunction findViaNativeElement(lView, target) {\n    const tView = lView[TVIEW];\n    for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n        if (unwrapRNode(lView[i]) === target) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Locates the next tNode (child, sibling or parent).\n */\nfunction traverseNextElement(tNode) {\n    if (tNode.child) {\n        return tNode.child;\n    }\n    else if (tNode.next) {\n        return tNode.next;\n    }\n    else {\n        // Let's take the following template: <div><span>text</span></div><component/>\n        // After checking the text node, we need to find the next parent that has a \"next\" TNode,\n        // in this case the parent `div`, so that we can find the component.\n        while (tNode.parent && !tNode.parent.next) {\n            tNode = tNode.parent;\n        }\n        return tNode.parent && tNode.parent.next;\n    }\n}\n/**\n * Locates the component within the given LView and returns the matching index\n */\nfunction findViaComponent(lView, componentInstance) {\n    const componentIndices = lView[TVIEW].components;\n    if (componentIndices) {\n        for (let i = 0; i < componentIndices.length; i++) {\n            const elementComponentIndex = componentIndices[i];\n            const componentView = getComponentLViewByIndex(elementComponentIndex, lView);\n            if (componentView[CONTEXT] === componentInstance) {\n                return elementComponentIndex;\n            }\n        }\n    }\n    else {\n        const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);\n        const rootComponent = rootComponentView[CONTEXT];\n        if (rootComponent === componentInstance) {\n            // we are dealing with the root element here therefore we know that the\n            // element is the very first element after the HEADER data in the lView\n            return HEADER_OFFSET;\n        }\n    }\n    return -1;\n}\n/**\n * Locates the directive within the given LView and returns the matching index\n */\nfunction findViaDirective(lView, directiveInstance) {\n    // if a directive is monkey patched then it will (by default)\n    // have a reference to the LView of the current view. The\n    // element bound to the directive being search lives somewhere\n    // in the view data. We loop through the nodes and check their\n    // list of directives for the instance.\n    let tNode = lView[TVIEW].firstChild;\n    while (tNode) {\n        const directiveIndexStart = tNode.directiveStart;\n        const directiveIndexEnd = tNode.directiveEnd;\n        for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n            if (lView[i] === directiveInstance) {\n                return tNode.index;\n            }\n        }\n        tNode = traverseNextElement(tNode);\n    }\n    return -1;\n}\n/**\n * Returns a list of directives extracted from the given view based on the\n * provided list of directive index values.\n *\n * @param nodeIndex The node index\n * @param lView The target view data\n * @param includeComponents Whether or not to include components in returned directives\n */\nfunction getDirectivesAtNodeIndex(nodeIndex, lView, includeComponents) {\n    const tNode = lView[TVIEW].data[nodeIndex];\n    let directiveStartIndex = tNode.directiveStart;\n    if (directiveStartIndex == 0)\n        return EMPTY_ARRAY;\n    const directiveEndIndex = tNode.directiveEnd;\n    if (!includeComponents && tNode.flags & 2 /* TNodeFlags.isComponentHost */)\n        directiveStartIndex++;\n    return lView.slice(directiveStartIndex, directiveEndIndex);\n}\nfunction getComponentAtNodeIndex(nodeIndex, lView) {\n    const tNode = lView[TVIEW].data[nodeIndex];\n    let directiveStartIndex = tNode.directiveStart;\n    return tNode.flags & 2 /* TNodeFlags.isComponentHost */ ? lView[directiveStartIndex] : null;\n}\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\nfunction discoverLocalRefs(lView, nodeIndex) {\n    const tNode = lView[TVIEW].data[nodeIndex];\n    if (tNode && tNode.localNames) {\n        const result = {};\n        let localIndex = tNode.index + 1;\n        for (let i = 0; i < tNode.localNames.length; i += 2) {\n            result[tNode.localNames[i]] = lView[localIndex];\n            localIndex++;\n        }\n        return result;\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _icuContainerIterate;\n/**\n * Iterator which provides ability to visit all of the `TIcuContainerNode` root `RNode`s.\n */\nfunction icuContainerIterate(tIcuContainerNode, lView) {\n    return _icuContainerIterate(tIcuContainerNode, lView);\n}\n/**\n * Ensures that `IcuContainerVisitor`'s implementation is present.\n *\n * This function is invoked when i18n instruction comes across an ICU. The purpose is to allow the\n * bundler to tree shake ICU logic and only load it if ICU instruction is executed.\n */\nfunction ensureIcuContainerVisitorLoaded(loader) {\n    if (_icuContainerIterate === undefined) {\n        // Do not inline this function. We want to keep `ensureIcuContainerVisitorLoaded` light, so it\n        // can be inlined into call-site.\n        _icuContainerIterate = loader();\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$4 = 1;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$3 = 1;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\n * that LContainer, which is an LView\n * @param lView the lView whose parent to get\n */\nfunction getLViewParent(lView) {\n    ngDevMode && assertLView(lView);\n    const parent = lView[PARENT];\n    return isLContainer(parent) ? parent[PARENT] : parent;\n}\n/**\n * Retrieve the root view from any component or `LView` by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param componentOrLView any component or `LView`\n */\nfunction getRootView(componentOrLView) {\n    ngDevMode && assertDefined(componentOrLView, 'component');\n    let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);\n    while (lView && !(lView[FLAGS] & 256 /* LViewFlags.IsRoot */)) {\n        lView = getLViewParent(lView);\n    }\n    ngDevMode && assertLView(lView);\n    return lView;\n}\n/**\n * Returns the context information associated with the application where the target is situated. It\n * does this by walking the parent views until it gets to the root view, then getting the context\n * off of that.\n *\n * @param viewOrComponent the `LView` or component to get the root context for.\n */\nfunction getRootContext(viewOrComponent) {\n    const rootView = getRootView(viewOrComponent);\n    ngDevMode &&\n        assertDefined(rootView[CONTEXT], 'Root view has no context. Perhaps it is disconnected?');\n    return rootView[CONTEXT];\n}\n/**\n * Gets the first `LContainer` in the LView or `null` if none exists.\n */\nfunction getFirstLContainer(lView) {\n    return getNearestLContainer(lView[CHILD_HEAD]);\n}\n/**\n * Gets the next `LContainer` that is a sibling of the given container.\n */\nfunction getNextLContainer(container) {\n    return getNearestLContainer(container[NEXT]);\n}\nfunction getNearestLContainer(viewOrContainer) {\n    while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {\n        viewOrContainer = viewOrContainer[NEXT];\n    }\n    return viewOrContainer;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst unusedValueToPlacateAjd$2 = unusedValueExportToPlacateAjd$7 + unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$3 + unusedValueExportToPlacateAjd$8;\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {\n    // If this slot was allocated for a text node dynamically created by i18n, the text node itself\n    // won't be created until i18nApply() in the update block, so this node should be skipped.\n    // For more info, see \"ICU expressions should work inside an ngTemplateOutlet inside an ngFor\"\n    // in `i18n_spec.ts`.\n    if (lNodeToHandle != null) {\n        let lContainer;\n        let isComponent = false;\n        // We are expecting an RNode, but in the case of a component or LContainer the `RNode` is\n        // wrapped in an array which needs to be unwrapped. We need to know if it is a component and if\n        // it has LContainer so that we can process all of those cases appropriately.\n        if (isLContainer(lNodeToHandle)) {\n            lContainer = lNodeToHandle;\n        }\n        else if (isLView(lNodeToHandle)) {\n            isComponent = true;\n            ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');\n            lNodeToHandle = lNodeToHandle[HOST];\n        }\n        const rNode = unwrapRNode(lNodeToHandle);\n        if (action === 0 /* WalkTNodeTreeAction.Create */ && parent !== null) {\n            if (beforeNode == null) {\n                nativeAppendChild(renderer, parent, rNode);\n            }\n            else {\n                nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n            }\n        }\n        else if (action === 1 /* WalkTNodeTreeAction.Insert */ && parent !== null) {\n            nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n        }\n        else if (action === 2 /* WalkTNodeTreeAction.Detach */) {\n            nativeRemoveNode(renderer, rNode, isComponent);\n        }\n        else if (action === 3 /* WalkTNodeTreeAction.Destroy */) {\n            ngDevMode && ngDevMode.rendererDestroyNode++;\n            renderer.destroyNode(rNode);\n        }\n        if (lContainer != null) {\n            applyContainer(renderer, action, lContainer, parent, beforeNode);\n        }\n    }\n}\nfunction createTextNode(renderer, value) {\n    ngDevMode && ngDevMode.rendererCreateTextNode++;\n    ngDevMode && ngDevMode.rendererSetText++;\n    return renderer.createText(value);\n}\nfunction updateTextNode(renderer, rNode, value) {\n    ngDevMode && ngDevMode.rendererSetText++;\n    renderer.setValue(rNode, value);\n}\nfunction createCommentNode(renderer, value) {\n    ngDevMode && ngDevMode.rendererCreateComment++;\n    return renderer.createComment(escapeCommentText(value));\n}\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param renderer A renderer to use\n * @param name the tag name\n * @param namespace Optional namespace for element.\n * @returns the element created\n */\nfunction createElementNode(renderer, name, namespace) {\n    ngDevMode && ngDevMode.rendererCreateElement++;\n    return renderer.createElement(name, namespace);\n}\n/**\n * Removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param lView The view from which elements should be added or removed\n */\nfunction removeViewFromContainer(tView, lView) {\n    const renderer = lView[RENDERER];\n    applyView(tView, lView, renderer, 2 /* WalkTNodeTreeAction.Detach */, null, null);\n    lView[HOST] = null;\n    lView[T_HOST] = null;\n}\n/**\n * Adds all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to add all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param parentTNode The `TNode` where the `LView` should be attached to.\n * @param renderer Current renderer to use for DOM manipulations.\n * @param lView The view from which elements should be added or removed\n * @param parentNativeNode The parent `RElement` where it should be inserted into.\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nfunction addViewToContainer(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {\n    lView[HOST] = parentNativeNode;\n    lView[T_HOST] = parentTNode;\n    applyView(tView, lView, renderer, 1 /* WalkTNodeTreeAction.Insert */, parentNativeNode, beforeNode);\n}\n/**\n * Detach a `LView` from the DOM by detaching its nodes.\n *\n * @param tView The `TView' of the `LView` to be detached\n * @param lView the `LView` to be detached.\n */\nfunction renderDetachView(tView, lView) {\n    applyView(tView, lView, lView[RENDERER], 2 /* WalkTNodeTreeAction.Detach */, null, null);\n}\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nfunction destroyViewTree(rootView) {\n    // If the view has no children, we can clean it up and return early.\n    let lViewOrLContainer = rootView[CHILD_HEAD];\n    if (!lViewOrLContainer) {\n        return cleanUpView(rootView[TVIEW], rootView);\n    }\n    while (lViewOrLContainer) {\n        let next = null;\n        if (isLView(lViewOrLContainer)) {\n            // If LView, traverse down to child.\n            next = lViewOrLContainer[CHILD_HEAD];\n        }\n        else {\n            ngDevMode && assertLContainer(lViewOrLContainer);\n            // If container, traverse down to its first LView.\n            const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];\n            if (firstView)\n                next = firstView;\n        }\n        if (!next) {\n            // Only clean up view when moving to the side or up, as destroy hooks\n            // should be called in order from the bottom up.\n            while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {\n                if (isLView(lViewOrLContainer)) {\n                    cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n                }\n                lViewOrLContainer = lViewOrLContainer[PARENT];\n            }\n            if (lViewOrLContainer === null)\n                lViewOrLContainer = rootView;\n            if (isLView(lViewOrLContainer)) {\n                cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n            }\n            next = lViewOrLContainer && lViewOrLContainer[NEXT];\n        }\n        lViewOrLContainer = next;\n    }\n}\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param tView The `TView' of the `LView` to insert\n * @param lView The view to insert\n * @param lContainer The container into which the view should be inserted\n * @param index Which index in the container to insert the child view into\n */\nfunction insertView(tView, lView, lContainer, index) {\n    ngDevMode && assertLView(lView);\n    ngDevMode && assertLContainer(lContainer);\n    const indexInContainer = CONTAINER_HEADER_OFFSET + index;\n    const containerLength = lContainer.length;\n    if (index > 0) {\n        // This is a new view, we need to add it to the children.\n        lContainer[indexInContainer - 1][NEXT] = lView;\n    }\n    if (index < containerLength - CONTAINER_HEADER_OFFSET) {\n        lView[NEXT] = lContainer[indexInContainer];\n        addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);\n    }\n    else {\n        lContainer.push(lView);\n        lView[NEXT] = null;\n    }\n    lView[PARENT] = lContainer;\n    // track views where declaration and insertion points are different\n    const declarationLContainer = lView[DECLARATION_LCONTAINER];\n    if (declarationLContainer !== null && lContainer !== declarationLContainer) {\n        trackMovedView(declarationLContainer, lView);\n    }\n    // notify query that a new view has been added\n    const lQueries = lView[QUERIES];\n    if (lQueries !== null) {\n        lQueries.insertView(tView);\n    }\n    // Sets the attached flag\n    lView[FLAGS] |= 64 /* LViewFlags.Attached */;\n}\n/**\n * Track views created from the declaration container (TemplateRef) and inserted into a\n * different LContainer.\n */\nfunction trackMovedView(declarationContainer, lView) {\n    ngDevMode && assertDefined(lView, 'LView required');\n    ngDevMode && assertLContainer(declarationContainer);\n    const movedViews = declarationContainer[MOVED_VIEWS];\n    const insertedLContainer = lView[PARENT];\n    ngDevMode && assertLContainer(insertedLContainer);\n    const insertedComponentLView = insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];\n    ngDevMode && assertDefined(insertedComponentLView, 'Missing insertedComponentLView');\n    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];\n    ngDevMode && assertDefined(declaredComponentLView, 'Missing declaredComponentLView');\n    if (declaredComponentLView !== insertedComponentLView) {\n        // At this point the declaration-component is not same as insertion-component; this means that\n        // this is a transplanted view. Mark the declared lView as having transplanted views so that\n        // those views can participate in CD.\n        declarationContainer[HAS_TRANSPLANTED_VIEWS] = true;\n    }\n    if (movedViews === null) {\n        declarationContainer[MOVED_VIEWS] = [lView];\n    }\n    else {\n        movedViews.push(lView);\n    }\n}\nfunction detachMovedView(declarationContainer, lView) {\n    ngDevMode && assertLContainer(declarationContainer);\n    ngDevMode &&\n        assertDefined(declarationContainer[MOVED_VIEWS], 'A projected view should belong to a non-empty projected views collection');\n    const movedViews = declarationContainer[MOVED_VIEWS];\n    const declarationViewIndex = movedViews.indexOf(lView);\n    const insertionLContainer = lView[PARENT];\n    ngDevMode && assertLContainer(insertionLContainer);\n    // If the view was marked for refresh but then detached before it was checked (where the flag\n    // would be cleared and the counter decremented), we need to decrement the view counter here\n    // instead.\n    if (lView[FLAGS] & 512 /* LViewFlags.RefreshTransplantedView */) {\n        lView[FLAGS] &= ~512 /* LViewFlags.RefreshTransplantedView */;\n        updateTransplantedViewCount(insertionLContainer, -1);\n    }\n    movedViews.splice(declarationViewIndex, 1);\n}\n/**\n * Detaches a view from a container.\n *\n * This method removes the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param lContainer The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @returns Detached LView instance.\n */\nfunction detachView(lContainer, removeIndex) {\n    if (lContainer.length <= CONTAINER_HEADER_OFFSET)\n        return;\n    const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;\n    const viewToDetach = lContainer[indexInContainer];\n    if (viewToDetach) {\n        const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];\n        if (declarationLContainer !== null && declarationLContainer !== lContainer) {\n            detachMovedView(declarationLContainer, viewToDetach);\n        }\n        if (removeIndex > 0) {\n            lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];\n        }\n        const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);\n        removeViewFromContainer(viewToDetach[TVIEW], viewToDetach);\n        // notify query that a view has been removed\n        const lQueries = removedLView[QUERIES];\n        if (lQueries !== null) {\n            lQueries.detachView(removedLView[TVIEW]);\n        }\n        viewToDetach[PARENT] = null;\n        viewToDetach[NEXT] = null;\n        // Unsets the attached flag\n        viewToDetach[FLAGS] &= ~64 /* LViewFlags.Attached */;\n    }\n    return viewToDetach;\n}\n/**\n * A standalone function which destroys an LView,\n * conducting clean up (e.g. removing listeners, calling onDestroys).\n *\n * @param tView The `TView' of the `LView` to be destroyed\n * @param lView The view to be destroyed.\n */\nfunction destroyLView(tView, lView) {\n    if (!(lView[FLAGS] & 128 /* LViewFlags.Destroyed */)) {\n        const renderer = lView[RENDERER];\n        if (renderer.destroyNode) {\n            applyView(tView, lView, renderer, 3 /* WalkTNodeTreeAction.Destroy */, null, null);\n        }\n        destroyViewTree(lView);\n    }\n}\n/**\n * Calls onDestroys hooks for all directives and pipes in a given view and then removes all\n * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks\n * can be propagated to @Output listeners.\n *\n * @param tView `TView` for the `LView` to clean up.\n * @param lView The LView to clean up\n */\nfunction cleanUpView(tView, lView) {\n    if (!(lView[FLAGS] & 128 /* LViewFlags.Destroyed */)) {\n        // Usually the Attached flag is removed when the view is detached from its parent, however\n        // if it's a root view, the flag won't be unset hence why we're also removing on destroy.\n        lView[FLAGS] &= ~64 /* LViewFlags.Attached */;\n        // Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook\n        // runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If\n        // We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.\n        // This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is\n        // really more of an \"afterDestroy\" hook if you think about it.\n        lView[FLAGS] |= 128 /* LViewFlags.Destroyed */;\n        executeOnDestroys(tView, lView);\n        processCleanups(tView, lView);\n        // For component views only, the local renderer is destroyed at clean up time.\n        if (lView[TVIEW].type === 1 /* TViewType.Component */) {\n            ngDevMode && ngDevMode.rendererDestroy++;\n            lView[RENDERER].destroy();\n        }\n        const declarationContainer = lView[DECLARATION_LCONTAINER];\n        // we are dealing with an embedded view that is still inserted into a container\n        if (declarationContainer !== null && isLContainer(lView[PARENT])) {\n            // and this is a projected view\n            if (declarationContainer !== lView[PARENT]) {\n                detachMovedView(declarationContainer, lView);\n            }\n            // For embedded views still attached to a container: remove query result from this view.\n            const lQueries = lView[QUERIES];\n            if (lQueries !== null) {\n                lQueries.detachView(tView);\n            }\n        }\n        // Unregister the view once everything else has been cleaned up.\n        unregisterLView(lView);\n    }\n}\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction processCleanups(tView, lView) {\n    const tCleanup = tView.cleanup;\n    const lCleanup = lView[CLEANUP];\n    // `LCleanup` contains both share information with `TCleanup` as well as instance specific\n    // information appended at the end. We need to know where the end of the `TCleanup` information\n    // is, and we track this with `lastLCleanupIndex`.\n    let lastLCleanupIndex = -1;\n    if (tCleanup !== null) {\n        for (let i = 0; i < tCleanup.length - 1; i += 2) {\n            if (typeof tCleanup[i] === 'string') {\n                // This is a native DOM listener\n                const idxOrTargetGetter = tCleanup[i + 1];\n                const target = typeof idxOrTargetGetter === 'function' ?\n                    idxOrTargetGetter(lView) :\n                    unwrapRNode(lView[idxOrTargetGetter]);\n                const listener = lCleanup[lastLCleanupIndex = tCleanup[i + 2]];\n                const useCaptureOrSubIdx = tCleanup[i + 3];\n                if (typeof useCaptureOrSubIdx === 'boolean') {\n                    // native DOM listener registered with Renderer3\n                    target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);\n                }\n                else {\n                    if (useCaptureOrSubIdx >= 0) {\n                        // unregister\n                        lCleanup[lastLCleanupIndex = useCaptureOrSubIdx]();\n                    }\n                    else {\n                        // Subscription\n                        lCleanup[lastLCleanupIndex = -useCaptureOrSubIdx].unsubscribe();\n                    }\n                }\n                i += 2;\n            }\n            else {\n                // This is a cleanup function that is grouped with the index of its context\n                const context = lCleanup[lastLCleanupIndex = tCleanup[i + 1]];\n                tCleanup[i].call(context);\n            }\n        }\n    }\n    if (lCleanup !== null) {\n        for (let i = lastLCleanupIndex + 1; i < lCleanup.length; i++) {\n            const instanceCleanupFn = lCleanup[i];\n            ngDevMode && assertFunction(instanceCleanupFn, 'Expecting instance cleanup function.');\n            instanceCleanupFn();\n        }\n        lView[CLEANUP] = null;\n    }\n}\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(tView, lView) {\n    let destroyHooks;\n    if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n        for (let i = 0; i < destroyHooks.length; i += 2) {\n            const context = lView[destroyHooks[i]];\n            // Only call the destroy hook if the context has been requested.\n            if (!(context instanceof NodeInjectorFactory)) {\n                const toCall = destroyHooks[i + 1];\n                if (Array.isArray(toCall)) {\n                    for (let j = 0; j < toCall.length; j += 2) {\n                        const callContext = context[toCall[j]];\n                        const hook = toCall[j + 1];\n                        profiler(4 /* ProfilerEvent.LifecycleHookStart */, callContext, hook);\n                        try {\n                            hook.call(callContext);\n                        }\n                        finally {\n                            profiler(5 /* ProfilerEvent.LifecycleHookEnd */, callContext, hook);\n                        }\n                    }\n                }\n                else {\n                    profiler(4 /* ProfilerEvent.LifecycleHookStart */, context, toCall);\n                    try {\n                        toCall.call(context);\n                    }\n                    finally {\n                        profiler(5 /* ProfilerEvent.LifecycleHookEnd */, context, toCall);\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n * Returns a native element if a node can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is made for projection but has not been inserted\n *   into destination.\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve render parent.\n * @param lView: Current `LView`.\n */\nfunction getParentRElement(tView, tNode, lView) {\n    return getClosestRElement(tView, tNode.parent, lView);\n}\n/**\n * Get closest `RElement` or `null` if it can't be found.\n *\n * If `TNode` is `TNodeType.Element` => return `RElement` at `LView[tNode.index]` location.\n * If `TNode` is `TNodeType.ElementContainer|IcuContain` => return the parent (recursively).\n * If `TNode` is `null` then return host `RElement`:\n *   - return `null` if projection\n *   - return `null` if parent container is disconnected (we have no parent.)\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve `RElement` (or `null` if host element is\n *     needed).\n * @param lView: Current `LView`.\n * @returns `null` if the `RElement` can't be determined at this time (no parent / projection)\n */\nfunction getClosestRElement(tView, tNode, lView) {\n    let parentTNode = tNode;\n    // Skip over element and ICU containers as those are represented by a comment node and\n    // can't be used as a render parent.\n    while (parentTNode !== null &&\n        (parentTNode.type & (8 /* TNodeType.ElementContainer */ | 32 /* TNodeType.Icu */))) {\n        tNode = parentTNode;\n        parentTNode = tNode.parent;\n    }\n    // If the parent tNode is null, then we are inserting across views: either into an embedded view\n    // or a component view.\n    if (parentTNode === null) {\n        // We are inserting a root element of the component view into the component host element and\n        // it should always be eager.\n        return lView[HOST];\n    }\n    else {\n        ngDevMode && assertTNodeType(parentTNode, 3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */);\n        if (parentTNode.flags & 2 /* TNodeFlags.isComponentHost */) {\n            ngDevMode && assertTNodeForLView(parentTNode, lView);\n            const encapsulation = tView.data[parentTNode.directiveStart].encapsulation;\n            // We've got a parent which is an element in the current view. We just need to verify if the\n            // parent element is not a component. Component's content nodes are not inserted immediately\n            // because they will be projected, and so doing insert at this point would be wasteful.\n            // Since the projection would then move it to its final destination. Note that we can't\n            // make this assumption when using the Shadow DOM, because the native projection placeholders\n            // (<content> or <slot>) have to be in place as elements are being inserted.\n            if (encapsulation === ViewEncapsulation.None ||\n                encapsulation === ViewEncapsulation.Emulated) {\n                return null;\n            }\n        }\n        return getNativeByTNode(parentTNode, lView);\n    }\n}\n/**\n * Inserts a native node before another native node for a given parent.\n * This is a utility function that can be used when native nodes were determined.\n */\nfunction nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {\n    ngDevMode && ngDevMode.rendererInsertBefore++;\n    renderer.insertBefore(parent, child, beforeNode, isMove);\n}\nfunction nativeAppendChild(renderer, parent, child) {\n    ngDevMode && ngDevMode.rendererAppendChild++;\n    ngDevMode && assertDefined(parent, 'parent node must be defined');\n    renderer.appendChild(parent, child);\n}\nfunction nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {\n    if (beforeNode !== null) {\n        nativeInsertBefore(renderer, parent, child, beforeNode, isMove);\n    }\n    else {\n        nativeAppendChild(renderer, parent, child);\n    }\n}\n/** Removes a node from the DOM given its native parent. */\nfunction nativeRemoveChild(renderer, parent, child, isHostElement) {\n    renderer.removeChild(parent, child, isHostElement);\n}\n/** Checks if an element is a `<template>` node. */\nfunction isTemplateNode(node) {\n    return node.tagName === 'TEMPLATE' && node.content !== undefined;\n}\n/**\n * Returns a native parent of a given native node.\n */\nfunction nativeParentNode(renderer, node) {\n    return renderer.parentNode(node);\n}\n/**\n * Returns a native sibling of a given native node.\n */\nfunction nativeNextSibling(renderer, node) {\n    return renderer.nextSibling(node);\n}\n/**\n * Find a node in front of which `currentTNode` should be inserted.\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account if i18n code has been invoked.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {\n    return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);\n}\n/**\n * Find a node in front of which `currentTNode` should be inserted. (Does not take i18n into\n * account)\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * does not take `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {\n    if (parentTNode.type & (8 /* TNodeType.ElementContainer */ | 32 /* TNodeType.Icu */)) {\n        return getNativeByTNode(parentTNode, lView);\n    }\n    return null;\n}\n/**\n * Tree shakable boundary for `getInsertInFrontOfRNodeWithI18n` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;\n/**\n * Tree shakable boundary for `processI18nInsertBefore` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _processI18nInsertBefore;\nfunction setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore) {\n    _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n;\n    _processI18nInsertBefore = processI18nInsertBefore;\n}\n/**\n * Appends the `child` native node (or a collection of nodes) to the `parent`.\n *\n * @param tView The `TView' to be appended\n * @param lView The current LView\n * @param childRNode The native child (or children) that should be appended\n * @param childTNode The TNode of the child element\n */\nfunction appendChild(tView, lView, childRNode, childTNode) {\n    const parentRNode = getParentRElement(tView, childTNode, lView);\n    const renderer = lView[RENDERER];\n    const parentTNode = childTNode.parent || lView[T_HOST];\n    const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);\n    if (parentRNode != null) {\n        if (Array.isArray(childRNode)) {\n            for (let i = 0; i < childRNode.length; i++) {\n                nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);\n            }\n        }\n        else {\n            nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);\n        }\n    }\n    _processI18nInsertBefore !== undefined &&\n        _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);\n}\n/**\n * Returns the first native node for a given LView, starting from the provided TNode.\n *\n * Native nodes are returned in the order in which those appear in the native tree (DOM).\n */\nfunction getFirstNativeNode(lView, tNode) {\n    if (tNode !== null) {\n        ngDevMode &&\n            assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 32 /* TNodeType.Icu */ | 16 /* TNodeType.Projection */);\n        const tNodeType = tNode.type;\n        if (tNodeType & 3 /* TNodeType.AnyRNode */) {\n            return getNativeByTNode(tNode, lView);\n        }\n        else if (tNodeType & 4 /* TNodeType.Container */) {\n            return getBeforeNodeForView(-1, lView[tNode.index]);\n        }\n        else if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n            const elIcuContainerChild = tNode.child;\n            if (elIcuContainerChild !== null) {\n                return getFirstNativeNode(lView, elIcuContainerChild);\n            }\n            else {\n                const rNodeOrLContainer = lView[tNode.index];\n                if (isLContainer(rNodeOrLContainer)) {\n                    return getBeforeNodeForView(-1, rNodeOrLContainer);\n                }\n                else {\n                    return unwrapRNode(rNodeOrLContainer);\n                }\n            }\n        }\n        else if (tNodeType & 32 /* TNodeType.Icu */) {\n            let nextRNode = icuContainerIterate(tNode, lView);\n            let rNode = nextRNode();\n            // If the ICU container has no nodes, than we use the ICU anchor as the node.\n            return rNode || unwrapRNode(lView[tNode.index]);\n        }\n        else {\n            const projectionNodes = getProjectionNodes(lView, tNode);\n            if (projectionNodes !== null) {\n                if (Array.isArray(projectionNodes)) {\n                    return projectionNodes[0];\n                }\n                const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n                ngDevMode && assertParentView(parentView);\n                return getFirstNativeNode(parentView, projectionNodes);\n            }\n            else {\n                return getFirstNativeNode(lView, tNode.next);\n            }\n        }\n    }\n    return null;\n}\nfunction getProjectionNodes(lView, tNode) {\n    if (tNode !== null) {\n        const componentView = lView[DECLARATION_COMPONENT_VIEW];\n        const componentHost = componentView[T_HOST];\n        const slotIdx = tNode.projection;\n        ngDevMode && assertProjectionSlots(lView);\n        return componentHost.projection[slotIdx];\n    }\n    return null;\n}\nfunction getBeforeNodeForView(viewIndexInContainer, lContainer) {\n    const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;\n    if (nextViewIndex < lContainer.length) {\n        const lView = lContainer[nextViewIndex];\n        const firstTNodeOfView = lView[TVIEW].firstChild;\n        if (firstTNodeOfView !== null) {\n            return getFirstNativeNode(lView, firstTNodeOfView);\n        }\n    }\n    return lContainer[NATIVE];\n}\n/**\n * Removes a native node itself using a given renderer. To remove the node we are looking up its\n * parent from the native tree as not all platforms / browsers support the equivalent of\n * node.remove().\n *\n * @param renderer A renderer to be used\n * @param rNode The native node that should be removed\n * @param isHostElement A flag indicating if a node to be removed is a host of a component.\n */\nfunction nativeRemoveNode(renderer, rNode, isHostElement) {\n    ngDevMode && ngDevMode.rendererRemoveNode++;\n    const nativeParent = nativeParentNode(renderer, rNode);\n    if (nativeParent) {\n        nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);\n    }\n}\n/**\n * Performs the operation of `action` on the node. Typically this involves inserting or removing\n * nodes on the LView or projection boundary.\n */\nfunction applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {\n    while (tNode != null) {\n        ngDevMode && assertTNodeForLView(tNode, lView);\n        ngDevMode &&\n            assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 16 /* TNodeType.Projection */ | 32 /* TNodeType.Icu */);\n        const rawSlotValue = lView[tNode.index];\n        const tNodeType = tNode.type;\n        if (isProjection) {\n            if (action === 0 /* WalkTNodeTreeAction.Create */) {\n                rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);\n                tNode.flags |= 4 /* TNodeFlags.isProjected */;\n            }\n        }\n        if ((tNode.flags & 64 /* TNodeFlags.isDetached */) !== 64 /* TNodeFlags.isDetached */) {\n            if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n                applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);\n                applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n            }\n            else if (tNodeType & 32 /* TNodeType.Icu */) {\n                const nextRNode = icuContainerIterate(tNode, lView);\n                let rNode;\n                while (rNode = nextRNode()) {\n                    applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n                }\n                applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n            }\n            else if (tNodeType & 16 /* TNodeType.Projection */) {\n                applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);\n            }\n            else {\n                ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */);\n                applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n            }\n        }\n        tNode = isProjection ? tNode.projectionNext : tNode.next;\n    }\n}\nfunction applyView(tView, lView, renderer, action, parentRElement, beforeNode) {\n    applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);\n}\n/**\n * `applyProjection` performs operation on the projection.\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param tView The `TView` of `LView` which needs to be inserted, detached, destroyed\n * @param lView The `LView` which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n */\nfunction applyProjection(tView, lView, tProjectionNode) {\n    const renderer = lView[RENDERER];\n    const parentRNode = getParentRElement(tView, tProjectionNode, lView);\n    const parentTNode = tProjectionNode.parent || lView[T_HOST];\n    let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);\n    applyProjectionRecursive(renderer, 0 /* WalkTNodeTreeAction.Create */, lView, tProjectionNode, parentRNode, beforeNode);\n}\n/**\n * `applyProjectionRecursive` performs operation on the projection specified by `action` (insert,\n * detach, destroy)\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param renderer Render to use\n * @param action action to perform (insert, detach, destroy)\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {\n    const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n    const componentNode = componentLView[T_HOST];\n    ngDevMode &&\n        assertEqual(typeof tProjectionNode.projection, 'number', 'expecting projection index');\n    const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];\n    if (Array.isArray(nodeToProjectOrRNodes)) {\n        // This should not exist, it is a bit of a hack. When we bootstrap a top level node and we\n        // need to support passing projectable nodes, so we cheat and put them in the TNode\n        // of the Host TView. (Yes we put instance info at the T Level). We can get away with it\n        // because we know that that TView is not shared and therefore it will not be a problem.\n        // This should be refactored and cleaned up.\n        for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {\n            const rNode = nodeToProjectOrRNodes[i];\n            applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n        }\n    }\n    else {\n        let nodeToProject = nodeToProjectOrRNodes;\n        const projectedComponentLView = componentLView[PARENT];\n        applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);\n    }\n}\n/**\n * `applyContainer` performs an operation on the container and its views as specified by\n * `action` (insert, detach, destroy)\n *\n * Inserting a Container is complicated by the fact that the container may have Views which\n * themselves have containers or projections.\n *\n * @param renderer Renderer to use\n * @param action action to perform (insert, detach, destroy)\n * @param lContainer The LContainer which needs to be inserted, detached, destroyed.\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {\n    ngDevMode && assertLContainer(lContainer);\n    const anchor = lContainer[NATIVE]; // LContainer has its own before node.\n    const native = unwrapRNode(lContainer);\n    // An LContainer can be created dynamically on any node by injecting ViewContainerRef.\n    // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor\n    // node (comment in the DOM) that will be different from the LContainer's host node. In this\n    // particular case we need to execute action on 2 nodes:\n    // - container's host node (this is done in the executeActionOnElementOrContainer)\n    // - container's host node (this is done here)\n    if (anchor !== native) {\n        // This is very strange to me (Misko). I would expect that the native is same as anchor. I\n        // don't see a reason why they should be different, but they are.\n        //\n        // If they are we need to process the second anchor as well.\n        applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);\n    }\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n        const lView = lContainer[i];\n        applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);\n    }\n}\n/**\n * Writes class/style to element.\n *\n * @param renderer Renderer to use.\n * @param isClassBased `true` if it should be written to `class` (`false` to write to `style`)\n * @param rNode The Node to write to.\n * @param prop Property to write to. This would be the class/style name.\n * @param value Value to write. If `null`/`undefined`/`false` this is considered a remove (set/add\n *        otherwise).\n */\nfunction applyStyling(renderer, isClassBased, rNode, prop, value) {\n    if (isClassBased) {\n        // We actually want JS true/false here because any truthy value should add the class\n        if (!value) {\n            ngDevMode && ngDevMode.rendererRemoveClass++;\n            renderer.removeClass(rNode, prop);\n        }\n        else {\n            ngDevMode && ngDevMode.rendererAddClass++;\n            renderer.addClass(rNode, prop);\n        }\n    }\n    else {\n        let flags = prop.indexOf('-') === -1 ? undefined : RendererStyleFlags2.DashCase;\n        if (value == null /** || value === undefined */) {\n            ngDevMode && ngDevMode.rendererRemoveStyle++;\n            renderer.removeStyle(rNode, prop, flags);\n        }\n        else {\n            // A value is important if it ends with `!important`. The style\n            // parser strips any semicolons at the end of the value.\n            const isImportant = typeof value === 'string' ? value.endsWith('!important') : false;\n            if (isImportant) {\n                // !important has to be stripped from the value for it to be valid.\n                value = value.slice(0, -10);\n                flags |= RendererStyleFlags2.Important;\n            }\n            ngDevMode && ngDevMode.rendererSetStyle++;\n            renderer.setStyle(rNode, prop, value, flags);\n        }\n    }\n}\n/**\n * Write `cssText` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\nfunction writeDirectStyle(renderer, element, newValue) {\n    ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n    renderer.setAttribute(element, 'style', newValue);\n    ngDevMode && ngDevMode.rendererSetStyle++;\n}\n/**\n * Write `className` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\nfunction writeDirectClass(renderer, element, newValue) {\n    ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n    if (newValue === '') {\n        // There are tests in `google3` which expect `element.getAttribute('class')` to be `null`.\n        renderer.removeAttribute(element, 'class');\n    }\n    else {\n        renderer.setAttribute(element, 'class', newValue);\n    }\n    ngDevMode && ngDevMode.rendererSetClassName++;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy$1;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy$1() {\n    if (policy$1 === undefined) {\n        policy$1 = null;\n        if (_global$1.trustedTypes) {\n            try {\n                policy$1 = _global$1.trustedTypes.createPolicy('angular', {\n                    createHTML: (s) => s,\n                    createScript: (s) => s,\n                    createScriptURL: (s) => s,\n                });\n            }\n            catch {\n                // trustedTypes.createPolicy throws if called with a name that is\n                // already registered, even in report-only mode. Until the API changes,\n                // catch the error not to break the applications functionally. In such\n                // cases, the code will fall back to using strings.\n            }\n        }\n    }\n    return policy$1;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will be interpreted as HTML by a browser, e.g. when assigning to\n * element.innerHTML.\n */\nfunction trustedHTMLFromString(html) {\n    return getPolicy$1()?.createHTML(html) || html;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script) {\n    return getPolicy$1()?.createScript(script) || script;\n}\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that the\n * provided string will never cause an XSS vulnerability if used in a context\n * that will cause a browser to load and execute a resource, e.g. when\n * assigning to script.src.\n */\nfunction trustedScriptURLFromString(url) {\n    return getPolicy$1()?.createScriptURL(url) || url;\n}\n/**\n * Unsafely call the Function constructor with the given string arguments. It\n * is only available in development mode, and should be stripped out of\n * production code.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from development code, as use in production code can lead to\n * XSS vulnerabilities.\n */\nfunction newTrustedFunctionForDev(...args) {\n    if (typeof ngDevMode === 'undefined') {\n        throw new Error('newTrustedFunctionForDev should never be called in production');\n    }\n    if (!_global$1.trustedTypes) {\n        // In environments that don't support Trusted Types, fall back to the most\n        // straightforward implementation:\n        return new Function(...args);\n    }\n    // Chrome currently does not support passing TrustedScript to the Function\n    // constructor. The following implements the workaround proposed on the page\n    // below, where the Chromium bug is also referenced:\n    // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n    const fnArgs = args.slice(0, -1).join(',');\n    const fnBody = args[args.length - 1];\n    const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n    // Using eval directly confuses the compiler and prevents this module from\n    // being stripped out of JS binaries even if not used. The global['eval']\n    // indirection fixes that.\n    const fn = _global$1['eval'](trustedScriptFromString(body));\n    if (fn.bind === undefined) {\n        // Workaround for a browser bug that only exists in Chrome 83, where passing\n        // a TrustedScript to eval just returns the TrustedScript back without\n        // evaluating it. In that case, fall back to the most straightforward\n        // implementation:\n        return new Function(...args);\n    }\n    // To completely mimic the behavior of calling \"new Function\", two more\n    // things need to happen:\n    // 1. Stringifying the resulting function should return its source code\n    fn.toString = () => body;\n    // 2. When calling the resulting function, `this` should refer to `global`\n    return fn.bind(_global$1);\n    // When Trusted Types support in Function constructors is widely available,\n    // the implementation of this function can be simplified to:\n    // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Validation function invoked at runtime for each binding that might potentially\n * represent a security-sensitive attribute of an <iframe>.\n * See `IFRAME_SECURITY_SENSITIVE_ATTRS` in the\n * `packages/compiler/src/schema/dom_security_schema.ts` script for the full list\n * of such attributes.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275validateIframeAttribute(attrValue, tagName, attrName) {\n    const lView = getLView();\n    const tNode = getSelectedTNode();\n    const element = getNativeByTNode(tNode, lView);\n    // Restrict any dynamic bindings of security-sensitive attributes/properties\n    // on an <iframe> for security reasons.\n    if (tNode.type === 2 /* TNodeType.Element */ && tagName.toLowerCase() === 'iframe') {\n        const iframe = element;\n        // Unset previously applied `src` and `srcdoc` if we come across a situation when\n        // a security-sensitive attribute is set later via an attribute/property binding.\n        iframe.src = '';\n        iframe.srcdoc = trustedHTMLFromString('');\n        // Also remove the <iframe> from the document.\n        nativeRemoveNode(lView[RENDERER], iframe);\n        const errorMessage = ngDevMode &&\n            `Angular has detected that the \\`${attrName}\\` was applied ` +\n                `as a binding to an <iframe>${getTemplateLocationDetails(lView)}. ` +\n                `For security reasons, the \\`${attrName}\\` can be set on an <iframe> ` +\n                `as a static attribute only. \\n` +\n                `To fix this, switch the \\`${attrName}\\` binding to a static attribute ` +\n                `in a template or in host bindings section.`;\n        throw new RuntimeError(-910 /* RuntimeErrorCode.UNSAFE_IFRAME_ATTRS */, errorMessage);\n    }\n    return attrValue;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Most of the use of `document` in Angular is from within the DI system so it is possible to simply\n * inject the `DOCUMENT` token and are done.\n *\n * Ivy is special because it does not rely upon the DI and must get hold of the document some other\n * way.\n *\n * The solution is to define `getDocument()` and `setDocument()` top-level functions for ivy.\n * Wherever ivy needs the global document, it calls `getDocument()` instead.\n *\n * When running ivy outside of a browser environment, it is necessary to call `setDocument()` to\n * tell ivy what the global `document` is.\n *\n * Angular does this for us in each of the standard platforms (`Browser`, `Server`, and `WebWorker`)\n * by calling `setDocument()` when providing the `DOCUMENT` token.\n */\nlet DOCUMENT = undefined;\n/**\n * Tell ivy what the `document` is for this platform.\n *\n * It is only necessary to call this if the current platform is not a browser.\n *\n * @param document The object representing the global `document` in this environment.\n */\nfunction setDocument(document) {\n    DOCUMENT = document;\n}\n/**\n * Access the object that represents the `document` for this platform.\n *\n * Ivy calls this whenever it needs to access the `document` object.\n * For example to create the renderer or to do sanitization.\n */\nfunction getDocument() {\n    if (DOCUMENT !== undefined) {\n        return DOCUMENT;\n    }\n    else if (typeof document !== 'undefined') {\n        return document;\n    }\n    // No \"document\" can be found. This should only happen if we are running ivy outside Angular and\n    // the current platform is not a browser. Since this is not a supported scenario at the moment\n    // this should not happen in Angular apps.\n    // Once we support running ivy outside of Angular we will need to publish `setDocument()` as a\n    // public API. Meanwhile we just return `undefined` and let the application fail.\n    return undefined;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy() {\n    if (policy === undefined) {\n        policy = null;\n        if (_global$1.trustedTypes) {\n            try {\n                policy = _global$1.trustedTypes\n                    .createPolicy('angular#unsafe-bypass', {\n                    createHTML: (s) => s,\n                    createScript: (s) => s,\n                    createScriptURL: (s) => s,\n                });\n            }\n            catch {\n                // trustedTypes.createPolicy throws if called with a name that is\n                // already registered, even in report-only mode. Until the API changes,\n                // catch the error not to break the applications functionally. In such\n                // cases, the code will fall back to using strings.\n            }\n        }\n    }\n    return policy;\n}\n/**\n * Unsafely promote a string to a TrustedHTML, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedHTMLFromStringBypass(html) {\n    return getPolicy()?.createHTML(html) || html;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedScriptFromStringBypass(script) {\n    return getPolicy()?.createScript(script) || script;\n}\n/**\n * Unsafely promote a string to a TrustedScriptURL, falling back to strings\n * when Trusted Types are not available.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only passed strings that come directly from custom sanitizers or the\n * bypassSecurityTrust* functions.\n */\nfunction trustedScriptURLFromStringBypass(url) {\n    return getPolicy()?.createScriptURL(url) || url;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass SafeValueImpl {\n    constructor(changingThisBreaksApplicationSecurity) {\n        this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;\n    }\n    toString() {\n        return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` +\n            ` (see https://g.co/ng/security#xss)`;\n    }\n}\nclass SafeHtmlImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"HTML\" /* BypassType.Html */;\n    }\n}\nclass SafeStyleImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"Style\" /* BypassType.Style */;\n    }\n}\nclass SafeScriptImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"Script\" /* BypassType.Script */;\n    }\n}\nclass SafeUrlImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"URL\" /* BypassType.Url */;\n    }\n}\nclass SafeResourceUrlImpl extends SafeValueImpl {\n    getTypeName() {\n        return \"ResourceURL\" /* BypassType.ResourceUrl */;\n    }\n}\nfunction unwrapSafeValue(value) {\n    return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity :\n        value;\n}\nfunction allowSanitizationBypassAndThrow(value, type) {\n    const actualType = getSanitizationBypassType(value);\n    if (actualType != null && actualType !== type) {\n        // Allow ResourceURLs in URL contexts, they are strictly more trusted.\n        if (actualType === \"ResourceURL\" /* BypassType.ResourceUrl */ && type === \"URL\" /* BypassType.Url */)\n            return true;\n        throw new Error(`Required a safe ${type}, got a ${actualType} (see https://g.co/ng/security#xss)`);\n    }\n    return actualType === type;\n}\nfunction getSanitizationBypassType(value) {\n    return value instanceof SafeValueImpl && value.getTypeName() || null;\n}\n/**\n * Mark `html` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\n *\n * @param trustedHtml `html` string which needs to be implicitly trusted.\n * @returns a `html` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustHtml(trustedHtml) {\n    return new SafeHtmlImpl(trustedHtml);\n}\n/**\n * Mark `style` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\n *\n * @param trustedStyle `style` string which needs to be implicitly trusted.\n * @returns a `style` hich has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustStyle(trustedStyle) {\n    return new SafeStyleImpl(trustedStyle);\n}\n/**\n * Mark `script` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\n *\n * @param trustedScript `script` string which needs to be implicitly trusted.\n * @returns a `script` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustScript(trustedScript) {\n    return new SafeScriptImpl(trustedScript);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\n *\n * @param trustedUrl `url` string which needs to be implicitly trusted.\n * @returns a `url`  which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustUrl(trustedUrl) {\n    return new SafeUrlImpl(trustedUrl);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\n *\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\n * @returns a `url` which has been branded to be implicitly trusted.\n */\nfunction bypassSanitizationTrustResourceUrl(trustedResourceUrl) {\n    return new SafeResourceUrlImpl(trustedResourceUrl);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This helper is used to get hold of an inert tree of DOM elements containing dirty HTML\n * that needs sanitizing.\n * Depending upon browser support we use one of two strategies for doing this.\n * Default: DOMParser strategy\n * Fallback: InertDocument strategy\n */\nfunction getInertBodyHelper(defaultDoc) {\n    const inertDocumentHelper = new InertDocumentHelper(defaultDoc);\n    return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;\n}\n/**\n * Uses DOMParser to create and fill an inert body element.\n * This is the default strategy used in browsers that support it.\n */\nclass DOMParserHelper {\n    constructor(inertDocumentHelper) {\n        this.inertDocumentHelper = inertDocumentHelper;\n    }\n    getInertBodyElement(html) {\n        // We add these extra elements to ensure that the rest of the content is parsed as expected\n        // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n        // `<head>` tag. Note that the `<body>` tag is closed implicitly to prevent unclosed tags\n        // in `html` from consuming the otherwise explicit `</body>` tag.\n        html = '<body><remove></remove>' + html;\n        try {\n            const body = new window.DOMParser()\n                .parseFromString(trustedHTMLFromString(html), 'text/html')\n                .body;\n            if (body === null) {\n                // In some browsers (e.g. Mozilla/5.0 iPad AppleWebKit Mobile) the `body` property only\n                // becomes available in the following tick of the JS engine. In that case we fall back to\n                // the `inertDocumentHelper` instead.\n                return this.inertDocumentHelper.getInertBodyElement(html);\n            }\n            body.removeChild(body.firstChild);\n            return body;\n        }\n        catch {\n            return null;\n        }\n    }\n}\n/**\n * Use an HTML5 `template` element, if supported, or an inert body element created via\n * `createHtmlDocument` to create and fill an inert DOM element.\n * This is the fallback strategy if the browser does not support DOMParser.\n */\nclass InertDocumentHelper {\n    constructor(defaultDoc) {\n        this.defaultDoc = defaultDoc;\n        this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');\n        if (this.inertDocument.body == null) {\n            // usually there should be only one body element in the document, but IE doesn't have any, so\n            // we need to create one.\n            const inertHtml = this.inertDocument.createElement('html');\n            this.inertDocument.appendChild(inertHtml);\n            const inertBodyElement = this.inertDocument.createElement('body');\n            inertHtml.appendChild(inertBodyElement);\n        }\n    }\n    getInertBodyElement(html) {\n        // Prefer using <template> element if supported.\n        const templateEl = this.inertDocument.createElement('template');\n        if ('content' in templateEl) {\n            templateEl.innerHTML = trustedHTMLFromString(html);\n            return templateEl;\n        }\n        // Note that previously we used to do something like `this.inertDocument.body.innerHTML = html`\n        // and we returned the inert `body` node. This was changed, because IE seems to treat setting\n        // `innerHTML` on an inserted element differently, compared to one that hasn't been inserted\n        // yet. In particular, IE appears to split some of the text into multiple text nodes rather\n        // than keeping them in a single one which ends up messing with Ivy's i18n parsing further\n        // down the line. This has been worked around by creating a new inert `body` and using it as\n        // the root node in which we insert the HTML.\n        const inertBody = this.inertDocument.createElement('body');\n        inertBody.innerHTML = trustedHTMLFromString(html);\n        // Support: IE 11 only\n        // strip custom-namespaced attributes on IE<=11\n        if (this.defaultDoc.documentMode) {\n            this.stripCustomNsAttrs(inertBody);\n        }\n        return inertBody;\n    }\n    /**\n     * When IE11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\n     * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.\n     * 'ns1:xlink:foo').\n     *\n     * This is undesirable since we don't want to allow any of these custom attributes. This method\n     * strips them all.\n     */\n    stripCustomNsAttrs(el) {\n        const elAttrs = el.attributes;\n        // loop backwards so that we can support removals.\n        for (let i = elAttrs.length - 1; 0 < i; i--) {\n            const attrib = elAttrs.item(i);\n            const attrName = attrib.name;\n            if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {\n                el.removeAttribute(attrName);\n            }\n        }\n        let childNode = el.firstChild;\n        while (childNode) {\n            if (childNode.nodeType === Node.ELEMENT_NODE)\n                this.stripCustomNsAttrs(childNode);\n            childNode = childNode.nextSibling;\n        }\n    }\n}\n/**\n * We need to determine whether the DOMParser exists in the global context and\n * supports parsing HTML; HTML parsing support is not as wide as other formats, see\n * https://developer.mozilla.org/en-US/docs/Web/API/DOMParser#Browser_compatibility.\n *\n * @suppress {uselessCode}\n */\nfunction isDOMParserAvailable() {\n    try {\n        return !!new window.DOMParser().parseFromString(trustedHTMLFromString(''), 'text/html');\n    }\n    catch {\n        return false;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\n *\n * This regular expression matches a subset of URLs that will not cause script\n * execution if used in URL context within a HTML document. Specifically, this\n * regular expression matches if (comment from here on and regex copied from\n * Soy's EscapingConventions):\n * (1) Either an allowed protocol (http, https, mailto or ftp).\n * (2) or no protocol.  A protocol must be followed by a colon. The below\n *     allows that by allowing colons only after one of the characters [/?#].\n *     A colon after a hash (#) must be in the fragment.\n *     Otherwise, a colon after a (?) must be in a query.\n *     Otherwise, a colon after a single solidus (/) must be in a path.\n *     Otherwise, a colon after a double solidus (//) must be in the authority\n *     (before port).\n *\n * The pattern disallows &, used in HTML entity declarations before\n * one of the characters in [/?#]. This disallows HTML entities used in the\n * protocol name, which should never happen, e.g. \"h&#116;tp\" for \"http\".\n * It also disallows HTML entities in the first path part of a relative path,\n * e.g. \"foo&lt;bar/baz\".  Our existing escaping functions should not produce\n * that. More importantly, it disallows masking of a colon,\n * e.g. \"javascript&#58;...\".\n *\n * This regular expression was taken from the Closure sanitization library.\n */\nconst SAFE_URL_PATTERN = /^(?:(?:https?|mailto|data|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;\nfunction _sanitizeUrl(url) {\n    url = String(url);\n    if (url.match(SAFE_URL_PATTERN))\n        return url;\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        console.warn(`WARNING: sanitizing unsafe URL value ${url} (see https://g.co/ng/security#xss)`);\n    }\n    return 'unsafe:' + url;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction tagSet(tags) {\n    const res = {};\n    for (const t of tags.split(','))\n        res[t] = true;\n    return res;\n}\nfunction merge(...sets) {\n    const res = {};\n    for (const s of sets) {\n        for (const v in s) {\n            if (s.hasOwnProperty(v))\n                res[v] = true;\n        }\n    }\n    return res;\n}\n// Good source of info about elements and attributes\n// https://html.spec.whatwg.org/#semantics\n// https://simon.html5.org/html-elements\n// Safe Void Elements - HTML5\n// https://html.spec.whatwg.org/#void-elements\nconst VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\n// Elements that you can, intentionally, leave open (and which close themselves)\n// https://html.spec.whatwg.org/#optional-tags\nconst OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\nconst OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\nconst OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);\n// Safe Block Elements - HTML5\nconst BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +\n    'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +\n    'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));\n// Inline Elements - HTML5\nconst INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +\n    'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +\n    'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));\nconst VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);\n// Attributes that have href and hence need to be sanitized\nconst URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');\nconst HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +\n    'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +\n    'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,' +\n    'valign,value,vspace,width');\n// Accessibility attributes as per WAI-ARIA 1.1 (W3C Working Draft 14 December 2018)\nconst ARIA_ATTRS = tagSet('aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,' +\n    'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,' +\n    'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,' +\n    'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,' +\n    'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,' +\n    'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,' +\n    'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext');\n// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security\n// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\n// innerHTML is required, SVG attributes should be added here.\n// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\n// can be sanitized, but they increase security surface area without a legitimate use case, so they\n// are left out here.\nconst VALID_ATTRS = merge(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);\n// Elements whose content should not be traversed/preserved, if the elements themselves are invalid.\n//\n// Typically, `<invalid>Some content</invalid>` would traverse (and in this case preserve)\n// `Some content`, but strip `invalid-element` opening/closing tags. For some elements, though, we\n// don't want to preserve the content, if the elements themselves are going to be removed.\nconst SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');\n/**\n * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\n * attributes.\n */\nclass SanitizingHtmlSerializer {\n    constructor() {\n        // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\n        // because characters were re-encoded.\n        this.sanitizedSomething = false;\n        this.buf = [];\n    }\n    sanitizeChildren(el) {\n        // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\n        // However this code never accesses properties off of `document` before deleting its contents\n        // again, so it shouldn't be vulnerable to DOM clobbering.\n        let current = el.firstChild;\n        let traverseContent = true;\n        while (current) {\n            if (current.nodeType === Node.ELEMENT_NODE) {\n                traverseContent = this.startElement(current);\n            }\n            else if (current.nodeType === Node.TEXT_NODE) {\n                this.chars(current.nodeValue);\n            }\n            else {\n                // Strip non-element, non-text nodes.\n                this.sanitizedSomething = true;\n            }\n            if (traverseContent && current.firstChild) {\n                current = current.firstChild;\n                continue;\n            }\n            while (current) {\n                // Leaving the element. Walk up and to the right, closing tags as we go.\n                if (current.nodeType === Node.ELEMENT_NODE) {\n                    this.endElement(current);\n                }\n                let next = this.checkClobberedElement(current, current.nextSibling);\n                if (next) {\n                    current = next;\n                    break;\n                }\n                current = this.checkClobberedElement(current, current.parentNode);\n            }\n        }\n        return this.buf.join('');\n    }\n    /**\n     * Sanitizes an opening element tag (if valid) and returns whether the element's contents should\n     * be traversed. Element content must always be traversed (even if the element itself is not\n     * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.\n     *\n     * @param element The element to sanitize.\n     * @return True if the element's contents should be traversed.\n     */\n    startElement(element) {\n        const tagName = element.nodeName.toLowerCase();\n        if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n            this.sanitizedSomething = true;\n            return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);\n        }\n        this.buf.push('<');\n        this.buf.push(tagName);\n        const elAttrs = element.attributes;\n        for (let i = 0; i < elAttrs.length; i++) {\n            const elAttr = elAttrs.item(i);\n            const attrName = elAttr.name;\n            const lower = attrName.toLowerCase();\n            if (!VALID_ATTRS.hasOwnProperty(lower)) {\n                this.sanitizedSomething = true;\n                continue;\n            }\n            let value = elAttr.value;\n            // TODO(martinprobst): Special case image URIs for data:image/...\n            if (URI_ATTRS[lower])\n                value = _sanitizeUrl(value);\n            this.buf.push(' ', attrName, '=\"', encodeEntities(value), '\"');\n        }\n        this.buf.push('>');\n        return true;\n    }\n    endElement(current) {\n        const tagName = current.nodeName.toLowerCase();\n        if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\n            this.buf.push('</');\n            this.buf.push(tagName);\n            this.buf.push('>');\n        }\n    }\n    chars(chars) {\n        this.buf.push(encodeEntities(chars));\n    }\n    checkClobberedElement(node, nextNode) {\n        if (nextNode &&\n            (node.compareDocumentPosition(nextNode) &\n                Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) {\n            throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);\n        }\n        return nextNode;\n    }\n}\n// Regular Expressions for parsing tags and attributes\nconst SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n// ! to ~ is the ASCII range.\nconst NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n */\nfunction encodeEntities(value) {\n    return value.replace(/&/g, '&amp;')\n        .replace(SURROGATE_PAIR_REGEXP, function (match) {\n        const hi = match.charCodeAt(0);\n        const low = match.charCodeAt(1);\n        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n    })\n        .replace(NON_ALPHANUMERIC_REGEXP, function (match) {\n        return '&#' + match.charCodeAt(0) + ';';\n    })\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;');\n}\nlet inertBodyHelper;\n/**\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n * the DOM in a browser environment.\n */\nfunction _sanitizeHtml(defaultDoc, unsafeHtmlInput) {\n    let inertBodyElement = null;\n    try {\n        inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);\n        // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\n        let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\n        inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n        // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\n        // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\n        let mXSSAttempts = 5;\n        let parsedHtml = unsafeHtml;\n        do {\n            if (mXSSAttempts === 0) {\n                throw new Error('Failed to sanitize html because the input is unstable');\n            }\n            mXSSAttempts--;\n            unsafeHtml = parsedHtml;\n            parsedHtml = inertBodyElement.innerHTML;\n            inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n        } while (unsafeHtml !== parsedHtml);\n        const sanitizer = new SanitizingHtmlSerializer();\n        const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && sanitizer.sanitizedSomething) {\n            console.warn('WARNING: sanitizing HTML stripped some content, see https://g.co/ng/security#xss');\n        }\n        return trustedHTMLFromString(safeHtml);\n    }\n    finally {\n        // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\n        if (inertBodyElement) {\n            const parent = getTemplateContent(inertBodyElement) || inertBodyElement;\n            while (parent.firstChild) {\n                parent.removeChild(parent.firstChild);\n            }\n        }\n    }\n}\nfunction getTemplateContent(el) {\n    return 'content' in el /** Microsoft/TypeScript#21517 */ && isTemplateElement(el) ?\n        el.content :\n        null;\n}\nfunction isTemplateElement(el) {\n    return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\n * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\n * handled.\n *\n * See DomSanitizer for more details on security in Angular applications.\n *\n * @publicApi\n */\nvar SecurityContext;\n(function (SecurityContext) {\n    SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n    SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n    SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n    SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n    SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n    SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing\n * dangerous content.\n *\n * This method parses the `html` and locates potentially dangerous content (such as urls and\n * javascript) and removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.\n *\n * @param unsafeHtml untrusted `html`, typically from the user.\n * @returns `html` string which is safe to display to user, because all of the dangerous javascript\n * and urls have been removed.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275sanitizeHtml(unsafeHtml) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '');\n    }\n    if (allowSanitizationBypassAndThrow(unsafeHtml, \"HTML\" /* BypassType.Html */)) {\n        return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));\n    }\n    return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));\n}\n/**\n * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing\n * dangerous content.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.\n *\n * @param unsafeStyle untrusted `style`, typically from the user.\n * @returns `style` string which is safe to bind to the `style` properties.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275sanitizeStyle(unsafeStyle) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';\n    }\n    if (allowSanitizationBypassAndThrow(unsafeStyle, \"Style\" /* BypassType.Style */)) {\n        return unwrapSafeValue(unsafeStyle);\n    }\n    return renderStringify(unsafeStyle);\n}\n/**\n * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing\n * dangerous\n * content.\n *\n * This method parses the `url` and locates potentially dangerous content (such as javascript) and\n * removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * all of the dangerous javascript has been removed.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275sanitizeUrl(unsafeUrl) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';\n    }\n    if (allowSanitizationBypassAndThrow(unsafeUrl, \"URL\" /* BypassType.Url */)) {\n        return unwrapSafeValue(unsafeUrl);\n    }\n    return _sanitizeUrl(renderStringify(unsafeUrl));\n}\n/**\n * A `url` sanitizer which only lets trusted `url`s through.\n *\n * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.\n *\n * @param unsafeResourceUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * only trusted `url`s have been allowed to pass.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275sanitizeResourceUrl(unsafeResourceUrl) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '');\n    }\n    if (allowSanitizationBypassAndThrow(unsafeResourceUrl, \"ResourceURL\" /* BypassType.ResourceUrl */)) {\n        return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));\n    }\n    throw new RuntimeError(904 /* RuntimeErrorCode.UNSAFE_VALUE_IN_RESOURCE_URL */, ngDevMode &&\n        'unsafe value used in a resource URL context (see https://g.co/ng/security#xss)');\n}\n/**\n * A `script` sanitizer which only lets trusted javascript through.\n *\n * This passes only `script`s marked trusted by calling {@link\n * bypassSanitizationTrustScript}.\n *\n * @param unsafeScript untrusted `script`, typically from the user.\n * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,\n * because only trusted `scripts` have been allowed to pass.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275sanitizeScript(unsafeScript) {\n    const sanitizer = getSanitizer();\n    if (sanitizer) {\n        return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '');\n    }\n    if (allowSanitizationBypassAndThrow(unsafeScript, \"Script\" /* BypassType.Script */)) {\n        return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));\n    }\n    throw new RuntimeError(905 /* RuntimeErrorCode.UNSAFE_VALUE_IN_SCRIPT */, ngDevMode && 'unsafe value used in a script context');\n}\n/**\n * A template tag function for promoting the associated constant literal to a\n * TrustedHTML. Interpolation is explicitly not allowed.\n *\n * @param html constant template literal containing trusted HTML.\n * @returns TrustedHTML wrapping `html`.\n *\n * @security This is a security-sensitive function and should only be used to\n * convert constant values of attributes and properties found in\n * application-provided Angular templates to TrustedHTML.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275trustConstantHtml(html) {\n    // The following runtime check ensures that the function was called as a\n    // template tag (e.g. \u0275\u0275trustConstantHtml`content`), without any interpolation\n    // (e.g. not \u0275\u0275trustConstantHtml`content ${variable}`). A TemplateStringsArray\n    // is an array with a `raw` property that is also an array. The associated\n    // template literal has no interpolation if and only if the length of the\n    // TemplateStringsArray is 1.\n    if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {\n        throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join('?')}`);\n    }\n    return trustedHTMLFromString(html[0]);\n}\n/**\n * A template tag function for promoting the associated constant literal to a\n * TrustedScriptURL. Interpolation is explicitly not allowed.\n *\n * @param url constant template literal containing a trusted script URL.\n * @returns TrustedScriptURL wrapping `url`.\n *\n * @security This is a security-sensitive function and should only be used to\n * convert constant values of attributes and properties found in\n * application-provided Angular templates to TrustedScriptURL.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275trustConstantResourceUrl(url) {\n    // The following runtime check ensures that the function was called as a\n    // template tag (e.g. \u0275\u0275trustConstantResourceUrl`content`), without any\n    // interpolation (e.g. not \u0275\u0275trustConstantResourceUrl`content ${variable}`). A\n    // TemplateStringsArray is an array with a `raw` property that is also an\n    // array. The associated template literal has no interpolation if and only if\n    // the length of the TemplateStringsArray is 1.\n    if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {\n        throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join('?')}`);\n    }\n    return trustedScriptURLFromString(url[0]);\n}\n/**\n * Detects which sanitizer to use for URL property, based on tag name and prop name.\n *\n * The rules are based on the RESOURCE_URL context config from\n * `packages/compiler/src/schema/dom_security_schema.ts`.\n * If tag and prop names don't match Resource URL schema, use URL sanitizer.\n */\nfunction getUrlSanitizer(tag, prop) {\n    if ((prop === 'src' &&\n        (tag === 'embed' || tag === 'frame' || tag === 'iframe' || tag === 'media' ||\n            tag === 'script')) ||\n        (prop === 'href' && (tag === 'base' || tag === 'link'))) {\n        return \u0275\u0275sanitizeResourceUrl;\n    }\n    return \u0275\u0275sanitizeUrl;\n}\n/**\n * Sanitizes URL, selecting sanitizer function based on tag and property names.\n *\n * This function is used in case we can't define security context at compile time, when only prop\n * name is available. This happens when we generate host bindings for Directives/Components. The\n * host element is unknown at compile time, so we defer calculation of specific sanitizer to\n * runtime.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @param tag target element tag name.\n * @param prop name of the property that contains the value.\n * @returns `url` string which is safe to bind.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275sanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {\n    return getUrlSanitizer(tag, prop)(unsafeUrl);\n}\nfunction validateAgainstEventProperties(name) {\n    if (name.toLowerCase().startsWith('on')) {\n        const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, ` +\n            `please use (${name.slice(2)})=...` +\n            `\\nIf '${name}' is a directive input, make sure the directive is imported by the` +\n            ` current module.`;\n        throw new RuntimeError(306 /* RuntimeErrorCode.INVALID_EVENT_BINDING */, errorMessage);\n    }\n}\nfunction validateAgainstEventAttributes(name) {\n    if (name.toLowerCase().startsWith('on')) {\n        const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, ` +\n            `please use (${name.slice(2)})=...`;\n        throw new RuntimeError(306 /* RuntimeErrorCode.INVALID_EVENT_BINDING */, errorMessage);\n    }\n}\nfunction getSanitizer() {\n    const lView = getLView();\n    return lView && lView[SANITIZER];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parameterized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides an additional level of type safety.\n *\n * ```\n * interface MyInterface {...}\n * const myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the `inject` function.\n * As you can see in the Tree-shakable InjectionToken example below.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As\n * mentioned above, `'root'` is the default value for `providedIn`.\n *\n * @usageNotes\n * ### Basic Examples\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n *\n * @publicApi\n */\nclass InjectionToken {\n    /**\n     * @param _desc   Description for the token,\n     *                used only for debugging purposes,\n     *                it should but does not need to be unique\n     * @param options Options for the token's usage, as described above\n     */\n    constructor(_desc, options) {\n        this._desc = _desc;\n        /** @internal */\n        this.ngMetadataName = 'InjectionToken';\n        this.\u0275prov = undefined;\n        if (typeof options == 'number') {\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                assertLessThan(options, 0, 'Only negative numbers are supported here');\n            // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.\n            // See `InjectorMarkers`\n            this.__NG_ELEMENT_ID__ = options;\n        }\n        else if (options !== undefined) {\n            this.\u0275prov = \u0275\u0275defineInjectable({\n                token: this,\n                providedIn: options.providedIn || 'root',\n                factory: options.factory,\n            });\n        }\n    }\n    /**\n     * @internal\n     */\n    get multi() {\n        return this;\n    }\n    toString() {\n        return `InjectionToken ${this._desc}`;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A multi-provider token for initialization functions that will run upon construction of an\n * environment injector.\n *\n * @publicApi\n */\nconst ENVIRONMENT_INITIALIZER = new InjectionToken('ENVIRONMENT_INITIALIZER');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nconst INJECTOR = new InjectionToken('INJECTOR', \n// Disable tslint because this is const enum which gets inlined not top level prop access.\n// tslint:disable-next-line: no-toplevel-property-access\n-1 /* InjectorMarkers.Injector */);\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst INJECTOR_DEF_TYPES = new InjectionToken('INJECTOR_DEF_TYPES');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass NullInjector {\n    get(token, notFoundValue = THROW_IF_NOT_FOUND) {\n        if (notFoundValue === THROW_IF_NOT_FOUND) {\n            const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n            error.name = 'NullInjectorError';\n            throw error;\n        }\n        return notFoundValue;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Collects providers from all NgModules and standalone components, including transitively imported\n * ones.\n *\n * Providers extracted via `importProvidersFrom` are only usable in an application injector or\n * another environment injector (such as a route injector). They should not be used in component\n * providers.\n *\n * More information about standalone components can be found in [this\n * guide](guide/standalone-components).\n *\n * @usageNotes\n * The results of the `importProvidersFrom` call can be used in the `bootstrapApplication` call:\n *\n * ```typescript\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     importProvidersFrom(NgModuleOne, NgModuleTwo)\n *   ]\n * });\n * ```\n *\n * You can also use the `importProvidersFrom` results in the `providers` field of a route, when a\n * standalone component is used:\n *\n * ```typescript\n * export const ROUTES: Route[] = [\n *   {\n *     path: 'foo',\n *     providers: [\n *       importProvidersFrom(NgModuleOne, NgModuleTwo)\n *     ],\n *     component: YourStandaloneComponent\n *   }\n * ];\n * ```\n *\n * @returns Collected providers from the specified list of types.\n * @publicApi\n * @developerPreview\n */\nfunction importProvidersFrom(...sources) {\n    return { \u0275providers: internalImportProvidersFrom(true, sources) };\n}\nfunction internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {\n    const providersOut = [];\n    const dedup = new Set(); // already seen types\n    let injectorTypesWithProviders;\n    deepForEach(sources, source => {\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {\n            const cmpDef = getComponentDef$1(source);\n            if (cmpDef?.standalone) {\n                throw new RuntimeError(800 /* RuntimeErrorCode.IMPORT_PROVIDERS_FROM_STANDALONE */, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component \"${stringifyForError(source)}\"`);\n            }\n        }\n        // Narrow `source` to access the internal type analogue for `ModuleWithProviders`.\n        const internalSource = source;\n        if (walkProviderTree(internalSource, providersOut, [], dedup)) {\n            injectorTypesWithProviders || (injectorTypesWithProviders = []);\n            injectorTypesWithProviders.push(internalSource);\n        }\n    });\n    // Collect all providers from `ModuleWithProviders` types.\n    if (injectorTypesWithProviders !== undefined) {\n        processInjectorTypesWithProviders(injectorTypesWithProviders, providersOut);\n    }\n    return providersOut;\n}\n/**\n * Collects all providers from the list of `ModuleWithProviders` and appends them to the provided\n * array.\n */\nfunction processInjectorTypesWithProviders(typesWithProviders, providersOut) {\n    for (let i = 0; i < typesWithProviders.length; i++) {\n        const { ngModule, providers } = typesWithProviders[i];\n        deepForEach(providers, provider => {\n            ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);\n            providersOut.push(provider);\n        });\n    }\n}\n/**\n * The logic visits an `InjectorType`, an `InjectorTypeWithProviders`, or a standalone\n * `ComponentType`, and all of its transitive providers and collects providers.\n *\n * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,\n * the function will return \"true\" to indicate that the providers of the type definition need\n * to be processed. This allows us to process providers of injector types after all imports of\n * an injector definition are processed. (following View Engine semantics: see FW-1349)\n */\nfunction walkProviderTree(container, providersOut, parents, dedup) {\n    container = resolveForwardRef(container);\n    if (!container)\n        return false;\n    // The actual type which had the definition. Usually `container`, but may be an unwrapped type\n    // from `InjectorTypeWithProviders`.\n    let defType = null;\n    let injDef = getInjectorDef(container);\n    const cmpDef = !injDef && getComponentDef$1(container);\n    if (!injDef && !cmpDef) {\n        // `container` is not an injector type or a component type. It might be:\n        //  * An `InjectorTypeWithProviders` that wraps an injector type.\n        //  * A standalone directive or pipe that got pulled in from a standalone component's\n        //    dependencies.\n        // Try to unwrap it as an `InjectorTypeWithProviders` first.\n        const ngModule = container.ngModule;\n        injDef = getInjectorDef(ngModule);\n        if (injDef) {\n            defType = ngModule;\n        }\n        else {\n            // Not a component or injector type, so ignore it.\n            return false;\n        }\n    }\n    else if (cmpDef && !cmpDef.standalone) {\n        return false;\n    }\n    else {\n        defType = container;\n    }\n    // Check for circular dependencies.\n    if (ngDevMode && parents.indexOf(defType) !== -1) {\n        const defName = stringify(defType);\n        const path = parents.map(stringify);\n        throwCyclicDependencyError(defName, path);\n    }\n    // Check for multiple imports of the same module\n    const isDuplicate = dedup.has(defType);\n    if (cmpDef) {\n        if (isDuplicate) {\n            // This component definition has already been processed.\n            return false;\n        }\n        dedup.add(defType);\n        if (cmpDef.dependencies) {\n            const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;\n            for (const dep of deps) {\n                walkProviderTree(dep, providersOut, parents, dedup);\n            }\n        }\n    }\n    else if (injDef) {\n        // First, include providers from any imports.\n        if (injDef.imports != null && !isDuplicate) {\n            // Before processing defType's imports, add it to the set of parents. This way, if it ends\n            // up deeply importing itself, this can be detected.\n            ngDevMode && parents.push(defType);\n            // Add it to the set of dedups. This way we can detect multiple imports of the same module\n            dedup.add(defType);\n            let importTypesWithProviders;\n            try {\n                deepForEach(injDef.imports, imported => {\n                    if (walkProviderTree(imported, providersOut, parents, dedup)) {\n                        importTypesWithProviders || (importTypesWithProviders = []);\n                        // If the processed import is an injector type with providers, we store it in the\n                        // list of import types with providers, so that we can process those afterwards.\n                        importTypesWithProviders.push(imported);\n                    }\n                });\n            }\n            finally {\n                // Remove it from the parents set when finished.\n                ngDevMode && parents.pop();\n            }\n            // Imports which are declared with providers (TypeWithProviders) need to be processed\n            // after all imported modules are processed. This is similar to how View Engine\n            // processes/merges module imports in the metadata resolver. See: FW-1349.\n            if (importTypesWithProviders !== undefined) {\n                processInjectorTypesWithProviders(importTypesWithProviders, providersOut);\n            }\n        }\n        if (!isDuplicate) {\n            // Track the InjectorType and add a provider for it.\n            // It's important that this is done after the def's imports.\n            const factory = getFactoryDef(defType) || (() => new defType());\n            // Append extra providers to make more info available for consumers (to retrieve an injector\n            // type), as well as internally (to calculate an injection scope correctly and eagerly\n            // instantiate a `defType` when an injector is created).\n            providersOut.push(\n            // Provider to create `defType` using its factory.\n            { provide: defType, useFactory: factory, deps: EMPTY_ARRAY }, \n            // Make this `defType` available to an internal logic that calculates injector scope.\n            { provide: INJECTOR_DEF_TYPES, useValue: defType, multi: true }, \n            // Provider to eagerly instantiate `defType` via `ENVIRONMENT_INITIALIZER`.\n            { provide: ENVIRONMENT_INITIALIZER, useValue: () => \u0275\u0275inject(defType), multi: true } //\n            );\n        }\n        // Next, include providers listed on the definition itself.\n        const defProviders = injDef.providers;\n        if (defProviders != null && !isDuplicate) {\n            const injectorType = container;\n            deepForEach(defProviders, provider => {\n                ngDevMode && validateProvider(provider, defProviders, injectorType);\n                providersOut.push(provider);\n            });\n        }\n    }\n    else {\n        // Should not happen, but just in case.\n        return false;\n    }\n    return (defType !== container &&\n        container.providers !== undefined);\n}\nfunction validateProvider(provider, providers, containerType) {\n    if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) ||\n        isExistingProvider(provider)) {\n        return;\n    }\n    // Here we expect the provider to be a `useClass` provider (by elimination).\n    const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n    if (!classRef) {\n        throwInvalidProviderError(containerType, providers, provider);\n    }\n}\nconst USE_VALUE$1 = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });\nfunction isValueProvider(value) {\n    return value !== null && typeof value == 'object' && USE_VALUE$1 in value;\n}\nfunction isExistingProvider(value) {\n    return !!(value && value.useExisting);\n}\nfunction isFactoryProvider(value) {\n    return !!(value && value.useFactory);\n}\nfunction isTypeProvider(value) {\n    return typeof value === 'function';\n}\nfunction isClassProvider(value) {\n    return !!value.useClass;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nconst INJECTOR_SCOPE = new InjectionToken('Set Injector scope.');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR$1 = undefined;\nfunction getNullInjector() {\n    if (NULL_INJECTOR$1 === undefined) {\n        NULL_INJECTOR$1 = new NullInjector();\n    }\n    return NULL_INJECTOR$1;\n}\n/**\n * An `Injector` that's part of the environment injector hierarchy, which exists outside of the\n * component tree.\n *\n * @developerPreview\n */\nclass EnvironmentInjector {\n}\nclass R3Injector extends EnvironmentInjector {\n    constructor(providers, parent, source, scopes) {\n        super();\n        this.parent = parent;\n        this.source = source;\n        this.scopes = scopes;\n        /**\n         * Map of tokens to records which contain the instances of those tokens.\n         * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n         * to prevent further searches.\n         */\n        this.records = new Map();\n        /**\n         * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n         */\n        this._ngOnDestroyHooks = new Set();\n        this._onDestroyHooks = [];\n        this._destroyed = false;\n        // Start off by creating Records for every provider.\n        forEachSingleProvider(providers, provider => this.processProvider(provider));\n        // Make sure the INJECTOR token provides this injector.\n        this.records.set(INJECTOR, makeRecord(undefined, this));\n        // And `EnvironmentInjector` if the current injector is supposed to be env-scoped.\n        if (scopes.has('environment')) {\n            this.records.set(EnvironmentInjector, makeRecord(undefined, this));\n        }\n        // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n        // any injectable scoped to APP_ROOT_SCOPE.\n        const record = this.records.get(INJECTOR_SCOPE);\n        if (record != null && typeof record.value === 'string') {\n            this.scopes.add(record.value);\n        }\n        this.injectorDefTypes =\n            new Set(this.get(INJECTOR_DEF_TYPES.multi, EMPTY_ARRAY, InjectFlags.Self));\n    }\n    /**\n     * Flag indicating that this injector was previously destroyed.\n     */\n    get destroyed() {\n        return this._destroyed;\n    }\n    /**\n     * Destroy the injector and release references to every instance or provider associated with it.\n     *\n     * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n     * hook was found.\n     */\n    destroy() {\n        this.assertNotDestroyed();\n        // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n        this._destroyed = true;\n        try {\n            // Call all the lifecycle hooks.\n            for (const service of this._ngOnDestroyHooks) {\n                service.ngOnDestroy();\n            }\n            for (const hook of this._onDestroyHooks) {\n                hook();\n            }\n        }\n        finally {\n            // Release all references.\n            this.records.clear();\n            this._ngOnDestroyHooks.clear();\n            this.injectorDefTypes.clear();\n            this._onDestroyHooks.length = 0;\n        }\n    }\n    onDestroy(callback) {\n        this._onDestroyHooks.push(callback);\n    }\n    runInContext(fn) {\n        this.assertNotDestroyed();\n        const previousInjector = setCurrentInjector(this);\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        try {\n            return fn();\n        }\n        finally {\n            setCurrentInjector(previousInjector);\n            setInjectImplementation(previousInjectImplementation);\n        }\n    }\n    get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        this.assertNotDestroyed();\n        // Set the injection context.\n        const previousInjector = setCurrentInjector(this);\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        try {\n            // Check for the SkipSelf flag.\n            if (!(flags & InjectFlags.SkipSelf)) {\n                // SkipSelf isn't set, check if the record belongs to this injector.\n                let record = this.records.get(token);\n                if (record === undefined) {\n                    // No record, but maybe the token is scoped to this injector. Look for an injectable\n                    // def with a scope matching this injector.\n                    const def = couldBeInjectableType(token) && getInjectableDef(token);\n                    if (def && this.injectableDefInScope(def)) {\n                        // Found an injectable def and it's scoped to this injector. Pretend as if it was here\n                        // all along.\n                        record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n                    }\n                    else {\n                        record = null;\n                    }\n                    this.records.set(token, record);\n                }\n                // If a record was found, get the instance for it and return it.\n                if (record != null /* NOT null || undefined */) {\n                    return this.hydrate(token, record);\n                }\n            }\n            // Select the next injector based on the Self flag - if self is set, the next injector is\n            // the NullInjector, otherwise it's the parent.\n            const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();\n            // Set the notFoundValue based on the Optional flag - if optional is set and notFoundValue\n            // is undefined, the value is null, otherwise it's the notFoundValue.\n            notFoundValue = (flags & InjectFlags.Optional) && notFoundValue === THROW_IF_NOT_FOUND ?\n                null :\n                notFoundValue;\n            return nextInjector.get(token, notFoundValue);\n        }\n        catch (e) {\n            if (e.name === 'NullInjectorError') {\n                const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n                path.unshift(stringify(token));\n                if (previousInjector) {\n                    // We still have a parent injector, keep throwing\n                    throw e;\n                }\n                else {\n                    // Format & throw the final error message when we don't have any previous injector\n                    return catchInjectorError(e, token, 'R3InjectorError', this.source);\n                }\n            }\n            else {\n                throw e;\n            }\n        }\n        finally {\n            // Lastly, restore the previous injection context.\n            setInjectImplementation(previousInjectImplementation);\n            setCurrentInjector(previousInjector);\n        }\n    }\n    /** @internal */\n    resolveInjectorInitializers() {\n        const previousInjector = setCurrentInjector(this);\n        const previousInjectImplementation = setInjectImplementation(undefined);\n        try {\n            const initializers = this.get(ENVIRONMENT_INITIALIZER.multi, EMPTY_ARRAY, InjectFlags.Self);\n            if (ngDevMode && !Array.isArray(initializers)) {\n                throw new RuntimeError(209 /* RuntimeErrorCode.INVALID_MULTI_PROVIDER */, 'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' +\n                    `(expected an array, but got ${typeof initializers}). ` +\n                    'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' +\n                    '`multi: true` provider.');\n            }\n            for (const initializer of initializers) {\n                initializer();\n            }\n        }\n        finally {\n            setCurrentInjector(previousInjector);\n            setInjectImplementation(previousInjectImplementation);\n        }\n    }\n    toString() {\n        const tokens = [];\n        const records = this.records;\n        for (const token of records.keys()) {\n            tokens.push(stringify(token));\n        }\n        return `R3Injector[${tokens.join(', ')}]`;\n    }\n    assertNotDestroyed() {\n        if (this._destroyed) {\n            throw new RuntimeError(205 /* RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED */, ngDevMode && 'Injector has already been destroyed.');\n        }\n    }\n    /**\n     * Process a `SingleProvider` and add it.\n     */\n    processProvider(provider) {\n        // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n        // property.\n        provider = resolveForwardRef(provider);\n        let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);\n        // Construct a `Record` for the provider.\n        const record = providerToRecord(provider);\n        if (!isTypeProvider(provider) && provider.multi === true) {\n            // If the provider indicates that it's a multi-provider, process it specially.\n            // First check whether it's been defined already.\n            let multiRecord = this.records.get(token);\n            if (multiRecord) {\n                // It has. Throw a nice error if\n                if (ngDevMode && multiRecord.multi === undefined) {\n                    throwMixedMultiProviderError();\n                }\n            }\n            else {\n                multiRecord = makeRecord(undefined, NOT_YET, true);\n                multiRecord.factory = () => injectArgs(multiRecord.multi);\n                this.records.set(token, multiRecord);\n            }\n            token = provider;\n            multiRecord.multi.push(provider);\n        }\n        else {\n            const existing = this.records.get(token);\n            if (ngDevMode && existing && existing.multi !== undefined) {\n                throwMixedMultiProviderError();\n            }\n        }\n        this.records.set(token, record);\n    }\n    hydrate(token, record) {\n        if (ngDevMode && record.value === CIRCULAR) {\n            throwCyclicDependencyError(stringify(token));\n        }\n        else if (record.value === NOT_YET) {\n            record.value = CIRCULAR;\n            record.value = record.factory();\n        }\n        if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n            this._ngOnDestroyHooks.add(record.value);\n        }\n        return record.value;\n    }\n    injectableDefInScope(def) {\n        if (!def.providedIn) {\n            return false;\n        }\n        const providedIn = resolveForwardRef(def.providedIn);\n        if (typeof providedIn === 'string') {\n            return providedIn === 'any' || (this.scopes.has(providedIn));\n        }\n        else {\n            return this.injectorDefTypes.has(providedIn);\n        }\n    }\n}\nfunction injectableDefOrInjectorDefFactory(token) {\n    // Most tokens will have an injectable def directly on them, which specifies a factory directly.\n    const injectableDef = getInjectableDef(token);\n    const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n    if (factory !== null) {\n        return factory;\n    }\n    // InjectionTokens should have an injectable def (\u0275prov) and thus should be handled above.\n    // If it's missing that, it's an error.\n    if (token instanceof InjectionToken) {\n        throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Token ${stringify(token)} is missing a \u0275prov definition.`);\n    }\n    // Undecorated types can sometimes be created if they have no constructor arguments.\n    if (token instanceof Function) {\n        return getUndecoratedInjectableFactory(token);\n    }\n    // There was no way to resolve a factory for this token.\n    throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && 'unreachable');\n}\nfunction getUndecoratedInjectableFactory(token) {\n    // If the token has parameters then it has dependencies that we cannot resolve implicitly.\n    const paramLength = token.length;\n    if (paramLength > 0) {\n        const args = newArray(paramLength, '?');\n        throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${args.join(', ')}).`);\n    }\n    // The constructor function appears to have no parameters.\n    // This might be because it inherits from a super-class. In which case, use an injectable\n    // def from an ancestor if there is one.\n    // Otherwise this really is a simple class with no dependencies, so return a factory that\n    // just instantiates the zero-arg constructor.\n    const inheritedInjectableDef = getInheritedInjectableDef(token);\n    if (inheritedInjectableDef !== null) {\n        return () => inheritedInjectableDef.factory(token);\n    }\n    else {\n        return () => new token();\n    }\n}\nfunction providerToRecord(provider) {\n    if (isValueProvider(provider)) {\n        return makeRecord(undefined, provider.useValue);\n    }\n    else {\n        const factory = providerToFactory(provider);\n        return makeRecord(factory, NOT_YET);\n    }\n}\n/**\n * Converts a `SingleProvider` into a factory function.\n *\n * @param provider provider to convert to factory\n */\nfunction providerToFactory(provider, ngModuleType, providers) {\n    let factory = undefined;\n    if (ngDevMode && isImportedNgModuleProviders(provider)) {\n        throwInvalidProviderError(undefined, providers, provider);\n    }\n    if (isTypeProvider(provider)) {\n        const unwrappedProvider = resolveForwardRef(provider);\n        return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);\n    }\n    else {\n        if (isValueProvider(provider)) {\n            factory = () => resolveForwardRef(provider.useValue);\n        }\n        else if (isFactoryProvider(provider)) {\n            factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n        }\n        else if (isExistingProvider(provider)) {\n            factory = () => \u0275\u0275inject(resolveForwardRef(provider.useExisting));\n        }\n        else {\n            const classRef = resolveForwardRef(provider &&\n                (provider.useClass || provider.provide));\n            if (ngDevMode && !classRef) {\n                throwInvalidProviderError(ngModuleType, providers, provider);\n            }\n            if (hasDeps(provider)) {\n                factory = () => new (classRef)(...injectArgs(provider.deps));\n            }\n            else {\n                return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);\n            }\n        }\n    }\n    return factory;\n}\nfunction makeRecord(factory, value, multi = false) {\n    return {\n        factory: factory,\n        value: value,\n        multi: multi ? [] : undefined,\n    };\n}\nfunction hasDeps(value) {\n    return !!value.deps;\n}\nfunction hasOnDestroy(value) {\n    return value !== null && typeof value === 'object' &&\n        typeof value.ngOnDestroy === 'function';\n}\nfunction couldBeInjectableType(value) {\n    return (typeof value === 'function') ||\n        (typeof value === 'object' && value instanceof InjectionToken);\n}\nfunction isImportedNgModuleProviders(provider) {\n    return !!provider.\u0275providers;\n}\nfunction forEachSingleProvider(providers, fn) {\n    for (const provider of providers) {\n        if (Array.isArray(provider)) {\n            forEachSingleProvider(provider, fn);\n        }\n        else if (isImportedNgModuleProviders(provider)) {\n            forEachSingleProvider(provider.\u0275providers, fn);\n        }\n        else {\n            fn(provider);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Represents a component created by a `ComponentFactory`.\n * Provides access to the component instance and related objects,\n * and provides the means of destroying the instance.\n *\n * @publicApi\n */\nclass ComponentRef$1 {\n}\n/**\n * Base class for a factory that can create a component dynamically.\n * Instantiate a factory for a given type of component with `resolveComponentFactory()`.\n * Use the resulting `ComponentFactory.create()` method to create a component of that type.\n *\n * @see [Dynamic Components](guide/dynamic-component-loader)\n *\n * @publicApi\n *\n * @deprecated Angular no longer requires Component factories. Please use other APIs where\n *     Component class can be used directly.\n */\nclass ComponentFactory$1 {\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction noComponentFactoryError(component) {\n    const error = Error(`No component factory found for ${stringify(component)}. Did you add it to @NgModule.entryComponents?`);\n    error[ERROR_COMPONENT] = component;\n    return error;\n}\nconst ERROR_COMPONENT = 'ngComponent';\nfunction getComponent$1(error) {\n    return error[ERROR_COMPONENT];\n}\nclass _NullComponentFactoryResolver {\n    resolveComponentFactory(component) {\n        throw noComponentFactoryError(component);\n    }\n}\n/**\n * A simple registry that maps `Components` to generated `ComponentFactory` classes\n * that can be used to create instances of components.\n * Use to obtain the factory for a given component type,\n * then use the factory's `create()` method to create a component of that type.\n *\n * Note: since v13, dynamic component creation via\n * [`ViewContainerRef.createComponent`](api/core/ViewContainerRef#createComponent)\n * does **not** require resolving component factory: component class can be used directly.\n *\n * @publicApi\n *\n * @deprecated Angular no longer requires Component factories. Please use other APIs where\n *     Component class can be used directly.\n */\nclass ComponentFactoryResolver$1 {\n}\nComponentFactoryResolver$1.NULL = ( /* @__PURE__ */new _NullComponentFactoryResolver());\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Creates an ElementRef from the most recent node.\n *\n * @returns The ElementRef instance to use\n */\nfunction injectElementRef() {\n    return createElementRef(getCurrentTNode(), getLView());\n}\n/**\n * Creates an ElementRef given a node.\n *\n * @param tNode The node for which you'd like an ElementRef\n * @param lView The view to which the node belongs\n * @returns The ElementRef instance to use\n */\nfunction createElementRef(tNode, lView) {\n    return new ElementRef(getNativeByTNode(tNode, lView));\n}\n/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n *\n * @security Permitting direct access to the DOM can make your application more vulnerable to\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n * [Security Guide](https://g.co/ng/security).\n *\n * @publicApi\n */\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\n// and could do better codegen in the future.\nclass ElementRef {\n    constructor(nativeElement) {\n        this.nativeElement = nativeElement;\n    }\n}\n/**\n * @internal\n * @nocollapse\n */\nElementRef.__NG_ELEMENT_ID__ = injectElementRef;\n/**\n * Unwraps `ElementRef` and return the `nativeElement`.\n *\n * @param value value to unwrap\n * @returns `nativeElement` if `ElementRef` otherwise returns value as is.\n */\nfunction unwrapElementRef(value) {\n    return value instanceof ElementRef ? value.nativeElement : value;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst Renderer2Interceptor = new InjectionToken('Renderer2Interceptor');\n/**\n * Creates and initializes a custom renderer that implements the `Renderer2` base class.\n *\n * @publicApi\n */\nclass RendererFactory2 {\n}\n/**\n * Extend this base class to implement custom rendering. By default, Angular\n * renders a template into DOM. You can use custom rendering to intercept\n * rendering calls, or to render to something other than DOM.\n *\n * Create your custom renderer using `RendererFactory2`.\n *\n * Use a custom renderer to bypass Angular's templating and\n * make custom UI changes that can't be expressed declaratively.\n * For example if you need to set a property or an attribute whose name is\n * not statically known, use the `setProperty()` or\n * `setAttribute()` method.\n *\n * @publicApi\n */\nclass Renderer2 {\n}\n/**\n * @internal\n * @nocollapse\n */\nRenderer2.__NG_ELEMENT_ID__ = () => injectRenderer2();\n/** Injects a Renderer2 for the current component. */\nfunction injectRenderer2() {\n    // We need the Renderer to be based on the component that it's being injected into, however since\n    // DI happens before we've entered its view, `getLView` will return the parent view instead.\n    const lView = getLView();\n    const tNode = getCurrentTNode();\n    const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);\n    return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Sanitizer is used by the views to sanitize potentially dangerous values.\n *\n * @publicApi\n */\nclass Sanitizer {\n}\n/** @nocollapse */\nSanitizer.\u0275prov = \u0275\u0275defineInjectable({\n    token: Sanitizer,\n    providedIn: 'root',\n    factory: () => null,\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @description Represents the version of Angular\n *\n * @publicApi\n */\nclass Version {\n    constructor(full) {\n        this.full = full;\n        this.major = full.split('.')[0];\n        this.minor = full.split('.')[1];\n        this.patch = full.split('.').slice(2).join('.');\n    }\n}\n/**\n * @publicApi\n */\nconst VERSION = new Version('14.3.0');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This default value is when checking the hierarchy for a token.\n//\n// It means both:\n// - the token is not provided by the current injector,\n// - only the element injectors should be checked (ie do not check module injectors\n//\n//          mod1\n//         /\n//       el1   mod2\n//         \\  /\n//         el2\n//\n// When requesting el2.injector.get(token), we should check in the following order and return the\n// first found value:\n// - el2.injector.get(token, default)\n// - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module\n// - mod2.injector.get(token, default)\nconst NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst ERROR_ORIGINAL_ERROR = 'ngOriginalError';\nfunction wrappedError(message, originalError) {\n    const msg = `${message} caused by: ${originalError instanceof Error ? originalError.message : originalError}`;\n    const error = Error(msg);\n    error[ERROR_ORIGINAL_ERROR] = originalError;\n    return error;\n}\nfunction getOriginalError(error) {\n    return error[ERROR_ORIGINAL_ERROR];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n */\nclass ErrorHandler {\n    constructor() {\n        /**\n         * @internal\n         */\n        this._console = console;\n    }\n    handleError(error) {\n        const originalError = this._findOriginalError(error);\n        this._console.error('ERROR', error);\n        if (originalError) {\n            this._console.error('ORIGINAL ERROR', originalError);\n        }\n    }\n    /** @internal */\n    _findOriginalError(error) {\n        let e = error && getOriginalError(error);\n        while (e && getOriginalError(e)) {\n            e = getOriginalError(e);\n        }\n        return e || null;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction normalizeDebugBindingName(name) {\n    // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers\n    name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));\n    return `ng-reflect-${name}`;\n}\nconst CAMEL_CASE_REGEXP = /([A-Z])/g;\nfunction camelCaseToDashCase(input) {\n    return input.replace(CAMEL_CASE_REGEXP, (...m) => '-' + m[1].toLowerCase());\n}\nfunction normalizeDebugBindingValue(value) {\n    try {\n        // Limit the size of the value as otherwise the DOM just gets polluted.\n        return value != null ? value.toString().slice(0, 30) : value;\n    }\n    catch (e) {\n        return '[ERROR] Exception while trying to serialize the value';\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Verifies that a given type is a Standalone Component. */\nfunction assertStandaloneComponentType(type) {\n    assertComponentDef(type);\n    const componentDef = getComponentDef$1(type);\n    if (!componentDef.standalone) {\n        throw new RuntimeError(907 /* RuntimeErrorCode.TYPE_IS_NOT_STANDALONE */, `The ${stringifyForError(type)} component is not marked as standalone, ` +\n            `but Angular expects to have a standalone component here. ` +\n            `Please make sure the ${stringifyForError(type)} component has ` +\n            `the \\`standalone: true\\` flag in the decorator.`);\n    }\n}\n/** Verifies whether a given type is a component */\nfunction assertComponentDef(type) {\n    if (!getComponentDef$1(type)) {\n        throw new RuntimeError(906 /* RuntimeErrorCode.MISSING_GENERATED_DEF */, `The ${stringifyForError(type)} is not an Angular component, ` +\n            `make sure it has the \\`@Component\\` decorator.`);\n    }\n}\n/** Called when there are multiple component selectors that match a given node */\nfunction throwMultipleComponentError(tNode, first, second) {\n    throw new RuntimeError(-300 /* RuntimeErrorCode.MULTIPLE_COMPONENTS_MATCH */, `Multiple components match node with tagname ${tNode.value}: ` +\n        `${stringifyForError(first)} and ` +\n        `${stringifyForError(second)}`);\n}\n/** Throws an ExpressionChangedAfterChecked error if checkNoChanges mode is on. */\nfunction throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName) {\n    const field = propName ? ` for '${propName}'` : '';\n    let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${oldValue}'. Current value: '${currValue}'.`;\n    if (creationMode) {\n        msg +=\n            ` It seems like the view has been created after its parent and its children have been dirty checked.` +\n                ` Has it been created in a change detection hook?`;\n    }\n    throw new RuntimeError(-100 /* RuntimeErrorCode.EXPRESSION_CHANGED_AFTER_CHECKED */, msg);\n}\nfunction constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {\n    const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);\n    let oldValue = prefix, newValue = prefix;\n    for (let i = 0; i < chunks.length; i++) {\n        const slotIdx = rootIndex + i;\n        oldValue += `${lView[slotIdx]}${chunks[i]}`;\n        newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;\n    }\n    return { propName, oldValue, newValue };\n}\n/**\n * Constructs an object that contains details for the ExpressionChangedAfterItHasBeenCheckedError:\n * - property name (for property bindings or interpolations)\n * - old and new values, enriched using information from metadata\n *\n * More information on the metadata storage format can be found in `storePropertyBindingMetadata`\n * function description.\n */\nfunction getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {\n    const tData = lView[TVIEW].data;\n    const metadata = tData[bindingIndex];\n    if (typeof metadata === 'string') {\n        // metadata for property interpolation\n        if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {\n            return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);\n        }\n        // metadata for property binding\n        return { propName: metadata, oldValue, newValue };\n    }\n    // metadata is not available for this expression, check if this expression is a part of the\n    // property interpolation by going from the current binding index left and look for a string that\n    // contains INTERPOLATION_DELIMITER, the layout in tView.data for this case will look like this:\n    // [..., 'id\uFFFDPrefix \uFFFD and \uFFFD suffix', null, null, null, ...]\n    if (metadata === null) {\n        let idx = bindingIndex - 1;\n        while (typeof tData[idx] !== 'string' && tData[idx + 1] === null) {\n            idx--;\n        }\n        const meta = tData[idx];\n        if (typeof meta === 'string') {\n            const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, 'g'));\n            // first interpolation delimiter separates property name from interpolation parts (in case of\n            // property interpolations), so we subtract one from total number of found delimiters\n            if (matches && (matches.length - 1) > bindingIndex - idx) {\n                return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);\n            }\n        }\n    }\n    return { propName: undefined, oldValue, newValue };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns an index of `classToSearch` in `className` taking token boundaries into account.\n *\n * `classIndexOf('AB A', 'A', 0)` will be 3 (not 0 since `AB!==A`)\n *\n * @param className A string containing classes (whitespace separated)\n * @param classToSearch A class name to locate\n * @param startingIndex Starting location of search\n * @returns an index of the located class (or -1 if not found)\n */\nfunction classIndexOf(className, classToSearch, startingIndex) {\n    ngDevMode && assertNotEqual(classToSearch, '', 'can not look for \"\" string.');\n    let end = className.length;\n    while (true) {\n        const foundIndex = className.indexOf(classToSearch, startingIndex);\n        if (foundIndex === -1)\n            return foundIndex;\n        if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32 /* CharCode.SPACE */) {\n            // Ensure that it has leading whitespace\n            const length = classToSearch.length;\n            if (foundIndex + length === end ||\n                className.charCodeAt(foundIndex + length) <= 32 /* CharCode.SPACE */) {\n                // Ensure that it has trailing whitespace\n                return foundIndex;\n            }\n        }\n        // False positive, keep searching from where we left off.\n        startingIndex = foundIndex + 1;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst unusedValueToPlacateAjd$1 = unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd$4;\nconst NG_TEMPLATE_SELECTOR = 'ng-template';\n/**\n * Search the `TAttributes` to see if it contains `cssClassToMatch` (case insensitive)\n *\n * @param attrs `TAttributes` to search through.\n * @param cssClassToMatch class to match (lowercase)\n * @param isProjectionMode Whether or not class matching should look into the attribute `class` in\n *    addition to the `AttributeMarker.Classes`.\n */\nfunction isCssClassMatching(attrs, cssClassToMatch, isProjectionMode) {\n    // TODO(misko): The fact that this function needs to know about `isProjectionMode` seems suspect.\n    // It is strange to me that sometimes the class information comes in form of `class` attribute\n    // and sometimes in form of `AttributeMarker.Classes`. Some investigation is needed to determine\n    // if that is the right behavior.\n    ngDevMode &&\n        assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), 'Class name expected to be lowercase.');\n    let i = 0;\n    while (i < attrs.length) {\n        let item = attrs[i++];\n        if (isProjectionMode && item === 'class') {\n            item = attrs[i];\n            if (classIndexOf(item.toLowerCase(), cssClassToMatch, 0) !== -1) {\n                return true;\n            }\n        }\n        else if (item === 1 /* AttributeMarker.Classes */) {\n            // We found the classes section. Start searching for the class.\n            while (i < attrs.length && typeof (item = attrs[i++]) == 'string') {\n                // while we have strings\n                if (item.toLowerCase() === cssClassToMatch)\n                    return true;\n            }\n            return false;\n        }\n    }\n    return false;\n}\n/**\n * Checks whether the `tNode` represents an inline template (e.g. `*ngFor`).\n *\n * @param tNode current TNode\n */\nfunction isInlineTemplate(tNode) {\n    return tNode.type === 4 /* TNodeType.Container */ && tNode.value !== NG_TEMPLATE_SELECTOR;\n}\n/**\n * Function that checks whether a given tNode matches tag-based selector and has a valid type.\n *\n * Matching can be performed in 2 modes: projection mode (when we project nodes) and regular\n * directive matching mode:\n * - in the \"directive matching\" mode we do _not_ take TContainer's tagName into account if it is\n * different from NG_TEMPLATE_SELECTOR (value different from NG_TEMPLATE_SELECTOR indicates that a\n * tag name was extracted from * syntax so we would match the same directive twice);\n * - in the \"projection\" mode, we use a tag name potentially extracted from the * syntax processing\n * (applicable to TNodeType.Container only).\n */\nfunction hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {\n    const tagNameToCompare = tNode.type === 4 /* TNodeType.Container */ && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;\n    return currentSelector === tagNameToCompare;\n}\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data of the node to match\n * @param selector The selector to try matching against the node.\n * @param isProjectionMode if `true` we are matching for content projection, otherwise we are doing\n * directive matching.\n * @returns true if node matches the selector.\n */\nfunction isNodeMatchingSelector(tNode, selector, isProjectionMode) {\n    ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\n    let mode = 4 /* SelectorFlags.ELEMENT */;\n    const nodeAttrs = tNode.attrs || [];\n    // Find the index of first attribute that has no value, only a name.\n    const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);\n    // When processing \":not\" selectors, we skip to the next \":not\" if the\n    // current one doesn't match\n    let skipToNextSelector = false;\n    for (let i = 0; i < selector.length; i++) {\n        const current = selector[i];\n        if (typeof current === 'number') {\n            // If we finish processing a :not selector and it hasn't failed, return false\n            if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {\n                return false;\n            }\n            // If we are skipping to the next :not() and this mode flag is positive,\n            // it's a part of the current :not() selector, and we should keep skipping\n            if (skipToNextSelector && isPositive(current))\n                continue;\n            skipToNextSelector = false;\n            mode = current | (mode & 1 /* SelectorFlags.NOT */);\n            continue;\n        }\n        if (skipToNextSelector)\n            continue;\n        if (mode & 4 /* SelectorFlags.ELEMENT */) {\n            mode = 2 /* SelectorFlags.ATTRIBUTE */ | mode & 1 /* SelectorFlags.NOT */;\n            if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) ||\n                current === '' && selector.length === 1) {\n                if (isPositive(mode))\n                    return false;\n                skipToNextSelector = true;\n            }\n        }\n        else {\n            const selectorAttrValue = mode & 8 /* SelectorFlags.CLASS */ ? current : selector[++i];\n            // special case for matching against classes when a tNode has been instantiated with\n            // class and style values as separate attribute values (e.g. ['title', CLASS, 'foo'])\n            if ((mode & 8 /* SelectorFlags.CLASS */) && tNode.attrs !== null) {\n                if (!isCssClassMatching(tNode.attrs, selectorAttrValue, isProjectionMode)) {\n                    if (isPositive(mode))\n                        return false;\n                    skipToNextSelector = true;\n                }\n                continue;\n            }\n            const attrName = (mode & 8 /* SelectorFlags.CLASS */) ? 'class' : current;\n            const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);\n            if (attrIndexInNode === -1) {\n                if (isPositive(mode))\n                    return false;\n                skipToNextSelector = true;\n                continue;\n            }\n            if (selectorAttrValue !== '') {\n                let nodeAttrValue;\n                if (attrIndexInNode > nameOnlyMarkerIdx) {\n                    nodeAttrValue = '';\n                }\n                else {\n                    ngDevMode &&\n                        assertNotEqual(nodeAttrs[attrIndexInNode], 0 /* AttributeMarker.NamespaceURI */, 'We do not match directives on namespaced attributes');\n                    // we lowercase the attribute value to be able to match\n                    // selectors without case-sensitivity\n                    // (selectors are already in lowercase when generated)\n                    nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();\n                }\n                const compareAgainstClassName = mode & 8 /* SelectorFlags.CLASS */ ? nodeAttrValue : null;\n                if (compareAgainstClassName &&\n                    classIndexOf(compareAgainstClassName, selectorAttrValue, 0) !== -1 ||\n                    mode & 2 /* SelectorFlags.ATTRIBUTE */ && selectorAttrValue !== nodeAttrValue) {\n                    if (isPositive(mode))\n                        return false;\n                    skipToNextSelector = true;\n                }\n            }\n        }\n    }\n    return isPositive(mode) || skipToNextSelector;\n}\nfunction isPositive(mode) {\n    return (mode & 1 /* SelectorFlags.NOT */) === 0;\n}\n/**\n * Examines the attribute's definition array for a node to find the index of the\n * attribute that matches the given `name`.\n *\n * NOTE: This will not match namespaced attributes.\n *\n * Attribute matching depends upon `isInlineTemplate` and `isProjectionMode`.\n * The following table summarizes which types of attributes we attempt to match:\n *\n * ===========================================================================================================\n * Modes                   | Normal Attributes | Bindings Attributes | Template Attributes | I18n\n * Attributes\n * ===========================================================================================================\n * Inline + Projection     | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Inline + Directive      | NO                | NO                  | YES                 | NO\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Projection | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Directive  | YES               | YES                 | NO                  | YES\n * ===========================================================================================================\n *\n * @param name the name of the attribute to find\n * @param attrs the attribute array to examine\n * @param isInlineTemplate true if the node being matched is an inline template (e.g. `*ngFor`)\n * rather than a manually expanded template node (e.g `<ng-template>`).\n * @param isProjectionMode true if we are matching against content projection otherwise we are\n * matching against directives.\n */\nfunction findAttrIndexInNode(name, attrs, isInlineTemplate, isProjectionMode) {\n    if (attrs === null)\n        return -1;\n    let i = 0;\n    if (isProjectionMode || !isInlineTemplate) {\n        let bindingsMode = false;\n        while (i < attrs.length) {\n            const maybeAttrName = attrs[i];\n            if (maybeAttrName === name) {\n                return i;\n            }\n            else if (maybeAttrName === 3 /* AttributeMarker.Bindings */ || maybeAttrName === 6 /* AttributeMarker.I18n */) {\n                bindingsMode = true;\n            }\n            else if (maybeAttrName === 1 /* AttributeMarker.Classes */ || maybeAttrName === 2 /* AttributeMarker.Styles */) {\n                let value = attrs[++i];\n                // We should skip classes here because we have a separate mechanism for\n                // matching classes in projection mode.\n                while (typeof value === 'string') {\n                    value = attrs[++i];\n                }\n                continue;\n            }\n            else if (maybeAttrName === 4 /* AttributeMarker.Template */) {\n                // We do not care about Template attributes in this scenario.\n                break;\n            }\n            else if (maybeAttrName === 0 /* AttributeMarker.NamespaceURI */) {\n                // Skip the whole namespaced attribute and value. This is by design.\n                i += 4;\n                continue;\n            }\n            // In binding mode there are only names, rather than name-value pairs.\n            i += bindingsMode ? 1 : 2;\n        }\n        // We did not match the attribute\n        return -1;\n    }\n    else {\n        return matchTemplateAttribute(attrs, name);\n    }\n}\nfunction isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {\n    for (let i = 0; i < selector.length; i++) {\n        if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getProjectAsAttrValue(tNode) {\n    const nodeAttrs = tNode.attrs;\n    if (nodeAttrs != null) {\n        const ngProjectAsAttrIdx = nodeAttrs.indexOf(5 /* AttributeMarker.ProjectAs */);\n        // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n        // (attribute names are stored at even indexes)\n        if ((ngProjectAsAttrIdx & 1) === 0) {\n            return nodeAttrs[ngProjectAsAttrIdx + 1];\n        }\n    }\n    return null;\n}\nfunction getNameOnlyMarkerIndex(nodeAttrs) {\n    for (let i = 0; i < nodeAttrs.length; i++) {\n        const nodeAttr = nodeAttrs[i];\n        if (isNameOnlyAttributeMarker(nodeAttr)) {\n            return i;\n        }\n    }\n    return nodeAttrs.length;\n}\nfunction matchTemplateAttribute(attrs, name) {\n    let i = attrs.indexOf(4 /* AttributeMarker.Template */);\n    if (i > -1) {\n        i++;\n        while (i < attrs.length) {\n            const attr = attrs[i];\n            // Return in case we checked all template attrs and are switching to the next section in the\n            // attrs array (that starts with a number that represents an attribute marker).\n            if (typeof attr === 'number')\n                return -1;\n            if (attr === name)\n                return i;\n            i++;\n        }\n    }\n    return -1;\n}\n/**\n * Checks whether a selector is inside a CssSelectorList\n * @param selector Selector to be checked.\n * @param list List in which to look for the selector.\n */\nfunction isSelectorInSelectorList(selector, list) {\n    selectorListLoop: for (let i = 0; i < list.length; i++) {\n        const currentSelectorInList = list[i];\n        if (selector.length !== currentSelectorInList.length) {\n            continue;\n        }\n        for (let j = 0; j < selector.length; j++) {\n            if (selector[j] !== currentSelectorInList[j]) {\n                continue selectorListLoop;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction maybeWrapInNotSelector(isNegativeMode, chunk) {\n    return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;\n}\nfunction stringifyCSSSelector(selector) {\n    let result = selector[0];\n    let i = 1;\n    let mode = 2 /* SelectorFlags.ATTRIBUTE */;\n    let currentChunk = '';\n    let isNegativeMode = false;\n    while (i < selector.length) {\n        let valueOrMarker = selector[i];\n        if (typeof valueOrMarker === 'string') {\n            if (mode & 2 /* SelectorFlags.ATTRIBUTE */) {\n                const attrValue = selector[++i];\n                currentChunk +=\n                    '[' + valueOrMarker + (attrValue.length > 0 ? '=\"' + attrValue + '\"' : '') + ']';\n            }\n            else if (mode & 8 /* SelectorFlags.CLASS */) {\n                currentChunk += '.' + valueOrMarker;\n            }\n            else if (mode & 4 /* SelectorFlags.ELEMENT */) {\n                currentChunk += ' ' + valueOrMarker;\n            }\n        }\n        else {\n            //\n            // Append current chunk to the final result in case we come across SelectorFlag, which\n            // indicates that the previous section of a selector is over. We need to accumulate content\n            // between flags to make sure we wrap the chunk later in :not() selector if needed, e.g.\n            // ```\n            //  ['', Flags.CLASS, '.classA', Flags.CLASS | Flags.NOT, '.classB', '.classC']\n            // ```\n            // should be transformed to `.classA :not(.classB .classC)`.\n            //\n            // Note: for negative selector part, we accumulate content between flags until we find the\n            // next negative flag. This is needed to support a case where `:not()` rule contains more than\n            // one chunk, e.g. the following selector:\n            // ```\n            //  ['', Flags.ELEMENT | Flags.NOT, 'p', Flags.CLASS, 'foo', Flags.CLASS | Flags.NOT, 'bar']\n            // ```\n            // should be stringified to `:not(p.foo) :not(.bar)`\n            //\n            if (currentChunk !== '' && !isPositive(valueOrMarker)) {\n                result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n                currentChunk = '';\n            }\n            mode = valueOrMarker;\n            // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n            // mode is maintained for remaining chunks of a selector.\n            isNegativeMode = isNegativeMode || !isPositive(mode);\n        }\n        i++;\n    }\n    if (currentChunk !== '') {\n        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n    }\n    return result;\n}\n/**\n * Generates string representation of CSS selector in parsed form.\n *\n * ComponentDef and DirectiveDef are generated with the selector in parsed form to avoid doing\n * additional parsing at runtime (for example, for directive matching). However in some cases (for\n * example, while bootstrapping a component), a string version of the selector is required to query\n * for the host element on the page. This function takes the parsed form of a selector and returns\n * its string representation.\n *\n * @param selectorList selector in parsed form\n * @returns string representation of a given selector\n */\nfunction stringifyCSSSelectorList(selectorList) {\n    return selectorList.map(stringifyCSSSelector).join(',');\n}\n/**\n * Extracts attributes and classes information from a given CSS selector.\n *\n * This function is used while creating a component dynamically. In this case, the host element\n * (that is created dynamically) should contain attributes and classes specified in component's CSS\n * selector.\n *\n * @param selector CSS selector in parsed form (in a form of array)\n * @returns object with `attrs` and `classes` fields that contain extracted information\n */\nfunction extractAttrsAndClassesFromSelector(selector) {\n    const attrs = [];\n    const classes = [];\n    let i = 1;\n    let mode = 2 /* SelectorFlags.ATTRIBUTE */;\n    while (i < selector.length) {\n        let valueOrMarker = selector[i];\n        if (typeof valueOrMarker === 'string') {\n            if (mode === 2 /* SelectorFlags.ATTRIBUTE */) {\n                if (valueOrMarker !== '') {\n                    attrs.push(valueOrMarker, selector[++i]);\n                }\n            }\n            else if (mode === 8 /* SelectorFlags.CLASS */) {\n                classes.push(valueOrMarker);\n            }\n        }\n        else {\n            // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n            // mode is maintained for remaining chunks of a selector. Since attributes and classes are\n            // extracted only for \"positive\" part of the selector, we can stop here.\n            if (!isPositive(mode))\n                break;\n            mode = valueOrMarker;\n        }\n        i++;\n    }\n    return { attrs, classes };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** A special value which designates that a value has not changed. */\nconst NO_CHANGE = (typeof ngDevMode === 'undefined' || ngDevMode) ? { __brand__: 'NO_CHANGE' } : {};\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Advances to an element for later binding instructions.\n *\n * Used in conjunction with instructions like {@link property} to act on elements with specified\n * indices, for example those created with {@link element} or {@link elementStart}.\n *\n * ```ts\n * (rf: RenderFlags, ctx: any) => {\n *   if (rf & 1) {\n *     text(0, 'Hello');\n *     text(1, 'Goodbye')\n *     element(2, 'div');\n *   }\n *   if (rf & 2) {\n *     advance(2); // Advance twice to the <div>.\n *     property('title', 'test');\n *   }\n *  }\n * ```\n * @param delta Number of elements to advance forwards by.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275advance(delta) {\n    ngDevMode && assertGreaterThan(delta, 0, 'Can only advance forward');\n    selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());\n}\nfunction selectIndexInternal(tView, lView, index, checkNoChangesMode) {\n    ngDevMode && assertIndexInDeclRange(lView, index);\n    // Flush the initial hooks for elements in the view that have been added up to this point.\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!checkNoChangesMode) {\n        const hooksInitPhaseCompleted = (lView[FLAGS] & 3 /* LViewFlags.InitPhaseStateMask */) === 3 /* InitPhaseState.InitPhaseCompleted */;\n        if (hooksInitPhaseCompleted) {\n            const preOrderCheckHooks = tView.preOrderCheckHooks;\n            if (preOrderCheckHooks !== null) {\n                executeCheckHooks(lView, preOrderCheckHooks, index);\n            }\n        }\n        else {\n            const preOrderHooks = tView.preOrderHooks;\n            if (preOrderHooks !== null) {\n                executeInitAndCheckHooks(lView, preOrderHooks, 0 /* InitPhaseState.OnInitHooksToBeRun */, index);\n            }\n        }\n    }\n    // We must set the selected index *after* running the hooks, because hooks may have side-effects\n    // that cause other template functions to run, thus updating the selected index, which is global\n    // state. If we run `setSelectedIndex` *before* we run the hooks, in some cases the selected index\n    // will be altered by the time we leave the `\u0275\u0275advance` instruction.\n    setSelectedIndex(index);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nconst angularCoreDiEnv = {\n    '\u0275\u0275defineInjectable': \u0275\u0275defineInjectable,\n    '\u0275\u0275defineInjector': \u0275\u0275defineInjector,\n    '\u0275\u0275inject': \u0275\u0275inject,\n    '\u0275\u0275invalidFactoryDep': \u0275\u0275invalidFactoryDep,\n    'resolveForwardRef': resolveForwardRef,\n};\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\n * injectable def (`\u0275prov`) onto the injectable type.\n */\nfunction compileInjectable(type, meta) {\n    let ngInjectableDef = null;\n    let ngFactoryDef = null;\n    // if NG_PROV_DEF is already defined on this class then don't overwrite it\n    if (!type.hasOwnProperty(NG_PROV_DEF)) {\n        Object.defineProperty(type, NG_PROV_DEF, {\n            get: () => {\n                if (ngInjectableDef === null) {\n                    const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'injectable', type });\n                    ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/\u0275prov.js`, getInjectableMetadata(type, meta));\n                }\n                return ngInjectableDef;\n            },\n        });\n    }\n    // if NG_FACTORY_DEF is already defined on this class then don't overwrite it\n    if (!type.hasOwnProperty(NG_FACTORY_DEF)) {\n        Object.defineProperty(type, NG_FACTORY_DEF, {\n            get: () => {\n                if (ngFactoryDef === null) {\n                    const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'injectable', type });\n                    ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/\u0275fac.js`, {\n                        name: type.name,\n                        type,\n                        typeArgumentCount: 0,\n                        deps: reflectDependencies(type),\n                        target: compiler.FactoryTarget.Injectable\n                    });\n                }\n                return ngFactoryDef;\n            },\n            // Leave this configurable so that the factories from directives or pipes can take precedence.\n            configurable: true\n        });\n    }\n}\nconst USE_VALUE = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });\nfunction isUseClassProvider(meta) {\n    return meta.useClass !== undefined;\n}\nfunction isUseValueProvider(meta) {\n    return USE_VALUE in meta;\n}\nfunction isUseFactoryProvider(meta) {\n    return meta.useFactory !== undefined;\n}\nfunction isUseExistingProvider(meta) {\n    return meta.useExisting !== undefined;\n}\nfunction getInjectableMetadata(type, srcMeta) {\n    // Allow the compilation of a class with a `@Injectable()` decorator without parameters\n    const meta = srcMeta || { providedIn: null };\n    const compilerMeta = {\n        name: type.name,\n        type: type,\n        typeArgumentCount: 0,\n        providedIn: meta.providedIn,\n    };\n    if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {\n        compilerMeta.deps = convertDependencies(meta.deps);\n    }\n    // Check to see if the user explicitly provided a `useXxxx` property.\n    if (isUseClassProvider(meta)) {\n        compilerMeta.useClass = meta.useClass;\n    }\n    else if (isUseValueProvider(meta)) {\n        compilerMeta.useValue = meta.useValue;\n    }\n    else if (isUseFactoryProvider(meta)) {\n        compilerMeta.useFactory = meta.useFactory;\n    }\n    else if (isUseExistingProvider(meta)) {\n        compilerMeta.useExisting = meta.useExisting;\n    }\n    return compilerMeta;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injectable decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nconst Injectable = makeDecorator('Injectable', undefined, undefined, undefined, (type, meta) => compileInjectable(type, meta));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n *\n * @publicApi\n */\nfunction createInjector(defType, parent = null, additionalProviders = null, name) {\n    const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);\n    injector.resolveInjectorInitializers();\n    return injector;\n}\n/**\n * Creates a new injector without eagerly resolving its injector types. Can be used in places\n * where resolving the injector types immediately can lead to an infinite loop. The injector types\n * should be resolved at a later point by calling `_resolveInjectorDefTypes`.\n */\nfunction createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {\n    const providers = [\n        additionalProviders || EMPTY_ARRAY,\n        importProvidersFrom(defType),\n    ];\n    name = name || (typeof defType === 'object' ? undefined : stringify(defType));\n    return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Concrete injectors implement this interface. Injectors are configured\n * with [providers](guide/glossary#provider) that associate\n * dependencies of various types with [injection tokens](guide/glossary#di-token).\n *\n * @see [\"DI Providers\"](guide/dependency-injection-providers).\n * @see `StaticProvider`\n *\n * @usageNotes\n *\n *  The following example creates a service injector instance.\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Usage example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nclass Injector {\n    static create(options, parent) {\n        if (Array.isArray(options)) {\n            return createInjector({ name: '' }, parent, options, '');\n        }\n        else {\n            const name = options.name ?? '';\n            return createInjector({ name }, options.parent, options.providers, name);\n        }\n    }\n}\nInjector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\nInjector.NULL = ( /* @__PURE__ */new NullInjector());\n/** @nocollapse */\nInjector.\u0275prov = \u0275\u0275defineInjectable({\n    token: Injector,\n    providedIn: 'any',\n    factory: () => \u0275\u0275inject(INJECTOR),\n});\n/**\n * @internal\n * @nocollapse\n */\nInjector.__NG_ELEMENT_ID__ = -1 /* InjectorMarkers.Injector */;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction findFirstClosedCycle(keys) {\n    const res = [];\n    for (let i = 0; i < keys.length; ++i) {\n        if (res.indexOf(keys[i]) > -1) {\n            res.push(keys[i]);\n            return res;\n        }\n        res.push(keys[i]);\n    }\n    return res;\n}\nfunction constructResolvingPath(keys) {\n    if (keys.length > 1) {\n        const reversed = findFirstClosedCycle(keys.slice().reverse());\n        const tokenStrs = reversed.map(k => stringify(k.token));\n        return ' (' + tokenStrs.join(' -> ') + ')';\n    }\n    return '';\n}\nfunction injectionError(injector, key, constructResolvingMessage, originalError) {\n    const keys = [key];\n    const errMsg = constructResolvingMessage(keys);\n    const error = (originalError ? wrappedError(errMsg, originalError) : Error(errMsg));\n    error.addKey = addKey;\n    error.keys = keys;\n    error.injectors = [injector];\n    error.constructResolvingMessage = constructResolvingMessage;\n    error[ERROR_ORIGINAL_ERROR] = originalError;\n    return error;\n}\nfunction addKey(injector, key) {\n    this.injectors.push(injector);\n    this.keys.push(key);\n    // Note: This updated message won't be reflected in the `.stack` property\n    this.message = this.constructResolvingMessage(this.keys);\n}\n/**\n * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the\n * {@link Injector} does not have a {@link Provider} for the given key.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b:B) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n */\nfunction noProviderError(injector, key) {\n    return injectionError(injector, key, function (keys) {\n        const first = stringify(keys[0].token);\n        return `No provider for ${first}!${constructResolvingPath(keys)}`;\n    });\n}\n/**\n * Thrown when dependencies form a cycle.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * var injector = Injector.resolveAndCreate([\n *   {provide: \"one\", useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]},\n *   {provide: \"two\", useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]}\n * ]);\n *\n * expect(() => injector.get(\"one\")).toThrowError();\n * ```\n *\n * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\n */\nfunction cyclicDependencyError(injector, key) {\n    return injectionError(injector, key, function (keys) {\n        return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;\n    });\n}\n/**\n * Thrown when a constructing type returns with an Error.\n *\n * The `InstantiationError` class contains the original error plus the dependency graph which caused\n * this object to be instantiated.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor() {\n *     throw new Error('message');\n *   }\n * }\n *\n * var injector = Injector.resolveAndCreate([A]);\n\n * try {\n *   injector.get(A);\n * } catch (e) {\n *   expect(e instanceof InstantiationError).toBe(true);\n *   expect(e.originalException.message).toEqual(\"message\");\n *   expect(e.originalStack).toBeDefined();\n * }\n * ```\n */\nfunction instantiationError(injector, originalException, originalStack, key) {\n    return injectionError(injector, key, function (keys) {\n        const first = stringify(keys[0].token);\n        return `${originalException.message}: Error during instantiation of ${first}!${constructResolvingPath(keys)}.`;\n    }, originalException);\n}\n/**\n * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}\n * creation.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\n * ```\n */\nfunction invalidProviderError(provider) {\n    return Error(`Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);\n}\n/**\n * Thrown when the class has no annotation information.\n *\n * Lack of annotation information prevents the {@link Injector} from determining which dependencies\n * need to be injected into the constructor.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n *\n * This error is also thrown when the class not marked with {@link Injectable} has parameter types.\n *\n * ```typescript\n * class B {}\n *\n * class A {\n *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\n * }\n *\n * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\n * ```\n *\n */\nfunction noAnnotationError(typeOrFunc, params) {\n    const signature = [];\n    for (let i = 0, ii = params.length; i < ii; i++) {\n        const parameter = params[i];\n        if (!parameter || parameter.length == 0) {\n            signature.push('?');\n        }\n        else {\n            signature.push(parameter.map(stringify).join(' '));\n        }\n    }\n    return Error('Cannot resolve all parameters for \\'' + stringify(typeOrFunc) + '\\'(' +\n        signature.join(', ') + '). ' +\n        'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \\'' +\n        stringify(typeOrFunc) + '\\' is decorated with Injectable.');\n}\n/**\n * Thrown when getting an object by index.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {}\n *\n * var injector = Injector.resolveAndCreate([A]);\n *\n * expect(() => injector.getAt(100)).toThrowError();\n * ```\n *\n */\nfunction outOfBoundsError(index) {\n    return Error(`Index ${index} is out-of-bounds.`);\n}\n// TODO: add a working example after alpha38 is released\n/**\n * Thrown when a multi provider and a regular provider are bound to the same token.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\n *   { provide: \"Strings\", useValue: \"string1\", multi: true},\n *   { provide: \"Strings\", useValue: \"string2\", multi: false}\n * ])).toThrowError();\n * ```\n */\nfunction mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {\n    return Error(`Cannot mix multi providers and regular providers, got: ${provider1} ${provider2}`);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A unique object used for retrieving items from the {@link ReflectiveInjector}.\n *\n * Keys have:\n * - a system-wide unique `id`.\n * - a `token`.\n *\n * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\n * the\n * injector to store created objects in a more efficient way.\n *\n * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\n * resolving\n * providers.\n *\n * @deprecated No replacement\n * @publicApi\n */\nclass ReflectiveKey {\n    /**\n     * Private\n     */\n    constructor(token, id) {\n        this.token = token;\n        this.id = id;\n        if (!token) {\n            throw new RuntimeError(208 /* RuntimeErrorCode.MISSING_INJECTION_TOKEN */, ngDevMode && 'Token must be defined!');\n        }\n        this.displayName = stringify(this.token);\n    }\n    /**\n     * Retrieves a `Key` for a token.\n     */\n    static get(token) {\n        return _globalKeyRegistry.get(resolveForwardRef(token));\n    }\n    /**\n     * @returns the number of keys registered in the system.\n     */\n    static get numberOfKeys() {\n        return _globalKeyRegistry.numberOfKeys;\n    }\n}\nclass KeyRegistry {\n    constructor() {\n        this._allKeys = new Map();\n    }\n    get(token) {\n        if (token instanceof ReflectiveKey)\n            return token;\n        if (this._allKeys.has(token)) {\n            return this._allKeys.get(token);\n        }\n        const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);\n        this._allKeys.set(token, newKey);\n        return newKey;\n    }\n    get numberOfKeys() {\n        return this._allKeys.size;\n    }\n}\nconst _globalKeyRegistry = new KeyRegistry();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * `Dependency` is used by the framework to extend DI.\n * This is internal to Angular and should not be used directly.\n */\nclass ReflectiveDependency {\n    constructor(key, optional, visibility) {\n        this.key = key;\n        this.optional = optional;\n        this.visibility = visibility;\n    }\n    static fromKey(key) {\n        return new ReflectiveDependency(key, false, null);\n    }\n}\nconst _EMPTY_LIST = [];\nclass ResolvedReflectiveProvider_ {\n    constructor(key, resolvedFactories, multiProvider) {\n        this.key = key;\n        this.resolvedFactories = resolvedFactories;\n        this.multiProvider = multiProvider;\n        this.resolvedFactory = this.resolvedFactories[0];\n    }\n}\n/**\n * An internal resolved representation of a factory function created by resolving `Provider`.\n * @publicApi\n */\nclass ResolvedReflectiveFactory {\n    constructor(\n    /**\n     * Factory function which can return an instance of an object represented by a key.\n     */\n    factory, \n    /**\n     * Arguments (dependencies) to the `factory` function.\n     */\n    dependencies) {\n        this.factory = factory;\n        this.dependencies = dependencies;\n    }\n}\n/**\n * Resolve a single provider.\n */\nfunction resolveReflectiveFactory(provider) {\n    let factoryFn;\n    let resolvedDeps;\n    if (provider.useClass) {\n        const useClass = resolveForwardRef(provider.useClass);\n        factoryFn = getReflect().factory(useClass);\n        resolvedDeps = _dependenciesFor(useClass);\n    }\n    else if (provider.useExisting) {\n        factoryFn = (aliasInstance) => aliasInstance;\n        resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\n    }\n    else if (provider.useFactory) {\n        factoryFn = provider.useFactory;\n        resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\n    }\n    else {\n        factoryFn = () => provider.useValue;\n        resolvedDeps = _EMPTY_LIST;\n    }\n    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\n}\n/**\n * Converts the `Provider` into `ResolvedProvider`.\n *\n * `Injector` internally only uses `ResolvedProvider`, `Provider` contains convenience provider\n * syntax.\n */\nfunction resolveReflectiveProvider(provider) {\n    return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi || false);\n}\n/**\n * Resolve a list of Providers.\n */\nfunction resolveReflectiveProviders(providers) {\n    const normalized = _normalizeProviders(providers, []);\n    const resolved = normalized.map(resolveReflectiveProvider);\n    const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());\n    return Array.from(resolvedProviderMap.values());\n}\n/**\n * Merges a list of ResolvedProviders into a list where each key is contained exactly once and\n * multi providers have been merged.\n */\nfunction mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {\n    for (let i = 0; i < providers.length; i++) {\n        const provider = providers[i];\n        const existing = normalizedProvidersMap.get(provider.key.id);\n        if (existing) {\n            if (provider.multiProvider !== existing.multiProvider) {\n                throw mixingMultiProvidersWithRegularProvidersError(existing, provider);\n            }\n            if (provider.multiProvider) {\n                for (let j = 0; j < provider.resolvedFactories.length; j++) {\n                    existing.resolvedFactories.push(provider.resolvedFactories[j]);\n                }\n            }\n            else {\n                normalizedProvidersMap.set(provider.key.id, provider);\n            }\n        }\n        else {\n            let resolvedProvider;\n            if (provider.multiProvider) {\n                resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);\n            }\n            else {\n                resolvedProvider = provider;\n            }\n            normalizedProvidersMap.set(provider.key.id, resolvedProvider);\n        }\n    }\n    return normalizedProvidersMap;\n}\nfunction _normalizeProviders(providers, res) {\n    providers.forEach(b => {\n        if (b instanceof Type) {\n            res.push({ provide: b, useClass: b });\n        }\n        else if (b && typeof b == 'object' && b.provide !== undefined) {\n            res.push(b);\n        }\n        else if (Array.isArray(b)) {\n            _normalizeProviders(b, res);\n        }\n        else {\n            throw invalidProviderError(b);\n        }\n    });\n    return res;\n}\nfunction constructDependencies(typeOrFunc, dependencies) {\n    if (!dependencies) {\n        return _dependenciesFor(typeOrFunc);\n    }\n    else {\n        const params = dependencies.map(t => [t]);\n        return dependencies.map(t => _extractToken(typeOrFunc, t, params));\n    }\n}\nfunction _dependenciesFor(typeOrFunc) {\n    const params = getReflect().parameters(typeOrFunc);\n    if (!params)\n        return [];\n    if (params.some(p => p == null)) {\n        throw noAnnotationError(typeOrFunc, params);\n    }\n    return params.map(p => _extractToken(typeOrFunc, p, params));\n}\nfunction _extractToken(typeOrFunc, metadata, params) {\n    let token = null;\n    let optional = false;\n    if (!Array.isArray(metadata)) {\n        if (metadata instanceof Inject) {\n            return _createDependency(metadata.token, optional, null);\n        }\n        else {\n            return _createDependency(metadata, optional, null);\n        }\n    }\n    let visibility = null;\n    for (let i = 0; i < metadata.length; ++i) {\n        const paramMetadata = metadata[i];\n        if (paramMetadata instanceof Type) {\n            token = paramMetadata;\n        }\n        else if (paramMetadata instanceof Inject) {\n            token = paramMetadata.token;\n        }\n        else if (paramMetadata instanceof Optional) {\n            optional = true;\n        }\n        else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {\n            visibility = paramMetadata;\n        }\n        else if (paramMetadata instanceof InjectionToken) {\n            token = paramMetadata;\n        }\n    }\n    token = resolveForwardRef(token);\n    if (token != null) {\n        return _createDependency(token, optional, visibility);\n    }\n    else {\n        throw noAnnotationError(typeOrFunc, params);\n    }\n}\nfunction _createDependency(token, optional, visibility) {\n    return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Threshold for the dynamic version\nconst UNDEFINED = {};\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n *\n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n *\n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n *\n * @usageNotes\n * ### Example\n *\n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n *\n * ```typescript\n * @Injectable()\n * class Engine {\n * }\n *\n * @Injectable()\n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n *\n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n *\n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n *\n * TODO: delete in v14.\n *\n * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.\n * @publicApi\n */\nclass ReflectiveInjector {\n    /**\n     * Turns an array of provider definitions into an array of resolved providers.\n     *\n     * A resolution is a process of flattening multiple nested arrays and converting individual\n     * providers into an array of `ResolvedReflectiveProvider`s.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n     *\n     * expect(providers.length).toEqual(2);\n     *\n     * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n     * expect(providers[0].key.displayName).toBe(\"Car\");\n     * expect(providers[0].dependencies.length).toEqual(1);\n     * expect(providers[0].factory).toBeDefined();\n     *\n     * expect(providers[1].key.displayName).toBe(\"Engine\");\n     * });\n     * ```\n     *\n     */\n    static resolve(providers) {\n        return resolveReflectiveProviders(providers);\n    }\n    /**\n     * Resolves an array of providers and creates an injector from those providers.\n     *\n     * The passed-in providers can be an array of `Type`, `Provider`,\n     * or a recursive array of more providers.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n     * expect(injector.get(Car) instanceof Car).toBe(true);\n     * ```\n     */\n    static resolveAndCreate(providers, parent) {\n        const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n        return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n    }\n    /**\n     * Creates an injector from previously resolved providers.\n     *\n     * This API is the recommended way to construct injectors in performance-sensitive parts.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Injectable()\n     * class Engine {\n     * }\n     *\n     * @Injectable()\n     * class Car {\n     *   constructor(public engine:Engine) {}\n     * }\n     *\n     * var providers = ReflectiveInjector.resolve([Car, Engine]);\n     * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n     * expect(injector.get(Car) instanceof Car).toBe(true);\n     * ```\n     */\n    static fromResolvedProviders(providers, parent) {\n        return new ReflectiveInjector_(providers, parent);\n    }\n}\nclass ReflectiveInjector_ {\n    /**\n     * Private\n     */\n    constructor(_providers, _parent) {\n        /** @internal */\n        this._constructionCounter = 0;\n        this._providers = _providers;\n        this.parent = _parent || null;\n        const len = _providers.length;\n        this.keyIds = [];\n        this.objs = [];\n        for (let i = 0; i < len; i++) {\n            this.keyIds[i] = _providers[i].key.id;\n            this.objs[i] = UNDEFINED;\n        }\n    }\n    get(token, notFoundValue = THROW_IF_NOT_FOUND) {\n        return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\n    }\n    resolveAndCreateChild(providers) {\n        const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n        return this.createChildFromResolved(ResolvedReflectiveProviders);\n    }\n    createChildFromResolved(providers) {\n        const inj = new ReflectiveInjector_(providers);\n        inj.parent = this;\n        return inj;\n    }\n    resolveAndInstantiate(provider) {\n        return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n    }\n    instantiateResolved(provider) {\n        return this._instantiateProvider(provider);\n    }\n    getProviderAtIndex(index) {\n        if (index < 0 || index >= this._providers.length) {\n            throw outOfBoundsError(index);\n        }\n        return this._providers[index];\n    }\n    /** @internal */\n    _new(provider) {\n        if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\n            throw cyclicDependencyError(this, provider.key);\n        }\n        return this._instantiateProvider(provider);\n    }\n    _getMaxNumberOfObjects() {\n        return this.objs.length;\n    }\n    _instantiateProvider(provider) {\n        if (provider.multiProvider) {\n            const res = [];\n            for (let i = 0; i < provider.resolvedFactories.length; ++i) {\n                res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n            }\n            return res;\n        }\n        else {\n            return this._instantiate(provider, provider.resolvedFactories[0]);\n        }\n    }\n    _instantiate(provider, ResolvedReflectiveFactory) {\n        const factory = ResolvedReflectiveFactory.factory;\n        let deps;\n        try {\n            deps =\n                ResolvedReflectiveFactory.dependencies.map(dep => this._getByReflectiveDependency(dep));\n        }\n        catch (e) {\n            if (e.addKey) {\n                e.addKey(this, provider.key);\n            }\n            throw e;\n        }\n        let obj;\n        try {\n            obj = factory(...deps);\n        }\n        catch (e) {\n            throw instantiationError(this, e, e.stack, provider.key);\n        }\n        return obj;\n    }\n    _getByReflectiveDependency(dep) {\n        return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n    }\n    _getByKey(key, visibility, notFoundValue) {\n        if (key === ReflectiveInjector_.INJECTOR_KEY) {\n            return this;\n        }\n        if (visibility instanceof Self) {\n            return this._getByKeySelf(key, notFoundValue);\n        }\n        else {\n            return this._getByKeyDefault(key, notFoundValue, visibility);\n        }\n    }\n    _getObjByKeyId(keyId) {\n        for (let i = 0; i < this.keyIds.length; i++) {\n            if (this.keyIds[i] === keyId) {\n                if (this.objs[i] === UNDEFINED) {\n                    this.objs[i] = this._new(this._providers[i]);\n                }\n                return this.objs[i];\n            }\n        }\n        return UNDEFINED;\n    }\n    /** @internal */\n    _throwOrNull(key, notFoundValue) {\n        if (notFoundValue !== THROW_IF_NOT_FOUND) {\n            return notFoundValue;\n        }\n        else {\n            throw noProviderError(this, key);\n        }\n    }\n    /** @internal */\n    _getByKeySelf(key, notFoundValue) {\n        const obj = this._getObjByKeyId(key.id);\n        return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\n    }\n    /** @internal */\n    _getByKeyDefault(key, notFoundValue, visibility) {\n        let inj;\n        if (visibility instanceof SkipSelf) {\n            inj = this.parent;\n        }\n        else {\n            inj = this;\n        }\n        while (inj instanceof ReflectiveInjector_) {\n            const inj_ = inj;\n            const obj = inj_._getObjByKeyId(key.id);\n            if (obj !== UNDEFINED)\n                return obj;\n            inj = inj_.parent;\n        }\n        if (inj !== null) {\n            return inj.get(key.token, notFoundValue);\n        }\n        else {\n            return this._throwOrNull(key, notFoundValue);\n        }\n    }\n    get displayName() {\n        const providers = _mapProviders(this, (b) => ' \"' + b.key.displayName + '\" ')\n            .join(', ');\n        return `ReflectiveInjector(providers: [${providers}])`;\n    }\n    toString() {\n        return this.displayName;\n    }\n}\nReflectiveInjector_.INJECTOR_KEY = ( /* @__PURE__ */ReflectiveKey.get(Injector));\nfunction _mapProviders(injector, fn) {\n    const res = [];\n    for (let i = 0; i < injector._providers.length; ++i) {\n        res[i] = fn(injector.getProviderAtIndex(i));\n    }\n    return res;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction \u0275\u0275directiveInject(token, flags = InjectFlags.Default) {\n    const lView = getLView();\n    // Fall back to inject() if view hasn't been created. This situation can happen in tests\n    // if inject utilities are used before bootstrapping.\n    if (lView === null) {\n        // Verify that we will not get into infinite loop.\n        ngDevMode && assertInjectImplementationNotEqual(\u0275\u0275directiveInject);\n        return \u0275\u0275inject(token, flags);\n    }\n    const tNode = getCurrentTNode();\n    return getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);\n}\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * This instruction allows the actual error message to be optimized away when ngDevMode is turned\n * off, saving bytes of generated code while still providing a good experience in dev mode.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275invalidFactory() {\n    const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : 'invalid';\n    throw new Error(msg);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * THIS FILE CONTAINS CODE WHICH SHOULD BE TREE SHAKEN AND NEVER CALLED FROM PRODUCTION CODE!!!\n */\n/**\n * Creates an `Array` construction with a given name. This is useful when\n * looking for memory consumption to see what time of array it is.\n *\n *\n * @param name Name to give to the constructor\n * @returns A subclass of `Array` if possible. This can only be done in\n *          environments which support `class` construct.\n */\nfunction createNamedArrayType(name) {\n    // This should never be called in prod mode, so let's verify that is the case.\n    if (ngDevMode) {\n        try {\n            // If this function were compromised the following could lead to arbitrary\n            // script execution. We bless it with Trusted Types anyway since this\n            // function is stripped out of production binaries.\n            return (newTrustedFunctionForDev('Array', `return class ${name} extends Array{}`))(Array);\n        }\n        catch (e) {\n            // If it does not work just give up and fall back to regular Array.\n            return Array;\n        }\n    }\n    else {\n        throw new Error('Looks like we are in \\'prod mode\\', but we are creating a named Array type, which is wrong! Check your code');\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction toTStylingRange(prev, next) {\n    ngDevMode && assertNumberInRange(prev, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n    ngDevMode && assertNumberInRange(next, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n    return (prev << 17 /* StylingRange.PREV_SHIFT */ | next << 2 /* StylingRange.NEXT_SHIFT */);\n}\nfunction getTStylingRangePrev(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange >> 17 /* StylingRange.PREV_SHIFT */) & 32767 /* StylingRange.UNSIGNED_MASK */;\n}\nfunction getTStylingRangePrevDuplicate(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange & 2 /* StylingRange.PREV_DUPLICATE */) ==\n        2 /* StylingRange.PREV_DUPLICATE */;\n}\nfunction setTStylingRangePrev(tStylingRange, previous) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    ngDevMode && assertNumberInRange(previous, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n    return ((tStylingRange & ~4294836224 /* StylingRange.PREV_MASK */) |\n        (previous << 17 /* StylingRange.PREV_SHIFT */));\n}\nfunction setTStylingRangePrevDuplicate(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange | 2 /* StylingRange.PREV_DUPLICATE */);\n}\nfunction getTStylingRangeNext(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange & 131068 /* StylingRange.NEXT_MASK */) >> 2 /* StylingRange.NEXT_SHIFT */;\n}\nfunction setTStylingRangeNext(tStylingRange, next) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    ngDevMode && assertNumberInRange(next, 0, 32767 /* StylingRange.UNSIGNED_MASK */);\n    return ((tStylingRange & ~131068 /* StylingRange.NEXT_MASK */) | //\n        next << 2 /* StylingRange.NEXT_SHIFT */);\n}\nfunction getTStylingRangeNextDuplicate(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange & 1 /* StylingRange.NEXT_DUPLICATE */) ===\n        1 /* StylingRange.NEXT_DUPLICATE */;\n}\nfunction setTStylingRangeNextDuplicate(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    return (tStylingRange | 1 /* StylingRange.NEXT_DUPLICATE */);\n}\nfunction getTStylingRangeTail(tStylingRange) {\n    ngDevMode && assertNumber(tStylingRange, 'expected number');\n    const next = getTStylingRangeNext(tStylingRange);\n    return next === 0 ? getTStylingRangePrev(tStylingRange) : next;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Patch a `debug` property on top of the existing object.\n *\n * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n *\n * @param obj Object to patch\n * @param debug Value to patch\n */\nfunction attachDebugObject(obj, debug) {\n    if (ngDevMode) {\n        Object.defineProperty(obj, 'debug', { value: debug, enumerable: false });\n    }\n    else {\n        throw new Error('This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n    }\n}\n/**\n * Patch a `debug` property getter on top of the existing object.\n *\n * NOTE: always call this method with `ngDevMode && attachDebugObject(...)`\n *\n * @param obj Object to patch\n * @param debugGetter Getter returning a value to patch\n */\nfunction attachDebugGetter(obj, debugGetter) {\n    if (ngDevMode) {\n        Object.defineProperty(obj, 'debug', { get: debugGetter, enumerable: false });\n    }\n    else {\n        throw new Error('This method should be guarded with `ngDevMode` so that it can be tree shaken in production!');\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/*\n * This file contains conditionally attached classes which provide human readable (debug) level\n * information for `LView`, `LContainer` and other internal data structures. These data structures\n * are stored internally as array which makes it very difficult during debugging to reason about the\n * current state of the system.\n *\n * Patching the array with extra property does change the array's hidden class' but it does not\n * change the cost of access, therefore this patching should not have significant if any impact in\n * `ngDevMode` mode. (see: https://jsperf.com/array-vs-monkey-patch-array)\n *\n * So instead of seeing:\n * ```\n * Array(30) [Object, 659, null, \u2026]\n * ```\n *\n * You get to see:\n * ```\n * LViewDebug {\n *   views: [...],\n *   flags: {attached: true, ...}\n *   nodes: [\n *     {html: '<div id=\"123\">', ..., nodes: [\n *       {html: '<span>', ..., nodes: null}\n *     ]}\n *   ]\n * }\n * ```\n */\nlet LVIEW_COMPONENT_CACHE;\nlet LVIEW_EMBEDDED_CACHE;\nlet LVIEW_ROOT;\nlet LVIEW_COMPONENT;\nlet LVIEW_EMBEDDED;\n/**\n * This function clones a blueprint and creates LView.\n *\n * Simple slice will keep the same type, and we need it to be LView\n */\nfunction cloneToLViewFromTViewBlueprint(tView) {\n    const debugTView = tView;\n    const lView = getLViewToClone(debugTView.type, tView.template && tView.template.name);\n    return lView.concat(tView.blueprint);\n}\nclass LRootView extends Array {\n}\nclass LComponentView extends Array {\n}\nclass LEmbeddedView extends Array {\n}\nfunction getLViewToClone(type, name) {\n    switch (type) {\n        case 0 /* TViewType.Root */:\n            if (LVIEW_ROOT === undefined)\n                LVIEW_ROOT = new LRootView();\n            return LVIEW_ROOT;\n        case 1 /* TViewType.Component */:\n            if (!ngDevMode || !ngDevMode.namedConstructors) {\n                if (LVIEW_COMPONENT === undefined)\n                    LVIEW_COMPONENT = new LComponentView();\n                return LVIEW_COMPONENT;\n            }\n            if (LVIEW_COMPONENT_CACHE === undefined)\n                LVIEW_COMPONENT_CACHE = new Map();\n            let componentArray = LVIEW_COMPONENT_CACHE.get(name);\n            if (componentArray === undefined) {\n                componentArray = new (createNamedArrayType('LComponentView' + nameSuffix(name)))();\n                LVIEW_COMPONENT_CACHE.set(name, componentArray);\n            }\n            return componentArray;\n        case 2 /* TViewType.Embedded */:\n            if (!ngDevMode || !ngDevMode.namedConstructors) {\n                if (LVIEW_EMBEDDED === undefined)\n                    LVIEW_EMBEDDED = new LEmbeddedView();\n                return LVIEW_EMBEDDED;\n            }\n            if (LVIEW_EMBEDDED_CACHE === undefined)\n                LVIEW_EMBEDDED_CACHE = new Map();\n            let embeddedArray = LVIEW_EMBEDDED_CACHE.get(name);\n            if (embeddedArray === undefined) {\n                embeddedArray = new (createNamedArrayType('LEmbeddedView' + nameSuffix(name)))();\n                LVIEW_EMBEDDED_CACHE.set(name, embeddedArray);\n            }\n            return embeddedArray;\n    }\n}\nfunction nameSuffix(text) {\n    if (text == null)\n        return '';\n    const index = text.lastIndexOf('_Template');\n    return '_' + (index === -1 ? text : text.slice(0, index));\n}\n/**\n * This class is a debug version of Object literal so that we can have constructor name show up\n * in\n * debug tools in ngDevMode.\n */\nconst TViewConstructor = class TView {\n    constructor(type, blueprint, template, queries, viewQuery, declTNode, data, bindingStartIndex, expandoStartIndex, hostBindingOpCodes, firstCreatePass, firstUpdatePass, staticViewQueries, staticContentQueries, preOrderHooks, preOrderCheckHooks, contentHooks, contentCheckHooks, viewHooks, viewCheckHooks, destroyHooks, cleanup, contentQueries, components, directiveRegistry, pipeRegistry, firstChild, schemas, consts, incompleteFirstPass, _decls, _vars) {\n        this.type = type;\n        this.blueprint = blueprint;\n        this.template = template;\n        this.queries = queries;\n        this.viewQuery = viewQuery;\n        this.declTNode = declTNode;\n        this.data = data;\n        this.bindingStartIndex = bindingStartIndex;\n        this.expandoStartIndex = expandoStartIndex;\n        this.hostBindingOpCodes = hostBindingOpCodes;\n        this.firstCreatePass = firstCreatePass;\n        this.firstUpdatePass = firstUpdatePass;\n        this.staticViewQueries = staticViewQueries;\n        this.staticContentQueries = staticContentQueries;\n        this.preOrderHooks = preOrderHooks;\n        this.preOrderCheckHooks = preOrderCheckHooks;\n        this.contentHooks = contentHooks;\n        this.contentCheckHooks = contentCheckHooks;\n        this.viewHooks = viewHooks;\n        this.viewCheckHooks = viewCheckHooks;\n        this.destroyHooks = destroyHooks;\n        this.cleanup = cleanup;\n        this.contentQueries = contentQueries;\n        this.components = components;\n        this.directiveRegistry = directiveRegistry;\n        this.pipeRegistry = pipeRegistry;\n        this.firstChild = firstChild;\n        this.schemas = schemas;\n        this.consts = consts;\n        this.incompleteFirstPass = incompleteFirstPass;\n        this._decls = _decls;\n        this._vars = _vars;\n    }\n    get template_() {\n        const buf = [];\n        processTNodeChildren(this.firstChild, buf);\n        return buf.join('');\n    }\n    get type_() {\n        return TViewTypeAsString[this.type] || `TViewType.?${this.type}?`;\n    }\n};\nclass TNode {\n    constructor(tView_, //\n    type, //\n    index, //\n    insertBeforeIndex, //\n    injectorIndex, //\n    directiveStart, //\n    directiveEnd, //\n    directiveStylingLast, //\n    propertyBindings, //\n    flags, //\n    providerIndexes, //\n    value, //\n    attrs, //\n    mergedAttrs, //\n    localNames, //\n    initialInputs, //\n    inputs, //\n    outputs, //\n    tViews, //\n    next, //\n    projectionNext, //\n    child, //\n    parent, //\n    projection, //\n    styles, //\n    stylesWithoutHost, //\n    residualStyles, //\n    classes, //\n    classesWithoutHost, //\n    residualClasses, //\n    classBindings, //\n    styleBindings) {\n        this.tView_ = tView_;\n        this.type = type;\n        this.index = index;\n        this.insertBeforeIndex = insertBeforeIndex;\n        this.injectorIndex = injectorIndex;\n        this.directiveStart = directiveStart;\n        this.directiveEnd = directiveEnd;\n        this.directiveStylingLast = directiveStylingLast;\n        this.propertyBindings = propertyBindings;\n        this.flags = flags;\n        this.providerIndexes = providerIndexes;\n        this.value = value;\n        this.attrs = attrs;\n        this.mergedAttrs = mergedAttrs;\n        this.localNames = localNames;\n        this.initialInputs = initialInputs;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.tViews = tViews;\n        this.next = next;\n        this.projectionNext = projectionNext;\n        this.child = child;\n        this.parent = parent;\n        this.projection = projection;\n        this.styles = styles;\n        this.stylesWithoutHost = stylesWithoutHost;\n        this.residualStyles = residualStyles;\n        this.classes = classes;\n        this.classesWithoutHost = classesWithoutHost;\n        this.residualClasses = residualClasses;\n        this.classBindings = classBindings;\n        this.styleBindings = styleBindings;\n    }\n    /**\n     * Return a human debug version of the set of `NodeInjector`s which will be consulted when\n     * resolving tokens from this `TNode`.\n     *\n     * When debugging applications, it is often difficult to determine which `NodeInjector`s will be\n     * consulted. This method shows a list of `DebugNode`s representing the `TNode`s which will be\n     * consulted in order when resolving a token starting at this `TNode`.\n     *\n     * The original data is stored in `LView` and `TView` with a lot of offset indexes, and so it is\n     * difficult to reason about.\n     *\n     * @param lView The `LView` instance for this `TNode`.\n     */\n    debugNodeInjectorPath(lView) {\n        const path = [];\n        let injectorIndex = getInjectorIndex(this, lView);\n        if (injectorIndex === -1) {\n            // Looks like the current `TNode` does not have `NodeInjector` associated with it => look for\n            // parent NodeInjector.\n            const parentLocation = getParentInjectorLocation(this, lView);\n            if (parentLocation !== NO_PARENT_INJECTOR) {\n                // We found a parent, so start searching from the parent location.\n                injectorIndex = getParentInjectorIndex(parentLocation);\n                lView = getParentInjectorView(parentLocation, lView);\n            }\n            else {\n                // No parents have been found, so there are no `NodeInjector`s to consult.\n            }\n        }\n        while (injectorIndex !== -1) {\n            ngDevMode && assertNodeInjector(lView, injectorIndex);\n            const tNode = lView[TVIEW].data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */];\n            path.push(buildDebugNode(tNode, lView));\n            const parentLocation = lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */];\n            if (parentLocation === NO_PARENT_INJECTOR) {\n                injectorIndex = -1;\n            }\n            else {\n                injectorIndex = getParentInjectorIndex(parentLocation);\n                lView = getParentInjectorView(parentLocation, lView);\n            }\n        }\n        return path;\n    }\n    get type_() {\n        return toTNodeTypeAsString(this.type) || `TNodeType.?${this.type}?`;\n    }\n    get flags_() {\n        const flags = [];\n        if (this.flags & 16 /* TNodeFlags.hasClassInput */)\n            flags.push('TNodeFlags.hasClassInput');\n        if (this.flags & 8 /* TNodeFlags.hasContentQuery */)\n            flags.push('TNodeFlags.hasContentQuery');\n        if (this.flags & 32 /* TNodeFlags.hasStyleInput */)\n            flags.push('TNodeFlags.hasStyleInput');\n        if (this.flags & 128 /* TNodeFlags.hasHostBindings */)\n            flags.push('TNodeFlags.hasHostBindings');\n        if (this.flags & 2 /* TNodeFlags.isComponentHost */)\n            flags.push('TNodeFlags.isComponentHost');\n        if (this.flags & 1 /* TNodeFlags.isDirectiveHost */)\n            flags.push('TNodeFlags.isDirectiveHost');\n        if (this.flags & 64 /* TNodeFlags.isDetached */)\n            flags.push('TNodeFlags.isDetached');\n        if (this.flags & 4 /* TNodeFlags.isProjected */)\n            flags.push('TNodeFlags.isProjected');\n        return flags.join('|');\n    }\n    get template_() {\n        if (this.type & 1 /* TNodeType.Text */)\n            return this.value;\n        const buf = [];\n        const tagName = typeof this.value === 'string' && this.value || this.type_;\n        buf.push('<', tagName);\n        if (this.flags) {\n            buf.push(' ', this.flags_);\n        }\n        if (this.attrs) {\n            for (let i = 0; i < this.attrs.length;) {\n                const attrName = this.attrs[i++];\n                if (typeof attrName == 'number') {\n                    break;\n                }\n                const attrValue = this.attrs[i++];\n                buf.push(' ', attrName, '=\"', attrValue, '\"');\n            }\n        }\n        buf.push('>');\n        processTNodeChildren(this.child, buf);\n        buf.push('</', tagName, '>');\n        return buf.join('');\n    }\n    get styleBindings_() {\n        return toDebugStyleBinding(this, false);\n    }\n    get classBindings_() {\n        return toDebugStyleBinding(this, true);\n    }\n    get providerIndexStart_() {\n        return this.providerIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n    }\n    get providerIndexEnd_() {\n        return this.providerIndexStart_ +\n            (this.providerIndexes >>> 20 /* TNodeProviderIndexes.CptViewProvidersCountShift */);\n    }\n}\nconst TNodeDebug = TNode;\nfunction toDebugStyleBinding(tNode, isClassBased) {\n    const tData = tNode.tView_.data;\n    const bindings = [];\n    const range = isClassBased ? tNode.classBindings : tNode.styleBindings;\n    const prev = getTStylingRangePrev(range);\n    const next = getTStylingRangeNext(range);\n    let isTemplate = next !== 0;\n    let cursor = isTemplate ? next : prev;\n    while (cursor !== 0) {\n        const itemKey = tData[cursor];\n        const itemRange = tData[cursor + 1];\n        bindings.unshift({\n            key: itemKey,\n            index: cursor,\n            isTemplate: isTemplate,\n            prevDuplicate: getTStylingRangePrevDuplicate(itemRange),\n            nextDuplicate: getTStylingRangeNextDuplicate(itemRange),\n            nextIndex: getTStylingRangeNext(itemRange),\n            prevIndex: getTStylingRangePrev(itemRange),\n        });\n        if (cursor === prev)\n            isTemplate = false;\n        cursor = getTStylingRangePrev(itemRange);\n    }\n    bindings.push((isClassBased ? tNode.residualClasses : tNode.residualStyles) || null);\n    return bindings;\n}\nfunction processTNodeChildren(tNode, buf) {\n    while (tNode) {\n        buf.push(tNode.template_);\n        tNode = tNode.next;\n    }\n}\nclass TViewData extends Array {\n}\nlet TVIEWDATA_EMPTY; // can't initialize here or it will not be tree shaken, because\n// `LView` constructor could have side-effects.\n/**\n * This function clones a blueprint and creates TData.\n *\n * Simple slice will keep the same type, and we need it to be TData\n */\nfunction cloneToTViewData(list) {\n    if (TVIEWDATA_EMPTY === undefined)\n        TVIEWDATA_EMPTY = new TViewData();\n    return TVIEWDATA_EMPTY.concat(list);\n}\nclass LViewBlueprint extends Array {\n}\nclass MatchesArray extends Array {\n}\nclass TViewComponents extends Array {\n}\nclass TNodeLocalNames extends Array {\n}\nclass TNodeInitialInputs extends Array {\n}\nclass LCleanup extends Array {\n}\nclass TCleanup extends Array {\n}\nfunction attachLViewDebug(lView) {\n    attachDebugObject(lView, new LViewDebug(lView));\n}\nfunction attachLContainerDebug(lContainer) {\n    attachDebugObject(lContainer, new LContainerDebug(lContainer));\n}\nfunction toDebug(obj) {\n    if (obj) {\n        const debug = obj.debug;\n        assertDefined(debug, 'Object does not have a debug representation.');\n        return debug;\n    }\n    else {\n        return obj;\n    }\n}\n/**\n * Use this method to unwrap a native element in `LView` and convert it into HTML for easier\n * reading.\n *\n * @param value possibly wrapped native DOM node.\n * @param includeChildren If `true` then the serialized HTML form will include child elements\n * (same\n * as `outerHTML`). If `false` then the serialized HTML form will only contain the element\n * itself\n * (will not serialize child elements).\n */\nfunction toHtml(value, includeChildren = false) {\n    const node = unwrapRNode(value);\n    if (node) {\n        switch (node.nodeType) {\n            case Node.TEXT_NODE:\n                return node.textContent;\n            case Node.COMMENT_NODE:\n                return `<!--${node.textContent}-->`;\n            case Node.ELEMENT_NODE:\n                const outerHTML = node.outerHTML;\n                if (includeChildren) {\n                    return outerHTML;\n                }\n                else {\n                    const innerHTML = '>' + node.innerHTML + '<';\n                    return (outerHTML.split(innerHTML)[0]) + '>';\n                }\n        }\n    }\n    return null;\n}\nclass LViewDebug {\n    constructor(_raw_lView) {\n        this._raw_lView = _raw_lView;\n    }\n    /**\n     * Flags associated with the `LView` unpacked into a more readable state.\n     */\n    get flags() {\n        const flags = this._raw_lView[FLAGS];\n        return {\n            __raw__flags__: flags,\n            initPhaseState: flags & 3 /* LViewFlags.InitPhaseStateMask */,\n            creationMode: !!(flags & 4 /* LViewFlags.CreationMode */),\n            firstViewPass: !!(flags & 8 /* LViewFlags.FirstLViewPass */),\n            checkAlways: !!(flags & 16 /* LViewFlags.CheckAlways */),\n            dirty: !!(flags & 32 /* LViewFlags.Dirty */),\n            attached: !!(flags & 64 /* LViewFlags.Attached */),\n            destroyed: !!(flags & 128 /* LViewFlags.Destroyed */),\n            isRoot: !!(flags & 256 /* LViewFlags.IsRoot */),\n            indexWithinInitPhase: flags >> 11 /* LViewFlags.IndexWithinInitPhaseShift */,\n        };\n    }\n    get parent() {\n        return toDebug(this._raw_lView[PARENT]);\n    }\n    get hostHTML() {\n        return toHtml(this._raw_lView[HOST], true);\n    }\n    get html() {\n        return (this.nodes || []).map(mapToHTML).join('');\n    }\n    get context() {\n        return this._raw_lView[CONTEXT];\n    }\n    /**\n     * The tree of nodes associated with the current `LView`. The nodes have been normalized into\n     * a tree structure with relevant details pulled out for readability.\n     */\n    get nodes() {\n        const lView = this._raw_lView;\n        const tNode = lView[TVIEW].firstChild;\n        return toDebugNodes(tNode, lView);\n    }\n    get template() {\n        return this.tView.template_;\n    }\n    get tView() {\n        return this._raw_lView[TVIEW];\n    }\n    get cleanup() {\n        return this._raw_lView[CLEANUP];\n    }\n    get injector() {\n        return this._raw_lView[INJECTOR$1];\n    }\n    get rendererFactory() {\n        return this._raw_lView[RENDERER_FACTORY];\n    }\n    get renderer() {\n        return this._raw_lView[RENDERER];\n    }\n    get sanitizer() {\n        return this._raw_lView[SANITIZER];\n    }\n    get childHead() {\n        return toDebug(this._raw_lView[CHILD_HEAD]);\n    }\n    get next() {\n        return toDebug(this._raw_lView[NEXT]);\n    }\n    get childTail() {\n        return toDebug(this._raw_lView[CHILD_TAIL]);\n    }\n    get declarationView() {\n        return toDebug(this._raw_lView[DECLARATION_VIEW]);\n    }\n    get queries() {\n        return this._raw_lView[QUERIES];\n    }\n    get tHost() {\n        return this._raw_lView[T_HOST];\n    }\n    get id() {\n        return this._raw_lView[ID];\n    }\n    get decls() {\n        return toLViewRange(this.tView, this._raw_lView, HEADER_OFFSET, this.tView.bindingStartIndex);\n    }\n    get vars() {\n        return toLViewRange(this.tView, this._raw_lView, this.tView.bindingStartIndex, this.tView.expandoStartIndex);\n    }\n    get expando() {\n        return toLViewRange(this.tView, this._raw_lView, this.tView.expandoStartIndex, this._raw_lView.length);\n    }\n    /**\n     * Normalized view of child views (and containers) attached at this location.\n     */\n    get childViews() {\n        const childViews = [];\n        let child = this.childHead;\n        while (child) {\n            childViews.push(child);\n            child = child.next;\n        }\n        return childViews;\n    }\n}\nfunction mapToHTML(node) {\n    if (node.type === 'ElementContainer') {\n        return (node.children || []).map(mapToHTML).join('');\n    }\n    else if (node.type === 'IcuContainer') {\n        throw new Error('Not implemented');\n    }\n    else {\n        return toHtml(node.native, true) || '';\n    }\n}\nfunction toLViewRange(tView, lView, start, end) {\n    let content = [];\n    for (let index = start; index < end; index++) {\n        content.push({ index: index, t: tView.data[index], l: lView[index] });\n    }\n    return { start: start, end: end, length: end - start, content: content };\n}\n/**\n * Turns a flat list of nodes into a tree by walking the associated `TNode` tree.\n *\n * @param tNode\n * @param lView\n */\nfunction toDebugNodes(tNode, lView) {\n    if (tNode) {\n        const debugNodes = [];\n        let tNodeCursor = tNode;\n        while (tNodeCursor) {\n            debugNodes.push(buildDebugNode(tNodeCursor, lView));\n            tNodeCursor = tNodeCursor.next;\n        }\n        return debugNodes;\n    }\n    else {\n        return [];\n    }\n}\nfunction buildDebugNode(tNode, lView) {\n    const rawValue = lView[tNode.index];\n    const native = unwrapRNode(rawValue);\n    const factories = [];\n    const instances = [];\n    const tView = lView[TVIEW];\n    for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {\n        const def = tView.data[i];\n        factories.push(def.type);\n        instances.push(lView[i]);\n    }\n    return {\n        html: toHtml(native),\n        type: toTNodeTypeAsString(tNode.type),\n        tNode,\n        native: native,\n        children: toDebugNodes(tNode.child, lView),\n        factories,\n        instances,\n        injector: buildNodeInjectorDebug(tNode, tView, lView),\n        get injectorResolutionPath() {\n            return tNode.debugNodeInjectorPath(lView);\n        },\n    };\n}\nfunction buildNodeInjectorDebug(tNode, tView, lView) {\n    const viewProviders = [];\n    for (let i = tNode.providerIndexStart_; i < tNode.providerIndexEnd_; i++) {\n        viewProviders.push(tView.data[i]);\n    }\n    const providers = [];\n    for (let i = tNode.providerIndexEnd_; i < tNode.directiveEnd; i++) {\n        providers.push(tView.data[i]);\n    }\n    const nodeInjectorDebug = {\n        bloom: toBloom(lView, tNode.injectorIndex),\n        cumulativeBloom: toBloom(tView.data, tNode.injectorIndex),\n        providers,\n        viewProviders,\n        parentInjectorIndex: lView[tNode.providerIndexStart_ - 1],\n    };\n    return nodeInjectorDebug;\n}\n/**\n * Convert a number at `idx` location in `array` into binary representation.\n *\n * @param array\n * @param idx\n */\nfunction binary(array, idx) {\n    const value = array[idx];\n    // If not a number we print 8 `?` to retain alignment but let user know that it was called on\n    // wrong type.\n    if (typeof value !== 'number')\n        return '????????';\n    // We prefix 0s so that we have constant length number\n    const text = '00000000' + value.toString(2);\n    return text.substring(text.length - 8);\n}\n/**\n * Convert a bloom filter at location `idx` in `array` into binary representation.\n *\n * @param array\n * @param idx\n */\nfunction toBloom(array, idx) {\n    if (idx < 0) {\n        return 'NO_NODE_INJECTOR';\n    }\n    return `${binary(array, idx + 7)}_${binary(array, idx + 6)}_${binary(array, idx + 5)}_${binary(array, idx + 4)}_${binary(array, idx + 3)}_${binary(array, idx + 2)}_${binary(array, idx + 1)}_${binary(array, idx + 0)}`;\n}\nclass LContainerDebug {\n    constructor(_raw_lContainer) {\n        this._raw_lContainer = _raw_lContainer;\n    }\n    get hasTransplantedViews() {\n        return this._raw_lContainer[HAS_TRANSPLANTED_VIEWS];\n    }\n    get views() {\n        return this._raw_lContainer.slice(CONTAINER_HEADER_OFFSET)\n            .map(toDebug);\n    }\n    get parent() {\n        return toDebug(this._raw_lContainer[PARENT]);\n    }\n    get movedViews() {\n        return this._raw_lContainer[MOVED_VIEWS];\n    }\n    get host() {\n        return this._raw_lContainer[HOST];\n    }\n    get native() {\n        return this._raw_lContainer[NATIVE];\n    }\n    get next() {\n        return toDebug(this._raw_lContainer[NEXT]);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Invoke `HostBindingsFunction`s for view.\n *\n * This methods executes `TView.hostBindingOpCodes`. It is used to execute the\n * `HostBindingsFunction`s associated with the current `LView`.\n *\n * @param tView Current `TView`.\n * @param lView Current `LView`.\n */\nfunction processHostBindingOpCodes(tView, lView) {\n    const hostBindingOpCodes = tView.hostBindingOpCodes;\n    if (hostBindingOpCodes === null)\n        return;\n    try {\n        for (let i = 0; i < hostBindingOpCodes.length; i++) {\n            const opCode = hostBindingOpCodes[i];\n            if (opCode < 0) {\n                // Negative numbers are element indexes.\n                setSelectedIndex(~opCode);\n            }\n            else {\n                // Positive numbers are NumberTuple which store bindingRootIndex and directiveIndex.\n                const directiveIdx = opCode;\n                const bindingRootIndx = hostBindingOpCodes[++i];\n                const hostBindingFn = hostBindingOpCodes[++i];\n                setBindingRootForHostBindings(bindingRootIndx, directiveIdx);\n                const context = lView[directiveIdx];\n                hostBindingFn(2 /* RenderFlags.Update */, context);\n            }\n        }\n    }\n    finally {\n        setSelectedIndex(-1);\n    }\n}\n/** Refreshes all content queries declared by directives in a given view */\nfunction refreshContentQueries(tView, lView) {\n    const contentQueries = tView.contentQueries;\n    if (contentQueries !== null) {\n        for (let i = 0; i < contentQueries.length; i += 2) {\n            const queryStartIdx = contentQueries[i];\n            const directiveDefIdx = contentQueries[i + 1];\n            if (directiveDefIdx !== -1) {\n                const directiveDef = tView.data[directiveDefIdx];\n                ngDevMode && assertDefined(directiveDef, 'DirectiveDef not found.');\n                ngDevMode &&\n                    assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');\n                setCurrentQueryIndex(queryStartIdx);\n                directiveDef.contentQueries(2 /* RenderFlags.Update */, lView[directiveDefIdx], directiveDefIdx);\n            }\n        }\n    }\n}\n/** Refreshes child components in the current view (update mode). */\nfunction refreshChildComponents(hostLView, components) {\n    for (let i = 0; i < components.length; i++) {\n        refreshComponent(hostLView, components[i]);\n    }\n}\n/** Renders child components in the current view (creation mode). */\nfunction renderChildComponents(hostLView, components) {\n    for (let i = 0; i < components.length; i++) {\n        renderComponent(hostLView, components[i]);\n    }\n}\nfunction createLView(parentLView, tView, context, flags, host, tHostNode, rendererFactory, renderer, sanitizer, injector, embeddedViewInjector) {\n    const lView = ngDevMode ? cloneToLViewFromTViewBlueprint(tView) : tView.blueprint.slice();\n    lView[HOST] = host;\n    lView[FLAGS] = flags | 4 /* LViewFlags.CreationMode */ | 64 /* LViewFlags.Attached */ | 8 /* LViewFlags.FirstLViewPass */;\n    if (embeddedViewInjector !== null ||\n        (parentLView && (parentLView[FLAGS] & 1024 /* LViewFlags.HasEmbeddedViewInjector */))) {\n        lView[FLAGS] |= 1024 /* LViewFlags.HasEmbeddedViewInjector */;\n    }\n    resetPreOrderHookFlags(lView);\n    ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);\n    lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;\n    lView[CONTEXT] = context;\n    lView[RENDERER_FACTORY] = (rendererFactory || parentLView && parentLView[RENDERER_FACTORY]);\n    ngDevMode && assertDefined(lView[RENDERER_FACTORY], 'RendererFactory is required');\n    lView[RENDERER] = (renderer || parentLView && parentLView[RENDERER]);\n    ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');\n    lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null;\n    lView[INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null;\n    lView[T_HOST] = tHostNode;\n    lView[ID] = getUniqueLViewId();\n    lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;\n    ngDevMode &&\n        assertEqual(tView.type == 2 /* TViewType.Embedded */ ? parentLView !== null : true, true, 'Embedded views must have parentLView');\n    lView[DECLARATION_COMPONENT_VIEW] =\n        tView.type == 2 /* TViewType.Embedded */ ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;\n    ngDevMode && attachLViewDebug(lView);\n    return lView;\n}\nfunction getOrCreateTNode(tView, index, type, name, attrs) {\n    ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in\n        // `view_engine_compatibility` for additional context.\n        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n    // Keep this function short, so that the VM will inline it.\n    ngDevMode && assertPureTNodeType(type);\n    let tNode = tView.data[index];\n    if (tNode === null) {\n        tNode = createTNodeAtIndex(tView, index, type, name, attrs);\n        if (isInI18nBlock()) {\n            // If we are in i18n block then all elements should be pre declared through `Placeholder`\n            // See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n            // If the `TNode` was not pre-declared than it means it was not mentioned which means it was\n            // removed, so we mark it as detached.\n            tNode.flags |= 64 /* TNodeFlags.isDetached */;\n        }\n    }\n    else if (tNode.type & 64 /* TNodeType.Placeholder */) {\n        tNode.type = type;\n        tNode.value = name;\n        tNode.attrs = attrs;\n        const parent = getCurrentParentTNode();\n        tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;\n        ngDevMode && assertTNodeForTView(tNode, tView);\n        ngDevMode && assertEqual(index, tNode.index, 'Expecting same index');\n    }\n    setCurrentTNode(tNode, true);\n    return tNode;\n}\nfunction createTNodeAtIndex(tView, index, type, name, attrs) {\n    const currentTNode = getCurrentTNodePlaceholderOk();\n    const isParent = isCurrentTNodeParent();\n    const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;\n    // Parents cannot cross component boundaries because components will be used in multiple places.\n    const tNode = tView.data[index] =\n        createTNode(tView, parent, type, index, name, attrs);\n    // Assign a pointer to the first child node of a given view. The first node is not always the one\n    // at index 0, in case of i18n, index 0 can be the instruction `i18nStart` and the first node has\n    // the index 1 or more, so we can't just check node index.\n    if (tView.firstChild === null) {\n        tView.firstChild = tNode;\n    }\n    if (currentTNode !== null) {\n        if (isParent) {\n            // FIXME(misko): This logic looks unnecessarily complicated. Could we simplify?\n            if (currentTNode.child == null && tNode.parent !== null) {\n                // We are in the same view, which means we are adding content node to the parent view.\n                currentTNode.child = tNode;\n            }\n        }\n        else {\n            if (currentTNode.next === null) {\n                // In the case of i18n the `currentTNode` may already be linked, in which case we don't want\n                // to break the links which i18n created.\n                currentTNode.next = tNode;\n            }\n        }\n    }\n    return tNode;\n}\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply()), we need to adjust the blueprint for future\n * template passes.\n *\n * @param tView `TView` associated with `LView`\n * @param lView The `LView` containing the blueprint to adjust\n * @param numSlotsToAlloc The number of slots to alloc in the LView, should be >0\n * @param initialValue Initial value to store in blueprint\n */\nfunction allocExpando(tView, lView, numSlotsToAlloc, initialValue) {\n    if (numSlotsToAlloc === 0)\n        return -1;\n    if (ngDevMode) {\n        assertFirstCreatePass(tView);\n        assertSame(tView, lView[TVIEW], '`LView` must be associated with `TView`!');\n        assertEqual(tView.data.length, lView.length, 'Expecting LView to be same size as TView');\n        assertEqual(tView.data.length, tView.blueprint.length, 'Expecting Blueprint to be same size as TView');\n        assertFirstUpdatePass(tView);\n    }\n    const allocIdx = lView.length;\n    for (let i = 0; i < numSlotsToAlloc; i++) {\n        lView.push(initialValue);\n        tView.blueprint.push(initialValue);\n        tView.data.push(null);\n    }\n    return allocIdx;\n}\n//////////////////////////\n//// Render\n//////////////////////////\n/**\n * Processes a view in the creation mode. This includes a number of steps in a specific order:\n * - creating view query functions (if any);\n * - executing a template function in the creation mode;\n * - updating static queries (if any);\n * - creating child components defined in a given view.\n */\nfunction renderView(tView, lView, context) {\n    ngDevMode && assertEqual(isCreationMode(lView), true, 'Should be run in creation mode');\n    enterView(lView);\n    try {\n        const viewQuery = tView.viewQuery;\n        if (viewQuery !== null) {\n            executeViewQueryFn(1 /* RenderFlags.Create */, viewQuery, context);\n        }\n        // Execute a template associated with this view, if it exists. A template function might not be\n        // defined for the root component views.\n        const templateFn = tView.template;\n        if (templateFn !== null) {\n            executeTemplate(tView, lView, templateFn, 1 /* RenderFlags.Create */, context);\n        }\n        // This needs to be set before children are processed to support recursive components.\n        // This must be set to false immediately after the first creation run because in an\n        // ngFor loop, all the views will be created together before update mode runs and turns\n        // off firstCreatePass. If we don't set it here, instances will perform directive\n        // matching, etc again and again.\n        if (tView.firstCreatePass) {\n            tView.firstCreatePass = false;\n        }\n        // We resolve content queries specifically marked as `static` in creation mode. Dynamic\n        // content queries are resolved during change detection (i.e. update mode), after embedded\n        // views are refreshed (see block above).\n        if (tView.staticContentQueries) {\n            refreshContentQueries(tView, lView);\n        }\n        // We must materialize query results before child components are processed\n        // in case a child component has projected a container. The LContainer needs\n        // to exist so the embedded views are properly attached by the container.\n        if (tView.staticViewQueries) {\n            executeViewQueryFn(2 /* RenderFlags.Update */, tView.viewQuery, context);\n        }\n        // Render child component views.\n        const components = tView.components;\n        if (components !== null) {\n            renderChildComponents(lView, components);\n        }\n    }\n    catch (error) {\n        // If we didn't manage to get past the first template pass due to\n        // an error, mark the view as corrupted so we can try to recover.\n        if (tView.firstCreatePass) {\n            tView.incompleteFirstPass = true;\n            tView.firstCreatePass = false;\n        }\n        throw error;\n    }\n    finally {\n        lView[FLAGS] &= ~4 /* LViewFlags.CreationMode */;\n        leaveView();\n    }\n}\n/**\n * Processes a view in update mode. This includes a number of steps in a specific order:\n * - executing a template function in update mode;\n * - executing hooks;\n * - refreshing queries;\n * - setting host bindings;\n * - refreshing child (embedded and component) views.\n */\nfunction refreshView(tView, lView, templateFn, context) {\n    ngDevMode && assertEqual(isCreationMode(lView), false, 'Should be run in update mode');\n    const flags = lView[FLAGS];\n    if ((flags & 128 /* LViewFlags.Destroyed */) === 128 /* LViewFlags.Destroyed */)\n        return;\n    enterView(lView);\n    // Check no changes mode is a dev only mode used to verify that bindings have not changed\n    // since they were assigned. We do not want to execute lifecycle hooks in that mode.\n    const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();\n    try {\n        resetPreOrderHookFlags(lView);\n        setBindingIndex(tView.bindingStartIndex);\n        if (templateFn !== null) {\n            executeTemplate(tView, lView, templateFn, 2 /* RenderFlags.Update */, context);\n        }\n        const hooksInitPhaseCompleted = (flags & 3 /* LViewFlags.InitPhaseStateMask */) === 3 /* InitPhaseState.InitPhaseCompleted */;\n        // execute pre-order hooks (OnInit, OnChanges, DoCheck)\n        // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n        if (!isInCheckNoChangesPass) {\n            if (hooksInitPhaseCompleted) {\n                const preOrderCheckHooks = tView.preOrderCheckHooks;\n                if (preOrderCheckHooks !== null) {\n                    executeCheckHooks(lView, preOrderCheckHooks, null);\n                }\n            }\n            else {\n                const preOrderHooks = tView.preOrderHooks;\n                if (preOrderHooks !== null) {\n                    executeInitAndCheckHooks(lView, preOrderHooks, 0 /* InitPhaseState.OnInitHooksToBeRun */, null);\n                }\n                incrementInitPhaseFlags(lView, 0 /* InitPhaseState.OnInitHooksToBeRun */);\n            }\n        }\n        // First mark transplanted views that are declared in this lView as needing a refresh at their\n        // insertion points. This is needed to avoid the situation where the template is defined in this\n        // `LView` but its declaration appears after the insertion component.\n        markTransplantedViewsForRefresh(lView);\n        refreshEmbeddedViews(lView);\n        // Content query results must be refreshed before content hooks are called.\n        if (tView.contentQueries !== null) {\n            refreshContentQueries(tView, lView);\n        }\n        // execute content hooks (AfterContentInit, AfterContentChecked)\n        // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n        if (!isInCheckNoChangesPass) {\n            if (hooksInitPhaseCompleted) {\n                const contentCheckHooks = tView.contentCheckHooks;\n                if (contentCheckHooks !== null) {\n                    executeCheckHooks(lView, contentCheckHooks);\n                }\n            }\n            else {\n                const contentHooks = tView.contentHooks;\n                if (contentHooks !== null) {\n                    executeInitAndCheckHooks(lView, contentHooks, 1 /* InitPhaseState.AfterContentInitHooksToBeRun */);\n                }\n                incrementInitPhaseFlags(lView, 1 /* InitPhaseState.AfterContentInitHooksToBeRun */);\n            }\n        }\n        processHostBindingOpCodes(tView, lView);\n        // Refresh child component views.\n        const components = tView.components;\n        if (components !== null) {\n            refreshChildComponents(lView, components);\n        }\n        // View queries must execute after refreshing child components because a template in this view\n        // could be inserted in a child component. If the view query executes before child component\n        // refresh, the template might not yet be inserted.\n        const viewQuery = tView.viewQuery;\n        if (viewQuery !== null) {\n            executeViewQueryFn(2 /* RenderFlags.Update */, viewQuery, context);\n        }\n        // execute view hooks (AfterViewInit, AfterViewChecked)\n        // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n        if (!isInCheckNoChangesPass) {\n            if (hooksInitPhaseCompleted) {\n                const viewCheckHooks = tView.viewCheckHooks;\n                if (viewCheckHooks !== null) {\n                    executeCheckHooks(lView, viewCheckHooks);\n                }\n            }\n            else {\n                const viewHooks = tView.viewHooks;\n                if (viewHooks !== null) {\n                    executeInitAndCheckHooks(lView, viewHooks, 2 /* InitPhaseState.AfterViewInitHooksToBeRun */);\n                }\n                incrementInitPhaseFlags(lView, 2 /* InitPhaseState.AfterViewInitHooksToBeRun */);\n            }\n        }\n        if (tView.firstUpdatePass === true) {\n            // We need to make sure that we only flip the flag on successful `refreshView` only\n            // Don't do this in `finally` block.\n            // If we did this in `finally` block then an exception could block the execution of styling\n            // instructions which in turn would be unable to insert themselves into the styling linked\n            // list. The result of this would be that if the exception would not be throw on subsequent CD\n            // the styling would be unable to process it data and reflect to the DOM.\n            tView.firstUpdatePass = false;\n        }\n        // Do not reset the dirty state when running in check no changes mode. We don't want components\n        // to behave differently depending on whether check no changes is enabled or not. For example:\n        // Marking an OnPush component as dirty from within the `ngAfterViewInit` hook in order to\n        // refresh a `NgClass` binding should work. If we would reset the dirty state in the check\n        // no changes cycle, the component would be not be dirty for the next update pass. This would\n        // be different in production mode where the component dirty state is not reset.\n        if (!isInCheckNoChangesPass) {\n            lView[FLAGS] &= ~(32 /* LViewFlags.Dirty */ | 8 /* LViewFlags.FirstLViewPass */);\n        }\n        if (lView[FLAGS] & 512 /* LViewFlags.RefreshTransplantedView */) {\n            lView[FLAGS] &= ~512 /* LViewFlags.RefreshTransplantedView */;\n            updateTransplantedViewCount(lView[PARENT], -1);\n        }\n    }\n    finally {\n        leaveView();\n    }\n}\nfunction executeTemplate(tView, lView, templateFn, rf, context) {\n    const prevSelectedIndex = getSelectedIndex();\n    const isUpdatePhase = rf & 2 /* RenderFlags.Update */;\n    try {\n        setSelectedIndex(-1);\n        if (isUpdatePhase && lView.length > HEADER_OFFSET) {\n            // When we're updating, inherently select 0 so we don't\n            // have to generate that instruction for most update blocks.\n            selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());\n        }\n        const preHookType = isUpdatePhase ? 2 /* ProfilerEvent.TemplateUpdateStart */ : 0 /* ProfilerEvent.TemplateCreateStart */;\n        profiler(preHookType, context);\n        templateFn(rf, context);\n    }\n    finally {\n        setSelectedIndex(prevSelectedIndex);\n        const postHookType = isUpdatePhase ? 3 /* ProfilerEvent.TemplateUpdateEnd */ : 1 /* ProfilerEvent.TemplateCreateEnd */;\n        profiler(postHookType, context);\n    }\n}\n//////////////////////////\n//// Element\n//////////////////////////\nfunction executeContentQueries(tView, tNode, lView) {\n    if (isContentQueryHost(tNode)) {\n        const start = tNode.directiveStart;\n        const end = tNode.directiveEnd;\n        for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n            const def = tView.data[directiveIndex];\n            if (def.contentQueries) {\n                def.contentQueries(1 /* RenderFlags.Create */, lView[directiveIndex], directiveIndex);\n            }\n        }\n    }\n}\n/**\n * Creates directive instances.\n */\nfunction createDirectivesInstances(tView, lView, tNode) {\n    if (!getBindingsEnabled())\n        return;\n    instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));\n    if ((tNode.flags & 128 /* TNodeFlags.hasHostBindings */) === 128 /* TNodeFlags.hasHostBindings */) {\n        invokeDirectivesHostBindings(tView, lView, tNode);\n    }\n}\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LView in the same order as they are loaded in the template with load().\n */\nfunction saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {\n    const localNames = tNode.localNames;\n    if (localNames !== null) {\n        let localIndex = tNode.index + 1;\n        for (let i = 0; i < localNames.length; i += 2) {\n            const index = localNames[i + 1];\n            const value = index === -1 ?\n                localRefExtractor(tNode, viewData) :\n                viewData[index];\n            viewData[localIndex++] = value;\n        }\n    }\n}\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param def ComponentDef\n * @returns TView\n */\nfunction getOrCreateComponentTView(def) {\n    const tView = def.tView;\n    // Create a TView if there isn't one, or recreate it if the first create pass didn't\n    // complete successfully since we can't know for sure whether it's in a usable shape.\n    if (tView === null || tView.incompleteFirstPass) {\n        // Declaration node here is null since this function is called when we dynamically create a\n        // component and hence there is no declaration.\n        const declTNode = null;\n        return def.tView = createTView(1 /* TViewType.Component */, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts);\n    }\n    return tView;\n}\n/**\n * Creates a TView instance\n *\n * @param type Type of `TView`.\n * @param declTNode Declaration location of this `TView`.\n * @param templateFn Template function\n * @param decls The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n * @param viewQuery View queries for this view\n * @param schemas Schemas for this view\n * @param consts Constants for this view\n */\nfunction createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory) {\n    ngDevMode && ngDevMode.tView++;\n    const bindingStartIndex = HEADER_OFFSET + decls;\n    // This length does not yet contain host bindings from child directives because at this point,\n    // we don't know which directives are active on this template. As soon as a directive is matched\n    // that has a host binding, we will update the blueprint with that def's hostVars count.\n    const initialViewLength = bindingStartIndex + vars;\n    const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n    const consts = typeof constsOrFactory === 'function' ? constsOrFactory() : constsOrFactory;\n    const tView = blueprint[TVIEW] = ngDevMode ?\n        new TViewConstructor(type, // type: TViewType,\n        blueprint, // blueprint: LView,\n        templateFn, // template: ComponentTemplate<{}>|null,\n        null, // queries: TQueries|null\n        viewQuery, // viewQuery: ViewQueriesFunction<{}>|null,\n        declTNode, // declTNode: TNode|null,\n        cloneToTViewData(blueprint).fill(null, bindingStartIndex), // data: TData,\n        bindingStartIndex, // bindingStartIndex: number,\n        initialViewLength, // expandoStartIndex: number,\n        null, // hostBindingOpCodes: HostBindingOpCodes,\n        true, // firstCreatePass: boolean,\n        true, // firstUpdatePass: boolean,\n        false, // staticViewQueries: boolean,\n        false, // staticContentQueries: boolean,\n        null, // preOrderHooks: HookData|null,\n        null, // preOrderCheckHooks: HookData|null,\n        null, // contentHooks: HookData|null,\n        null, // contentCheckHooks: HookData|null,\n        null, // viewHooks: HookData|null,\n        null, // viewCheckHooks: HookData|null,\n        null, // destroyHooks: DestroyHookData|null,\n        null, // cleanup: any[]|null,\n        null, // contentQueries: number[]|null,\n        null, // components: number[]|null,\n        typeof directives === 'function' ? //\n            directives() : //\n            directives, // directiveRegistry: DirectiveDefList|null,\n        typeof pipes === 'function' ? pipes() : pipes, // pipeRegistry: PipeDefList|null,\n        null, // firstChild: TNode|null,\n        schemas, // schemas: SchemaMetadata[]|null,\n        consts, // consts: TConstants|null\n        false, // incompleteFirstPass: boolean\n        decls, // ngDevMode only: decls\n        vars) :\n        {\n            type: type,\n            blueprint: blueprint,\n            template: templateFn,\n            queries: null,\n            viewQuery: viewQuery,\n            declTNode: declTNode,\n            data: blueprint.slice().fill(null, bindingStartIndex),\n            bindingStartIndex: bindingStartIndex,\n            expandoStartIndex: initialViewLength,\n            hostBindingOpCodes: null,\n            firstCreatePass: true,\n            firstUpdatePass: true,\n            staticViewQueries: false,\n            staticContentQueries: false,\n            preOrderHooks: null,\n            preOrderCheckHooks: null,\n            contentHooks: null,\n            contentCheckHooks: null,\n            viewHooks: null,\n            viewCheckHooks: null,\n            destroyHooks: null,\n            cleanup: null,\n            contentQueries: null,\n            components: null,\n            directiveRegistry: typeof directives === 'function' ? directives() : directives,\n            pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n            firstChild: null,\n            schemas: schemas,\n            consts: consts,\n            incompleteFirstPass: false\n        };\n    if (ngDevMode) {\n        // For performance reasons it is important that the tView retains the same shape during runtime.\n        // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n        // prevent class transitions.\n        Object.seal(tView);\n    }\n    return tView;\n}\nfunction createViewBlueprint(bindingStartIndex, initialViewLength) {\n    const blueprint = ngDevMode ? new LViewBlueprint() : [];\n    for (let i = 0; i < initialViewLength; i++) {\n        blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);\n    }\n    return blueprint;\n}\nfunction createError(text, token) {\n    return new Error(`Renderer: ${text} [${stringifyForError(token)}]`);\n}\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param rendererFactory Factory function to create renderer instance.\n * @param elementOrSelector Render element or CSS selector to locate the element.\n * @param encapsulation View Encapsulation defined for component that requests host element.\n */\nfunction locateHostElement(renderer, elementOrSelector, encapsulation) {\n    // When using native Shadow DOM, do not clear host element to allow native slot projection\n    const preserveContent = encapsulation === ViewEncapsulation.ShadowDom;\n    return renderer.selectRootElement(elementOrSelector, preserveContent);\n}\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n *\n * This function can also be used to store instance specific cleanup fns. In that case the `context`\n * is `null` and the function is store in `LView` (rather than it `TView`).\n */\nfunction storeCleanupWithContext(tView, lView, context, cleanupFn) {\n    const lCleanup = getOrCreateLViewCleanup(lView);\n    if (context === null) {\n        // If context is null that this is instance specific callback. These callbacks can only be\n        // inserted after template shared instances. For this reason in ngDevMode we freeze the TView.\n        if (ngDevMode) {\n            Object.freeze(getOrCreateTViewCleanup(tView));\n        }\n        lCleanup.push(cleanupFn);\n    }\n    else {\n        lCleanup.push(context);\n        if (tView.firstCreatePass) {\n            getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n        }\n    }\n}\nfunction createTNode(tView, tParent, type, index, value, attrs) {\n    ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in\n        // `view_engine_compatibility` for additional context.\n        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n    ngDevMode && assertNotSame(attrs, undefined, '\\'undefined\\' is not valid value for \\'attrs\\'');\n    ngDevMode && ngDevMode.tNode++;\n    ngDevMode && tParent && assertTNodeForTView(tParent, tView);\n    let injectorIndex = tParent ? tParent.injectorIndex : -1;\n    const tNode = ngDevMode ?\n        new TNodeDebug(tView, // tView_: TView\n        type, // type: TNodeType\n        index, // index: number\n        null, // insertBeforeIndex: null|-1|number|number[]\n        injectorIndex, // injectorIndex: number\n        -1, // directiveStart: number\n        -1, // directiveEnd: number\n        -1, // directiveStylingLast: number\n        null, // propertyBindings: number[]|null\n        0, // flags: TNodeFlags\n        0, // providerIndexes: TNodeProviderIndexes\n        value, // value: string|null\n        attrs, // attrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null\n        null, // mergedAttrs\n        null, // localNames: (string|number)[]|null\n        undefined, // initialInputs: (string[]|null)[]|null|undefined\n        null, // inputs: PropertyAliases|null\n        null, // outputs: PropertyAliases|null\n        null, // tViews: ITView|ITView[]|null\n        null, // next: ITNode|null\n        null, // projectionNext: ITNode|null\n        null, // child: ITNode|null\n        tParent, // parent: TElementNode|TContainerNode|null\n        null, // projection: number|(ITNode|RNode[])[]|null\n        null, // styles: string|null\n        null, // stylesWithoutHost: string|null\n        undefined, // residualStyles: string|null\n        null, // classes: string|null\n        null, // classesWithoutHost: string|null\n        undefined, // residualClasses: string|null\n        0, // classBindings: TStylingRange;\n        0) :\n        {\n            type,\n            index,\n            insertBeforeIndex: null,\n            injectorIndex,\n            directiveStart: -1,\n            directiveEnd: -1,\n            directiveStylingLast: -1,\n            propertyBindings: null,\n            flags: 0,\n            providerIndexes: 0,\n            value: value,\n            attrs: attrs,\n            mergedAttrs: null,\n            localNames: null,\n            initialInputs: undefined,\n            inputs: null,\n            outputs: null,\n            tViews: null,\n            next: null,\n            projectionNext: null,\n            child: null,\n            parent: tParent,\n            projection: null,\n            styles: null,\n            stylesWithoutHost: null,\n            residualStyles: undefined,\n            classes: null,\n            classesWithoutHost: null,\n            residualClasses: undefined,\n            classBindings: 0,\n            styleBindings: 0,\n        };\n    if (ngDevMode) {\n        // For performance reasons it is important that the tNode retains the same shape during runtime.\n        // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n        // prevent class transitions.\n        Object.seal(tNode);\n    }\n    return tNode;\n}\nfunction generatePropertyAliases(inputAliasMap, directiveDefIdx, propStore) {\n    for (let publicName in inputAliasMap) {\n        if (inputAliasMap.hasOwnProperty(publicName)) {\n            propStore = propStore === null ? {} : propStore;\n            const internalName = inputAliasMap[publicName];\n            if (propStore.hasOwnProperty(publicName)) {\n                propStore[publicName].push(directiveDefIdx, internalName);\n            }\n            else {\n                (propStore[publicName] = [directiveDefIdx, internalName]);\n            }\n        }\n    }\n    return propStore;\n}\n/**\n * Initializes data structures required to work with directive inputs and outputs.\n * Initialization is done for all directives matched on a given TNode.\n */\nfunction initializeInputAndOutputAliases(tView, tNode) {\n    ngDevMode && assertFirstCreatePass(tView);\n    const start = tNode.directiveStart;\n    const end = tNode.directiveEnd;\n    const tViewData = tView.data;\n    const tNodeAttrs = tNode.attrs;\n    const inputsFromAttrs = ngDevMode ? new TNodeInitialInputs() : [];\n    let inputsStore = null;\n    let outputsStore = null;\n    for (let i = start; i < end; i++) {\n        const directiveDef = tViewData[i];\n        const directiveInputs = directiveDef.inputs;\n        // Do not use unbound attributes as inputs to structural directives, since structural\n        // directive inputs can only be set using microsyntax (e.g. `<div *dir=\"exp\">`).\n        // TODO(FW-1930): microsyntax expressions may also contain unbound/static attributes, which\n        // should be set for inline templates.\n        const initialInputs = (tNodeAttrs !== null && !isInlineTemplate(tNode)) ?\n            generateInitialInputs(directiveInputs, tNodeAttrs) :\n            null;\n        inputsFromAttrs.push(initialInputs);\n        inputsStore = generatePropertyAliases(directiveInputs, i, inputsStore);\n        outputsStore = generatePropertyAliases(directiveDef.outputs, i, outputsStore);\n    }\n    if (inputsStore !== null) {\n        if (inputsStore.hasOwnProperty('class')) {\n            tNode.flags |= 16 /* TNodeFlags.hasClassInput */;\n        }\n        if (inputsStore.hasOwnProperty('style')) {\n            tNode.flags |= 32 /* TNodeFlags.hasStyleInput */;\n        }\n    }\n    tNode.initialInputs = inputsFromAttrs;\n    tNode.inputs = inputsStore;\n    tNode.outputs = outputsStore;\n}\n/**\n * Mapping between attributes names that don't correspond to their element property names.\n *\n * Performance note: this function is written as a series of if checks (instead of, say, a property\n * object lookup) for performance reasons - the series of `if` checks seems to be the fastest way of\n * mapping property names. Do NOT change without benchmarking.\n *\n * Note: this mapping has to be kept in sync with the equally named mapping in the template\n * type-checking machinery of ngtsc.\n */\nfunction mapPropName(name) {\n    if (name === 'class')\n        return 'className';\n    if (name === 'for')\n        return 'htmlFor';\n    if (name === 'formaction')\n        return 'formAction';\n    if (name === 'innerHtml')\n        return 'innerHTML';\n    if (name === 'readonly')\n        return 'readOnly';\n    if (name === 'tabindex')\n        return 'tabIndex';\n    return name;\n}\nfunction elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {\n    ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n    const element = getNativeByTNode(tNode, lView);\n    let inputData = tNode.inputs;\n    let dataValue;\n    if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {\n        setInputsForProperty(tView, lView, dataValue, propName, value);\n        if (isComponentHost(tNode))\n            markDirtyIfOnPush(lView, tNode.index);\n        if (ngDevMode) {\n            setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n        }\n    }\n    else if (tNode.type & 3 /* TNodeType.AnyRNode */) {\n        propName = mapPropName(propName);\n        if (ngDevMode) {\n            validateAgainstEventProperties(propName);\n            if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {\n                handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n            }\n            ngDevMode.rendererSetProperty++;\n        }\n        // It is assumed that the sanitizer is only added when the compiler determines that the\n        // property is risky, so sanitization can be done without further checks.\n        value = sanitizer != null ? sanitizer(value, tNode.value || '', propName) : value;\n        renderer.setProperty(element, propName, value);\n    }\n    else if (tNode.type & 12 /* TNodeType.AnyContainer */) {\n        // If the node is a container and the property didn't\n        // match any of the inputs or schemas we should throw.\n        if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) {\n            handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n        }\n    }\n}\n/** If node is an OnPush component, marks its LView dirty. */\nfunction markDirtyIfOnPush(lView, viewIndex) {\n    ngDevMode && assertLView(lView);\n    const childComponentLView = getComponentLViewByIndex(viewIndex, lView);\n    if (!(childComponentLView[FLAGS] & 16 /* LViewFlags.CheckAlways */)) {\n        childComponentLView[FLAGS] |= 32 /* LViewFlags.Dirty */;\n    }\n}\nfunction setNgReflectProperty(lView, element, type, attrName, value) {\n    const renderer = lView[RENDERER];\n    attrName = normalizeDebugBindingName(attrName);\n    const debugValue = normalizeDebugBindingValue(value);\n    if (type & 3 /* TNodeType.AnyRNode */) {\n        if (value == null) {\n            renderer.removeAttribute(element, attrName);\n        }\n        else {\n            renderer.setAttribute(element, attrName, debugValue);\n        }\n    }\n    else {\n        const textContent = escapeCommentText(`bindings=${JSON.stringify({ [attrName]: debugValue }, null, 2)}`);\n        renderer.setValue(element, textContent);\n    }\n}\nfunction setNgReflectProperties(lView, element, type, dataValue, value) {\n    if (type & (3 /* TNodeType.AnyRNode */ | 4 /* TNodeType.Container */)) {\n        /**\n         * dataValue is an array containing runtime input or output names for the directives:\n         * i+0: directive instance index\n         * i+1: privateName\n         *\n         * e.g. [0, 'change', 'change-minified']\n         * we want to set the reflected property with the privateName: dataValue[i+1]\n         */\n        for (let i = 0; i < dataValue.length; i += 2) {\n            setNgReflectProperty(lView, element, type, dataValue[i + 1], value);\n        }\n    }\n}\n/**\n * Instantiate a root component.\n */\nfunction instantiateRootComponent(tView, lView, def) {\n    const rootTNode = getCurrentTNode();\n    if (tView.firstCreatePass) {\n        if (def.providersResolver)\n            def.providersResolver(def);\n        const directiveIndex = allocExpando(tView, lView, 1, null);\n        ngDevMode &&\n            assertEqual(directiveIndex, rootTNode.directiveStart, 'Because this is a root component the allocated expando should match the TNode component.');\n        configureViewWithDirective(tView, rootTNode, lView, directiveIndex, def);\n        initializeInputAndOutputAliases(tView, rootTNode);\n    }\n    const directive = getNodeInjectable(lView, tView, rootTNode.directiveStart, rootTNode);\n    attachPatchData(directive, lView);\n    const native = getNativeByTNode(rootTNode, lView);\n    if (native) {\n        attachPatchData(native, lView);\n    }\n    return directive;\n}\n/**\n * Resolve the matched directives on a node.\n */\nfunction resolveDirectives(tView, lView, tNode, localRefs) {\n    // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in\n    // tsickle.\n    ngDevMode && assertFirstCreatePass(tView);\n    let hasDirectives = false;\n    if (getBindingsEnabled()) {\n        const directiveDefs = findDirectiveDefMatches(tView, lView, tNode);\n        const exportsMap = localRefs === null ? null : { '': -1 };\n        if (directiveDefs !== null) {\n            hasDirectives = true;\n            initTNodeFlags(tNode, tView.data.length, directiveDefs.length);\n            // When the same token is provided by several directives on the same node, some rules apply in\n            // the viewEngine:\n            // - viewProviders have priority over providers\n            // - the last directive in NgModule.declarations has priority over the previous one\n            // So to match these rules, the order in which providers are added in the arrays is very\n            // important.\n            for (let i = 0; i < directiveDefs.length; i++) {\n                const def = directiveDefs[i];\n                if (def.providersResolver)\n                    def.providersResolver(def);\n            }\n            let preOrderHooksFound = false;\n            let preOrderCheckHooksFound = false;\n            let directiveIdx = allocExpando(tView, lView, directiveDefs.length, null);\n            ngDevMode &&\n                assertSame(directiveIdx, tNode.directiveStart, 'TNode.directiveStart should point to just allocated space');\n            for (let i = 0; i < directiveDefs.length; i++) {\n                const def = directiveDefs[i];\n                // Merge the attrs in the order of matches. This assumes that the first directive is the\n                // component itself, so that the component has the least priority.\n                tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);\n                configureViewWithDirective(tView, tNode, lView, directiveIdx, def);\n                saveNameToExportMap(directiveIdx, def, exportsMap);\n                if (def.contentQueries !== null)\n                    tNode.flags |= 8 /* TNodeFlags.hasContentQuery */;\n                if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)\n                    tNode.flags |= 128 /* TNodeFlags.hasHostBindings */;\n                const lifeCycleHooks = def.type.prototype;\n                // Only push a node index into the preOrderHooks array if this is the first\n                // pre-order hook found on this node.\n                if (!preOrderHooksFound &&\n                    (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {\n                    // We will push the actual hook function into this array later during dir instantiation.\n                    // We cannot do it now because we must ensure hooks are registered in the same\n                    // order that directives are created (i.e. injection order).\n                    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(tNode.index);\n                    preOrderHooksFound = true;\n                }\n                if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {\n                    (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(tNode.index);\n                    preOrderCheckHooksFound = true;\n                }\n                directiveIdx++;\n            }\n            initializeInputAndOutputAliases(tView, tNode);\n        }\n        if (exportsMap)\n            cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n    }\n    // Merge the template attrs last so that they have the highest priority.\n    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);\n    return hasDirectives;\n}\n/**\n * Add `hostBindings` to the `TView.hostBindingOpCodes`.\n *\n * @param tView `TView` to which the `hostBindings` should be added.\n * @param tNode `TNode` the element which contains the directive\n * @param lView `LView` current `LView`\n * @param directiveIdx Directive index in view.\n * @param directiveVarsIdx Where will the directive's vars be stored\n * @param def `ComponentDef`/`DirectiveDef`, which contains the `hostVars`/`hostBindings` to add.\n */\nfunction registerHostBindingOpCodes(tView, tNode, lView, directiveIdx, directiveVarsIdx, def) {\n    ngDevMode && assertFirstCreatePass(tView);\n    const hostBindings = def.hostBindings;\n    if (hostBindings) {\n        let hostBindingOpCodes = tView.hostBindingOpCodes;\n        if (hostBindingOpCodes === null) {\n            hostBindingOpCodes = tView.hostBindingOpCodes = [];\n        }\n        const elementIndx = ~tNode.index;\n        if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {\n            // Conditionally add select element so that we are more efficient in execution.\n            // NOTE: this is strictly not necessary and it trades code size for runtime perf.\n            // (We could just always add it.)\n            hostBindingOpCodes.push(elementIndx);\n        }\n        hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);\n    }\n}\n/**\n * Returns the last selected element index in the `HostBindingOpCodes`\n *\n * For perf reasons we don't need to update the selected element index in `HostBindingOpCodes` only\n * if it changes. This method returns the last index (or '0' if not found.)\n *\n * Selected element index are only the ones which are negative.\n */\nfunction lastSelectedElementIdx(hostBindingOpCodes) {\n    let i = hostBindingOpCodes.length;\n    while (i > 0) {\n        const value = hostBindingOpCodes[--i];\n        if (typeof value === 'number' && value < 0) {\n            return value;\n        }\n    }\n    return 0;\n}\n/**\n * Instantiate all the directives that were previously resolved on the current node.\n */\nfunction instantiateAllDirectives(tView, lView, tNode, native) {\n    const start = tNode.directiveStart;\n    const end = tNode.directiveEnd;\n    if (!tView.firstCreatePass) {\n        getOrCreateNodeInjectorForNode(tNode, lView);\n    }\n    attachPatchData(native, lView);\n    const initialInputs = tNode.initialInputs;\n    for (let i = start; i < end; i++) {\n        const def = tView.data[i];\n        const isComponent = isComponentDef(def);\n        if (isComponent) {\n            ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */);\n            addComponentLogic(lView, tNode, def);\n        }\n        const directive = getNodeInjectable(lView, tView, i, tNode);\n        attachPatchData(directive, lView);\n        if (initialInputs !== null) {\n            setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);\n        }\n        if (isComponent) {\n            const componentView = getComponentLViewByIndex(tNode.index, lView);\n            componentView[CONTEXT] = directive;\n        }\n    }\n}\nfunction invokeDirectivesHostBindings(tView, lView, tNode) {\n    const start = tNode.directiveStart;\n    const end = tNode.directiveEnd;\n    const elementIndex = tNode.index;\n    const currentDirectiveIndex = getCurrentDirectiveIndex();\n    try {\n        setSelectedIndex(elementIndex);\n        for (let dirIndex = start; dirIndex < end; dirIndex++) {\n            const def = tView.data[dirIndex];\n            const directive = lView[dirIndex];\n            setCurrentDirectiveIndex(dirIndex);\n            if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {\n                invokeHostBindingsInCreationMode(def, directive);\n            }\n        }\n    }\n    finally {\n        setSelectedIndex(-1);\n        setCurrentDirectiveIndex(currentDirectiveIndex);\n    }\n}\n/**\n * Invoke the host bindings in creation mode.\n *\n * @param def `DirectiveDef` which may contain the `hostBindings` function.\n * @param directive Instance of directive.\n */\nfunction invokeHostBindingsInCreationMode(def, directive) {\n    if (def.hostBindings !== null) {\n        def.hostBindings(1 /* RenderFlags.Create */, directive);\n    }\n}\n/**\n * Matches the current node against all available selectors.\n * If a component is matched (at most one), it is returned in first position in the array.\n */\nfunction findDirectiveDefMatches(tView, viewData, tNode) {\n    ngDevMode && assertFirstCreatePass(tView);\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */);\n    const registry = tView.directiveRegistry;\n    let matches = null;\n    if (registry) {\n        for (let i = 0; i < registry.length; i++) {\n            const def = registry[i];\n            if (isNodeMatchingSelectorList(tNode, def.selectors, /* isProjectionMode */ false)) {\n                matches || (matches = ngDevMode ? new MatchesArray() : []);\n                diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type);\n                if (isComponentDef(def)) {\n                    if (ngDevMode) {\n                        assertTNodeType(tNode, 2 /* TNodeType.Element */, `\"${tNode.value}\" tags cannot be used as component hosts. ` +\n                            `Please use a different tag to activate the ${stringify(def.type)} component.`);\n                        if (tNode.flags & 2 /* TNodeFlags.isComponentHost */) {\n                            // If another component has been matched previously, it's the first element in the\n                            // `matches` array, see how we store components/directives in `matches` below.\n                            throwMultipleComponentError(tNode, matches[0].type, def.type);\n                        }\n                    }\n                    markAsComponentHost(tView, tNode);\n                    // The component is always stored first with directives after.\n                    matches.unshift(def);\n                }\n                else {\n                    matches.push(def);\n                }\n            }\n        }\n    }\n    return matches;\n}\n/**\n * Marks a given TNode as a component's host. This consists of:\n * - setting appropriate TNode flags;\n * - storing index of component's host element so it will be queued for view refresh during CD.\n */\nfunction markAsComponentHost(tView, hostTNode) {\n    ngDevMode && assertFirstCreatePass(tView);\n    hostTNode.flags |= 2 /* TNodeFlags.isComponentHost */;\n    (tView.components || (tView.components = ngDevMode ? new TViewComponents() : []))\n        .push(hostTNode.index);\n}\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(tNode, localRefs, exportsMap) {\n    if (localRefs) {\n        const localNames = tNode.localNames = ngDevMode ? new TNodeLocalNames() : [];\n        // Local names must be stored in tNode in the same order that localRefs are defined\n        // in the template to ensure the data is loaded in the same slots as their refs\n        // in the template (for template queries).\n        for (let i = 0; i < localRefs.length; i += 2) {\n            const index = exportsMap[localRefs[i + 1]];\n            if (index == null)\n                throw new RuntimeError(-301 /* RuntimeErrorCode.EXPORT_NOT_FOUND */, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);\n            localNames.push(localRefs[i], index);\n        }\n    }\n}\n/**\n * Builds up an export map as directives are created, so local refs can be quickly mapped\n * to their directive instances.\n */\nfunction saveNameToExportMap(directiveIdx, def, exportsMap) {\n    if (exportsMap) {\n        if (def.exportAs) {\n            for (let i = 0; i < def.exportAs.length; i++) {\n                exportsMap[def.exportAs[i]] = directiveIdx;\n            }\n        }\n        if (isComponentDef(def))\n            exportsMap[''] = directiveIdx;\n    }\n}\n/**\n * Initializes the flags on the current node, setting all indices to the initial index,\n * the directive count to 0, and adding the isComponent flag.\n * @param index the initial index\n */\nfunction initTNodeFlags(tNode, index, numberOfDirectives) {\n    ngDevMode &&\n        assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, 'Reached the max number of directives');\n    tNode.flags |= 1 /* TNodeFlags.isDirectiveHost */;\n    // When the first directive is created on a node, save the index\n    tNode.directiveStart = index;\n    tNode.directiveEnd = index + numberOfDirectives;\n    tNode.providerIndexes = index;\n}\n/**\n * Setup directive for instantiation.\n *\n * We need to create a `NodeInjectorFactory` which is then inserted in both the `Blueprint` as well\n * as `LView`. `TView` gets the `DirectiveDef`.\n *\n * @param tView `TView`\n * @param tNode `TNode`\n * @param lView `LView`\n * @param directiveIndex Index where the directive will be stored in the Expando.\n * @param def `DirectiveDef`\n */\nfunction configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {\n    ngDevMode &&\n        assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, 'Must be in Expando section');\n    tView.data[directiveIndex] = def;\n    const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));\n    // Even though `directiveFactory` will already be using `\u0275\u0275directiveInject` in its generated code,\n    // we also want to support `inject()` directly from the directive constructor context so we set\n    // `\u0275\u0275directiveInject` as the inject implementation here too.\n    const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), \u0275\u0275directiveInject);\n    tView.blueprint[directiveIndex] = nodeInjectorFactory;\n    lView[directiveIndex] = nodeInjectorFactory;\n    registerHostBindingOpCodes(tView, tNode, lView, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);\n}\nfunction addComponentLogic(lView, hostTNode, def) {\n    const native = getNativeByTNode(hostTNode, lView);\n    const tView = getOrCreateComponentTView(def);\n    // Only component views should be added to the view tree directly. Embedded views are\n    // accessed through their containers because they may be removed / re-added later.\n    const rendererFactory = lView[RENDERER_FACTORY];\n    const componentView = addToViewTree(lView, createLView(lView, tView, null, def.onPush ? 32 /* LViewFlags.Dirty */ : 16 /* LViewFlags.CheckAlways */, native, hostTNode, rendererFactory, rendererFactory.createRenderer(native, def), null, null, null));\n    // Component view will always be created before any injected LContainers,\n    // so this is a regular element, wrap it with the component view\n    lView[hostTNode.index] = componentView;\n}\nfunction elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {\n    if (ngDevMode) {\n        assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n        validateAgainstEventAttributes(name);\n        assertTNodeType(tNode, 2 /* TNodeType.Element */, `Attempted to set attribute \\`${name}\\` on a container node. ` +\n            `Host bindings are not valid on ng-container or ng-template.`);\n    }\n    const element = getNativeByTNode(tNode, lView);\n    setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);\n}\nfunction setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {\n    if (value == null) {\n        ngDevMode && ngDevMode.rendererRemoveAttribute++;\n        renderer.removeAttribute(element, name, namespace);\n    }\n    else {\n        ngDevMode && ngDevMode.rendererSetAttribute++;\n        const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || '', name);\n        renderer.setAttribute(element, name, strValue, namespace);\n    }\n}\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param lView Current LView that is being processed.\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param def The directive def that contains the list of inputs\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {\n    const initialInputs = initialInputData[directiveIndex];\n    if (initialInputs !== null) {\n        const setInput = def.setInput;\n        for (let i = 0; i < initialInputs.length;) {\n            const publicName = initialInputs[i++];\n            const privateName = initialInputs[i++];\n            const value = initialInputs[i++];\n            if (setInput !== null) {\n                def.setInput(instance, value, publicName, privateName);\n            }\n            else {\n                instance[privateName] = value;\n            }\n            if (ngDevMode) {\n                const nativeElement = getNativeByTNode(tNode, lView);\n                setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);\n            }\n        }\n    }\n}\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param inputs The list of inputs from the directive def\n * @param attrs The static attrs on this node\n */\nfunction generateInitialInputs(inputs, attrs) {\n    let inputsToStore = null;\n    let i = 0;\n    while (i < attrs.length) {\n        const attrName = attrs[i];\n        if (attrName === 0 /* AttributeMarker.NamespaceURI */) {\n            // We do not allow inputs on namespaced attributes.\n            i += 4;\n            continue;\n        }\n        else if (attrName === 5 /* AttributeMarker.ProjectAs */) {\n            // Skip over the `ngProjectAs` value.\n            i += 2;\n            continue;\n        }\n        // If we hit any other attribute markers, we're done anyway. None of those are valid inputs.\n        if (typeof attrName === 'number')\n            break;\n        if (inputs.hasOwnProperty(attrName)) {\n            if (inputsToStore === null)\n                inputsToStore = [];\n            inputsToStore.push(attrName, inputs[attrName], attrs[i + 1]);\n        }\n        i += 2;\n    }\n    return inputsToStore;\n}\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n// Not sure why I need to do `any` here but TS complains later.\nconst LContainerArray = class LContainer extends Array {\n};\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nfunction createLContainer(hostNative, currentView, native, tNode) {\n    ngDevMode && assertLView(currentView);\n    // https://jsperf.com/array-literal-vs-new-array-really\n    const lContainer = new (ngDevMode ? LContainerArray : Array)(hostNative, // host native\n    true, // Boolean `true` in this position signifies that this is an `LContainer`\n    false, // has transplanted views\n    currentView, // parent\n    null, // next\n    0, // transplanted views to refresh count\n    tNode, // t_host\n    native, // native,\n    null, // view refs\n    null);\n    ngDevMode &&\n        assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, 'Should allocate correct number of slots for LContainer header.');\n    ngDevMode && attachLContainerDebug(lContainer);\n    return lContainer;\n}\n/**\n * Goes over embedded views (ones created through ViewContainerRef APIs) and refreshes\n * them by executing an associated template function.\n */\nfunction refreshEmbeddedViews(lView) {\n    for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n        for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n            const embeddedLView = lContainer[i];\n            const embeddedTView = embeddedLView[TVIEW];\n            ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');\n            if (viewAttachedToChangeDetector(embeddedLView)) {\n                refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);\n            }\n        }\n    }\n}\n/**\n * Mark transplanted views as needing to be refreshed at their insertion points.\n *\n * @param lView The `LView` that may have transplanted views.\n */\nfunction markTransplantedViewsForRefresh(lView) {\n    for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n        if (!lContainer[HAS_TRANSPLANTED_VIEWS])\n            continue;\n        const movedViews = lContainer[MOVED_VIEWS];\n        ngDevMode && assertDefined(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');\n        for (let i = 0; i < movedViews.length; i++) {\n            const movedLView = movedViews[i];\n            const insertionLContainer = movedLView[PARENT];\n            ngDevMode && assertLContainer(insertionLContainer);\n            // We don't want to increment the counter if the moved LView was already marked for\n            // refresh.\n            if ((movedLView[FLAGS] & 512 /* LViewFlags.RefreshTransplantedView */) === 0) {\n                updateTransplantedViewCount(insertionLContainer, 1);\n            }\n            // Note, it is possible that the `movedViews` is tracking views that are transplanted *and*\n            // those that aren't (declaration component === insertion component). In the latter case,\n            // it's fine to add the flag, as we will clear it immediately in\n            // `refreshEmbeddedViews` for the view currently being refreshed.\n            movedLView[FLAGS] |= 512 /* LViewFlags.RefreshTransplantedView */;\n        }\n    }\n}\n/////////////\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param componentHostIdx  Element index in LView[] (adjusted for HEADER_OFFSET)\n */\nfunction refreshComponent(hostLView, componentHostIdx) {\n    ngDevMode && assertEqual(isCreationMode(hostLView), false, 'Should be run in update mode');\n    const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n    // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n    if (viewAttachedToChangeDetector(componentView)) {\n        const tView = componentView[TVIEW];\n        if (componentView[FLAGS] & (16 /* LViewFlags.CheckAlways */ | 32 /* LViewFlags.Dirty */)) {\n            refreshView(tView, componentView, tView.template, componentView[CONTEXT]);\n        }\n        else if (componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n            // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n            refreshContainsDirtyView(componentView);\n        }\n    }\n}\n/**\n * Refreshes all transplanted views marked with `LViewFlags.RefreshTransplantedView` that are\n * children or descendants of the given lView.\n *\n * @param lView The lView which contains descendant transplanted views that need to be refreshed.\n */\nfunction refreshContainsDirtyView(lView) {\n    for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n        for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n            const embeddedLView = lContainer[i];\n            if (viewAttachedToChangeDetector(embeddedLView)) {\n                if (embeddedLView[FLAGS] & 512 /* LViewFlags.RefreshTransplantedView */) {\n                    const embeddedTView = embeddedLView[TVIEW];\n                    ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');\n                    refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);\n                }\n                else if (embeddedLView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n                    refreshContainsDirtyView(embeddedLView);\n                }\n            }\n        }\n    }\n    const tView = lView[TVIEW];\n    // Refresh child component views.\n    const components = tView.components;\n    if (components !== null) {\n        for (let i = 0; i < components.length; i++) {\n            const componentView = getComponentLViewByIndex(components[i], lView);\n            // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n            if (viewAttachedToChangeDetector(componentView) &&\n                componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n                refreshContainsDirtyView(componentView);\n            }\n        }\n    }\n}\nfunction renderComponent(hostLView, componentHostIdx) {\n    ngDevMode && assertEqual(isCreationMode(hostLView), true, 'Should be run in creation mode');\n    const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n    const componentTView = componentView[TVIEW];\n    syncViewWithBlueprint(componentTView, componentView);\n    renderView(componentTView, componentView, componentView[CONTEXT]);\n}\n/**\n * Syncs an LView instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LView is created.\n * 3. Second <comp> is matched as a component and its LView is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LView was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param tView The `TView` that contains the blueprint for syncing\n * @param lView The view to sync\n */\nfunction syncViewWithBlueprint(tView, lView) {\n    for (let i = lView.length; i < tView.blueprint.length; i++) {\n        lView.push(tView.blueprint[i]);\n    }\n}\n/**\n * Adds LView or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param lView The view where LView or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header\n * @param lViewOrLContainer The LView or LContainer to add to the view tree\n * @returns The state passed in\n */\nfunction addToViewTree(lView, lViewOrLContainer) {\n    // TODO(benlesh/misko): This implementation is incorrect, because it always adds the LContainer\n    // to the end of the queue, which means if the developer retrieves the LContainers from RNodes out\n    // of order, the change detection will run out of order, as the act of retrieving the the\n    // LContainer from the RNode is what adds it to the queue.\n    if (lView[CHILD_HEAD]) {\n        lView[CHILD_TAIL][NEXT] = lViewOrLContainer;\n    }\n    else {\n        lView[CHILD_HEAD] = lViewOrLContainer;\n    }\n    lView[CHILD_TAIL] = lViewOrLContainer;\n    return lViewOrLContainer;\n}\n///////////////////////////////\n//// Change detection\n///////////////////////////////\n/**\n * Marks current view and all ancestors dirty.\n *\n * Returns the root view because it is found as a byproduct of marking the view tree\n * dirty, and can be used by methods that consume markViewDirty() to easily schedule\n * change detection. Otherwise, such methods would need to traverse up the view tree\n * an additional time to get the root view and schedule a tick on it.\n *\n * @param lView The starting LView to mark dirty\n * @returns the root LView\n */\nfunction markViewDirty(lView) {\n    while (lView) {\n        lView[FLAGS] |= 32 /* LViewFlags.Dirty */;\n        const parent = getLViewParent(lView);\n        // Stop traversing up as soon as you find a root view that wasn't attached to any container\n        if (isRootView(lView) && !parent) {\n            return lView;\n        }\n        // continue otherwise\n        lView = parent;\n    }\n    return null;\n}\nfunction detectChangesInternal(tView, lView, context, notifyErrorHandler = true) {\n    const rendererFactory = lView[RENDERER_FACTORY];\n    // Check no changes mode is a dev only mode used to verify that bindings have not changed\n    // since they were assigned. We do not want to invoke renderer factory functions in that mode\n    // to avoid any possible side-effects.\n    const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();\n    if (!checkNoChangesMode && rendererFactory.begin)\n        rendererFactory.begin();\n    try {\n        refreshView(tView, lView, tView.template, context);\n    }\n    catch (error) {\n        if (notifyErrorHandler) {\n            handleError(lView, error);\n        }\n        throw error;\n    }\n    finally {\n        if (!checkNoChangesMode && rendererFactory.end)\n            rendererFactory.end();\n    }\n}\nfunction checkNoChangesInternal(tView, lView, context, notifyErrorHandler = true) {\n    setIsInCheckNoChangesMode(true);\n    try {\n        detectChangesInternal(tView, lView, context, notifyErrorHandler);\n    }\n    finally {\n        setIsInCheckNoChangesMode(false);\n    }\n}\nfunction executeViewQueryFn(flags, viewQueryFn, component) {\n    ngDevMode && assertDefined(viewQueryFn, 'View queries function to execute must be defined.');\n    setCurrentQueryIndex(0);\n    viewQueryFn(flags, component);\n}\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n/**\n * Stores meta-data for a property binding to be used by TestBed's `DebugElement.properties`.\n *\n * In order to support TestBed's `DebugElement.properties` we need to save, for each binding:\n * - a bound property name;\n * - a static parts of interpolated strings;\n *\n * A given property metadata is saved at the binding's index in the `TView.data` (in other words, a\n * property binding metadata will be stored in `TView.data` at the same index as a bound value in\n * `LView`). Metadata are represented as `INTERPOLATION_DELIMITER`-delimited string with the\n * following format:\n * - `propertyName` for bound properties;\n * - `propertyName\uFFFDprefix\uFFFDinterpolation_static_part1\uFFFD..interpolation_static_partN\uFFFDsuffix` for\n * interpolated properties.\n *\n * @param tData `TData` where meta-data will be saved;\n * @param tNode `TNode` that is a target of the binding;\n * @param propertyName bound property name;\n * @param bindingIndex binding index in `LView`\n * @param interpolationParts static interpolation parts (for property interpolations)\n */\nfunction storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {\n    // Binding meta-data are stored only the first time a given property instruction is processed.\n    // Since we don't have a concept of the \"first update pass\" we need to check for presence of the\n    // binding meta-data to decide if one should be stored (or if was stored already).\n    if (tData[bindingIndex] === null) {\n        if (tNode.inputs == null || !tNode.inputs[propertyName]) {\n            const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);\n            propBindingIdxs.push(bindingIndex);\n            let bindingMetadata = propertyName;\n            if (interpolationParts.length > 0) {\n                bindingMetadata +=\n                    INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);\n            }\n            tData[bindingIndex] = bindingMetadata;\n        }\n    }\n}\nfunction getOrCreateLViewCleanup(view) {\n    // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n    return view[CLEANUP] || (view[CLEANUP] = ngDevMode ? new LCleanup() : []);\n}\nfunction getOrCreateTViewCleanup(tView) {\n    return tView.cleanup || (tView.cleanup = ngDevMode ? new TCleanup() : []);\n}\n/**\n * There are cases where the sub component's renderer needs to be included\n * instead of the current renderer (see the componentSyntheticHost* instructions).\n */\nfunction loadComponentRenderer(currentDef, tNode, lView) {\n    // TODO(FW-2043): the `currentDef` is null when host bindings are invoked while creating root\n    // component (see packages/core/src/render3/component.ts). This is not consistent with the process\n    // of creating inner components, when current directive index is available in the state. In order\n    // to avoid relying on current def being `null` (thus special-casing root component creation), the\n    // process of creating root component should be unified with the process of creating inner\n    // components.\n    if (currentDef === null || isComponentDef(currentDef)) {\n        lView = unwrapLView(lView[tNode.index]);\n    }\n    return lView[RENDERER];\n}\n/** Handles an error thrown in an LView. */\nfunction handleError(lView, error) {\n    const injector = lView[INJECTOR$1];\n    const errorHandler = injector ? injector.get(ErrorHandler, null) : null;\n    errorHandler && errorHandler.handleError(error);\n}\n/**\n * Set the inputs of directives at the current node to corresponding value.\n *\n * @param tView The current TView\n * @param lView the `LView` which contains the directives.\n * @param inputs mapping between the public \"input\" name and privately-known,\n *        possibly minified, property names to write to.\n * @param value Value to set.\n */\nfunction setInputsForProperty(tView, lView, inputs, publicName, value) {\n    for (let i = 0; i < inputs.length;) {\n        const index = inputs[i++];\n        const privateName = inputs[i++];\n        const instance = lView[index];\n        ngDevMode && assertIndexInRange(lView, index);\n        const def = tView.data[index];\n        if (def.setInput !== null) {\n            def.setInput(instance, value, publicName, privateName);\n        }\n        else {\n            instance[privateName] = value;\n        }\n    }\n}\n/**\n * Updates a text binding at a given index in a given LView.\n */\nfunction textBindingInternal(lView, index, value) {\n    ngDevMode && assertString(value, 'Value should be a string');\n    ngDevMode && assertNotSame(value, NO_CHANGE, 'value should not be NO_CHANGE');\n    ngDevMode && assertIndexInRange(lView, index);\n    const element = getNativeByIndex(index, lView);\n    ngDevMode && assertDefined(element, 'native element should exist');\n    updateTextNode(lView[RENDERER], element, value);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Compute the static styling (class/style) from `TAttributes`.\n *\n * This function should be called during `firstCreatePass` only.\n *\n * @param tNode The `TNode` into which the styling information should be loaded.\n * @param attrs `TAttributes` containing the styling information.\n * @param writeToHost Where should the resulting static styles be written?\n *   - `false` Write to `TNode.stylesWithoutHost` / `TNode.classesWithoutHost`\n *   - `true` Write to `TNode.styles` / `TNode.classes`\n */\nfunction computeStaticStyling(tNode, attrs, writeToHost) {\n    ngDevMode &&\n        assertFirstCreatePass(getTView(), 'Expecting to be called in first template pass only');\n    let styles = writeToHost ? tNode.styles : null;\n    let classes = writeToHost ? tNode.classes : null;\n    let mode = 0;\n    if (attrs !== null) {\n        for (let i = 0; i < attrs.length; i++) {\n            const value = attrs[i];\n            if (typeof value === 'number') {\n                mode = value;\n            }\n            else if (mode == 1 /* AttributeMarker.Classes */) {\n                classes = concatStringsWithSpace(classes, value);\n            }\n            else if (mode == 2 /* AttributeMarker.Styles */) {\n                const style = value;\n                const styleValue = attrs[++i];\n                styles = concatStringsWithSpace(styles, style + ': ' + styleValue + ';');\n            }\n        }\n    }\n    writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;\n    writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction collectNativeNodes(tView, lView, tNode, result, isProjection = false) {\n    while (tNode !== null) {\n        ngDevMode &&\n            assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */ | 16 /* TNodeType.Projection */ | 32 /* TNodeType.Icu */);\n        const lNode = lView[tNode.index];\n        if (lNode !== null) {\n            result.push(unwrapRNode(lNode));\n        }\n        // A given lNode can represent either a native node or a LContainer (when it is a host of a\n        // ViewContainerRef). When we find a LContainer we need to descend into it to collect root nodes\n        // from the views in this container.\n        if (isLContainer(lNode)) {\n            for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {\n                const lViewInAContainer = lNode[i];\n                const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;\n                if (lViewFirstChildTNode !== null) {\n                    collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);\n                }\n            }\n        }\n        const tNodeType = tNode.type;\n        if (tNodeType & 8 /* TNodeType.ElementContainer */) {\n            collectNativeNodes(tView, lView, tNode.child, result);\n        }\n        else if (tNodeType & 32 /* TNodeType.Icu */) {\n            const nextRNode = icuContainerIterate(tNode, lView);\n            let rNode;\n            while (rNode = nextRNode()) {\n                result.push(rNode);\n            }\n        }\n        else if (tNodeType & 16 /* TNodeType.Projection */) {\n            const nodesInSlot = getProjectionNodes(lView, tNode);\n            if (Array.isArray(nodesInSlot)) {\n                result.push(...nodesInSlot);\n            }\n            else {\n                const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n                ngDevMode && assertParentView(parentView);\n                collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);\n            }\n        }\n        tNode = isProjection ? tNode.projectionNext : tNode.next;\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ViewRef {\n    constructor(\n    /**\n     * This represents `LView` associated with the component when ViewRef is a ChangeDetectorRef.\n     *\n     * When ViewRef is created for a dynamic component, this also represents the `LView` for the\n     * component.\n     *\n     * For a \"regular\" ViewRef created for an embedded view, this is the `LView` for the embedded\n     * view.\n     *\n     * @internal\n     */\n    _lView, \n    /**\n     * This represents the `LView` associated with the point where `ChangeDetectorRef` was\n     * requested.\n     *\n     * This may be different from `_lView` if the `_cdRefInjectingView` is an embedded view.\n     */\n    _cdRefInjectingView) {\n        this._lView = _lView;\n        this._cdRefInjectingView = _cdRefInjectingView;\n        this._appRef = null;\n        this._attachedToViewContainer = false;\n    }\n    get rootNodes() {\n        const lView = this._lView;\n        const tView = lView[TVIEW];\n        return collectNativeNodes(tView, lView, tView.firstChild, []);\n    }\n    get context() {\n        return this._lView[CONTEXT];\n    }\n    set context(value) {\n        this._lView[CONTEXT] = value;\n    }\n    get destroyed() {\n        return (this._lView[FLAGS] & 128 /* LViewFlags.Destroyed */) === 128 /* LViewFlags.Destroyed */;\n    }\n    destroy() {\n        if (this._appRef) {\n            this._appRef.detachView(this);\n        }\n        else if (this._attachedToViewContainer) {\n            const parent = this._lView[PARENT];\n            if (isLContainer(parent)) {\n                const viewRefs = parent[VIEW_REFS];\n                const index = viewRefs ? viewRefs.indexOf(this) : -1;\n                if (index > -1) {\n                    ngDevMode &&\n                        assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, 'An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.');\n                    detachView(parent, index);\n                    removeFromArray(viewRefs, index);\n                }\n            }\n            this._attachedToViewContainer = false;\n        }\n        destroyLView(this._lView[TVIEW], this._lView);\n    }\n    onDestroy(callback) {\n        storeCleanupWithContext(this._lView[TVIEW], this._lView, null, callback);\n    }\n    /**\n     * Marks a view and all of its ancestors dirty.\n     *\n     * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\n     * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n     * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n     *\n     * <!-- TODO: Add a link to a chapter on OnPush components -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * ```typescript\n     * @Component({\n     *   selector: 'app-root',\n     *   template: `Number of ticks: {{numberOfTicks}}`\n     *   changeDetection: ChangeDetectionStrategy.OnPush,\n     * })\n     * class AppComponent {\n     *   numberOfTicks = 0;\n     *\n     *   constructor(private ref: ChangeDetectorRef) {\n     *     setInterval(() => {\n     *       this.numberOfTicks++;\n     *       // the following is required, otherwise the view will not be updated\n     *       this.ref.markForCheck();\n     *     }, 1000);\n     *   }\n     * }\n     * ```\n     */\n    markForCheck() {\n        markViewDirty(this._cdRefInjectingView || this._lView);\n    }\n    /**\n     * Detaches the view from the change detection tree.\n     *\n     * Detached views will not be checked during change detection runs until they are\n     * re-attached, even if they are dirty. `detach` can be used in combination with\n     * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\n     * detection checks.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example defines a component with a large list of readonly data.\n     * Imagine the data changes constantly, many times per second. For performance reasons,\n     * we want to check and update the list every five seconds. We can do that by detaching\n     * the component's change detector and doing a local check every five seconds.\n     *\n     * ```typescript\n     * class DataProvider {\n     *   // in a real application the returned data will be different every time\n     *   get data() {\n     *     return [1,2,3,4,5];\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'giant-list',\n     *   template: `\n     *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n     *   `,\n     * })\n     * class GiantList {\n     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n     *     ref.detach();\n     *     setInterval(() => {\n     *       this.ref.detectChanges();\n     *     }, 5000);\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'app',\n     *   providers: [DataProvider],\n     *   template: `\n     *     <giant-list><giant-list>\n     *   `,\n     * })\n     * class App {\n     * }\n     * ```\n     */\n    detach() {\n        this._lView[FLAGS] &= ~64 /* LViewFlags.Attached */;\n    }\n    /**\n     * Re-attaches a view to the change detection tree.\n     *\n     * This can be used to re-attach views that were previously detached from the tree\n     * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example creates a component displaying `live` data. The component will detach\n     * its change detector from the main change detector tree when the component's live property\n     * is set to false.\n     *\n     * ```typescript\n     * class DataProvider {\n     *   data = 1;\n     *\n     *   constructor() {\n     *     setInterval(() => {\n     *       this.data = this.data * 2;\n     *     }, 500);\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'live-data',\n     *   inputs: ['live'],\n     *   template: 'Data: {{dataProvider.data}}'\n     * })\n     * class LiveData {\n     *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n     *\n     *   set live(value) {\n     *     if (value) {\n     *       this.ref.reattach();\n     *     } else {\n     *       this.ref.detach();\n     *     }\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'app-root',\n     *   providers: [DataProvider],\n     *   template: `\n     *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n     *     <live-data [live]=\"live\"><live-data>\n     *   `,\n     * })\n     * class AppComponent {\n     *   live = true;\n     * }\n     * ```\n     */\n    reattach() {\n        this._lView[FLAGS] |= 64 /* LViewFlags.Attached */;\n    }\n    /**\n     * Checks the view and its children.\n     *\n     * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\n     * local change detection checks.\n     *\n     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * The following example defines a component with a large list of readonly data.\n     * Imagine, the data changes constantly, many times per second. For performance reasons,\n     * we want to check and update the list every five seconds.\n     *\n     * We can do that by detaching the component's change detector and doing a local change detection\n     * check every five seconds.\n     *\n     * See {@link ChangeDetectorRef#detach detach} for more information.\n     */\n    detectChanges() {\n        detectChangesInternal(this._lView[TVIEW], this._lView, this.context);\n    }\n    /**\n     * Checks the change detector and its children, and throws if any changes are detected.\n     *\n     * This is used in development mode to verify that running change detection doesn't\n     * introduce other changes.\n     */\n    checkNoChanges() {\n        if (ngDevMode) {\n            checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context);\n        }\n    }\n    attachToViewContainerRef() {\n        if (this._appRef) {\n            throw new RuntimeError(902 /* RuntimeErrorCode.VIEW_ALREADY_ATTACHED */, ngDevMode && 'This view is already attached directly to the ApplicationRef!');\n        }\n        this._attachedToViewContainer = true;\n    }\n    detachFromAppRef() {\n        this._appRef = null;\n        renderDetachView(this._lView[TVIEW], this._lView);\n    }\n    attachToAppRef(appRef) {\n        if (this._attachedToViewContainer) {\n            throw new RuntimeError(902 /* RuntimeErrorCode.VIEW_ALREADY_ATTACHED */, ngDevMode && 'This view is already attached to a ViewContainer!');\n        }\n        this._appRef = appRef;\n    }\n}\n/** @internal */\nclass RootViewRef extends ViewRef {\n    constructor(_view) {\n        super(_view);\n        this._view = _view;\n    }\n    detectChanges() {\n        const lView = this._view;\n        const tView = lView[TVIEW];\n        const context = lView[CONTEXT];\n        detectChangesInternal(tView, lView, context, false);\n    }\n    checkNoChanges() {\n        if (ngDevMode) {\n            const lView = this._view;\n            const tView = lView[TVIEW];\n            const context = lView[CONTEXT];\n            checkNoChangesInternal(tView, lView, context, false);\n        }\n    }\n    get context() {\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ComponentFactoryResolver extends ComponentFactoryResolver$1 {\n    /**\n     * @param ngModule The NgModuleRef to which all resolved factories are bound.\n     */\n    constructor(ngModule) {\n        super();\n        this.ngModule = ngModule;\n    }\n    resolveComponentFactory(component) {\n        ngDevMode && assertComponentType(component);\n        const componentDef = getComponentDef$1(component);\n        return new ComponentFactory(componentDef, this.ngModule);\n    }\n}\nfunction toRefArray(map) {\n    const array = [];\n    for (let nonMinified in map) {\n        if (map.hasOwnProperty(nonMinified)) {\n            const minified = map[nonMinified];\n            array.push({ propName: minified, templateName: nonMinified });\n        }\n    }\n    return array;\n}\nfunction getNamespace(elementName) {\n    const name = elementName.toLowerCase();\n    return name === 'svg' ? SVG_NAMESPACE : (name === 'math' ? MATH_ML_NAMESPACE : null);\n}\n/**\n * Injector that looks up a value using a specific injector, before falling back to the module\n * injector. Used primarily when creating components or embedded views dynamically.\n */\nclass ChainedInjector {\n    constructor(injector, parentInjector) {\n        this.injector = injector;\n        this.parentInjector = parentInjector;\n    }\n    get(token, notFoundValue, flags) {\n        const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);\n        if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||\n            notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\n            // Return the value from the root element injector when\n            // - it provides it\n            //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n            // - the module injector should not be checked\n            //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n            return value;\n        }\n        return this.parentInjector.get(token, notFoundValue, flags);\n    }\n}\n/**\n * ComponentFactory interface implementation.\n */\nclass ComponentFactory extends ComponentFactory$1 {\n    /**\n     * @param componentDef The component definition.\n     * @param ngModule The NgModuleRef to which the factory is bound.\n     */\n    constructor(componentDef, ngModule) {\n        super();\n        this.componentDef = componentDef;\n        this.ngModule = ngModule;\n        this.componentType = componentDef.type;\n        this.selector = stringifyCSSSelectorList(componentDef.selectors);\n        this.ngContentSelectors =\n            componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];\n        this.isBoundToModule = !!ngModule;\n    }\n    get inputs() {\n        return toRefArray(this.componentDef.inputs);\n    }\n    get outputs() {\n        return toRefArray(this.componentDef.outputs);\n    }\n    create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {\n        environmentInjector = environmentInjector || this.ngModule;\n        let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ?\n            environmentInjector :\n            environmentInjector?.injector;\n        if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) {\n            realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) ||\n                realEnvironmentInjector;\n        }\n        const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;\n        const rendererFactory = rootViewInjector.get(RendererFactory2, null);\n        if (rendererFactory === null) {\n            throw new RuntimeError(407 /* RuntimeErrorCode.RENDERER_NOT_FOUND */, ngDevMode &&\n                'Angular was not able to inject a renderer (RendererFactory2). ' +\n                    'Likely this is due to a broken DI hierarchy. ' +\n                    'Make sure that any injector used to create this component has a correct parent.');\n        }\n        const sanitizer = rootViewInjector.get(Sanitizer, null);\n        const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);\n        // Determine a tag name used for creating host elements when this component is created\n        // dynamically. Default to 'div' if this component did not specify any tag name in its selector.\n        const elementName = this.componentDef.selectors[0][0] || 'div';\n        const hostRNode = rootSelectorOrNode ?\n            locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation) :\n            createElementNode(hostRenderer, elementName, getNamespace(elementName));\n        const rootFlags = this.componentDef.onPush ? 32 /* LViewFlags.Dirty */ | 256 /* LViewFlags.IsRoot */ :\n            16 /* LViewFlags.CheckAlways */ | 256 /* LViewFlags.IsRoot */;\n        // Create the root view. Uses empty TView and ContentTemplate.\n        const rootTView = createTView(0 /* TViewType.Root */, null, null, 1, 0, null, null, null, null, null);\n        const rootLView = createLView(null, rootTView, null, rootFlags, null, null, rendererFactory, hostRenderer, sanitizer, rootViewInjector, null);\n        // rootView is the parent when bootstrapping\n        // TODO(misko): it looks like we are entering view here but we don't really need to as\n        // `renderView` does that. However as the code is written it is needed because\n        // `createRootComponentView` and `createRootComponent` both read global state. Fixing those\n        // issues would allow us to drop this.\n        enterView(rootLView);\n        let component;\n        let tElementNode;\n        try {\n            const componentView = createRootComponentView(hostRNode, this.componentDef, rootLView, rendererFactory, hostRenderer);\n            if (hostRNode) {\n                if (rootSelectorOrNode) {\n                    setUpAttributes(hostRenderer, hostRNode, ['ng-version', VERSION.full]);\n                }\n                else {\n                    // If host element is created as a part of this function call (i.e. `rootSelectorOrNode`\n                    // is not defined), also apply attributes and classes extracted from component selector.\n                    // Extract attributes and classes from the first selector only to match VE behavior.\n                    const { attrs, classes } = extractAttrsAndClassesFromSelector(this.componentDef.selectors[0]);\n                    if (attrs) {\n                        setUpAttributes(hostRenderer, hostRNode, attrs);\n                    }\n                    if (classes && classes.length > 0) {\n                        writeDirectClass(hostRenderer, hostRNode, classes.join(' '));\n                    }\n                }\n            }\n            tElementNode = getTNode(rootTView, HEADER_OFFSET);\n            if (projectableNodes !== undefined) {\n                const projection = tElementNode.projection = [];\n                for (let i = 0; i < this.ngContentSelectors.length; i++) {\n                    const nodesforSlot = projectableNodes[i];\n                    // Projectable nodes can be passed as array of arrays or an array of iterables (ngUpgrade\n                    // case). Here we do normalize passed data structure to be an array of arrays to avoid\n                    // complex checks down the line.\n                    // We also normalize the length of the passed in projectable nodes (to match the number of\n                    // <ng-container> slots defined by a component).\n                    projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);\n                }\n            }\n            // TODO: should LifecycleHooksFeature and other host features be generated by the compiler and\n            // executed here?\n            // Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref\n            component =\n                createRootComponent(componentView, this.componentDef, rootLView, [LifecycleHooksFeature]);\n            renderView(rootTView, rootLView, null);\n        }\n        finally {\n            leaveView();\n        }\n        return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);\n    }\n}\nconst componentFactoryResolver = new ComponentFactoryResolver();\n/**\n * Creates a ComponentFactoryResolver and stores it on the injector. Or, if the\n * ComponentFactoryResolver\n * already exists, retrieves the existing ComponentFactoryResolver.\n *\n * @returns The ComponentFactoryResolver instance to use\n */\nfunction injectComponentFactoryResolver() {\n    return componentFactoryResolver;\n}\n/**\n * Represents an instance of a Component created via a {@link ComponentFactory}.\n *\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\n * method.\n *\n */\nclass ComponentRef extends ComponentRef$1 {\n    constructor(componentType, instance, location, _rootLView, _tNode) {\n        super();\n        this.location = location;\n        this._rootLView = _rootLView;\n        this._tNode = _tNode;\n        this.instance = instance;\n        this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);\n        this.componentType = componentType;\n    }\n    setInput(name, value) {\n        const inputData = this._tNode.inputs;\n        let dataValue;\n        if (inputData !== null && (dataValue = inputData[name])) {\n            const lView = this._rootLView;\n            setInputsForProperty(lView[TVIEW], lView, dataValue, name, value);\n            markDirtyIfOnPush(lView, this._tNode.index);\n        }\n        else {\n            if (ngDevMode) {\n                const cmpNameForError = stringifyForError(this.componentType);\n                let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;\n                message += `Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`;\n                reportUnknownPropertyError(message);\n            }\n        }\n    }\n    get injector() {\n        return new NodeInjector(this._tNode, this._rootLView);\n    }\n    destroy() {\n        this.hostView.destroy();\n    }\n    onDestroy(callback) {\n        this.hostView.onDestroy(callback);\n    }\n}\n// TODO: A hack to not pull in the NullInjector from @angular/core.\nconst NULL_INJECTOR = {\n    get: (token, notFoundValue) => {\n        throwProviderNotFoundError(token, 'NullInjector');\n    }\n};\n/**\n * Creates the root component view and the root component node.\n *\n * @param rNode Render host element.\n * @param def ComponentDef\n * @param rootView The parent view where the host node is stored\n * @param rendererFactory Factory to be used for creating child renderers.\n * @param hostRenderer The current renderer\n * @param sanitizer The sanitizer, if provided\n *\n * @returns Component view created\n */\nfunction createRootComponentView(rNode, def, rootView, rendererFactory, hostRenderer, sanitizer) {\n    const tView = rootView[TVIEW];\n    const index = HEADER_OFFSET;\n    ngDevMode && assertIndexInRange(rootView, index);\n    rootView[index] = rNode;\n    // '#host' is added here as we don't know the real host DOM name (we don't want to read it) and at\n    // the same time we want to communicate the debug `TNode` that this is a special `TNode`\n    // representing a host element.\n    const tNode = getOrCreateTNode(tView, index, 2 /* TNodeType.Element */, '#host', null);\n    const mergedAttrs = tNode.mergedAttrs = def.hostAttrs;\n    if (mergedAttrs !== null) {\n        computeStaticStyling(tNode, mergedAttrs, true);\n        if (rNode !== null) {\n            setUpAttributes(hostRenderer, rNode, mergedAttrs);\n            if (tNode.classes !== null) {\n                writeDirectClass(hostRenderer, rNode, tNode.classes);\n            }\n            if (tNode.styles !== null) {\n                writeDirectStyle(hostRenderer, rNode, tNode.styles);\n            }\n        }\n    }\n    const viewRenderer = rendererFactory.createRenderer(rNode, def);\n    const componentView = createLView(rootView, getOrCreateComponentTView(def), null, def.onPush ? 32 /* LViewFlags.Dirty */ : 16 /* LViewFlags.CheckAlways */, rootView[index], tNode, rendererFactory, viewRenderer, sanitizer || null, null, null);\n    if (tView.firstCreatePass) {\n        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);\n        markAsComponentHost(tView, tNode);\n        initTNodeFlags(tNode, rootView.length, 1);\n    }\n    addToViewTree(rootView, componentView);\n    // Store component view at node index, with node as the HOST\n    return rootView[index] = componentView;\n}\n/**\n * Creates a root component and sets it up with features and host bindings.Shared by\n * renderComponent() and ViewContainerRef.createComponent().\n */\nfunction createRootComponent(componentView, componentDef, rootLView, hostFeatures) {\n    const tView = rootLView[TVIEW];\n    // Create directive instance with factory() and store at next index in viewData\n    const component = instantiateRootComponent(tView, rootLView, componentDef);\n    // Root view only contains an instance of this component,\n    // so we use a reference to that component instance as a context.\n    componentView[CONTEXT] = rootLView[CONTEXT] = component;\n    if (hostFeatures !== null) {\n        for (const feature of hostFeatures) {\n            feature(component, componentDef);\n        }\n    }\n    // We want to generate an empty QueryList for root content queries for backwards\n    // compatibility with ViewEngine.\n    if (componentDef.contentQueries) {\n        const tNode = getCurrentTNode();\n        ngDevMode && assertDefined(tNode, 'TNode expected');\n        componentDef.contentQueries(1 /* RenderFlags.Create */, component, tNode.directiveStart);\n    }\n    const rootTNode = getCurrentTNode();\n    ngDevMode && assertDefined(rootTNode, 'tNode should have been already created');\n    if (tView.firstCreatePass &&\n        (componentDef.hostBindings !== null || componentDef.hostAttrs !== null)) {\n        setSelectedIndex(rootTNode.index);\n        const rootTView = rootLView[TVIEW];\n        registerHostBindingOpCodes(rootTView, rootTNode, rootLView, rootTNode.directiveStart, rootTNode.directiveEnd, componentDef);\n        invokeHostBindingsInCreationMode(componentDef, component);\n    }\n    return component;\n}\n/**\n * Used to enable lifecycle hooks on the root component.\n *\n * Include this feature when calling `renderComponent` if the root component\n * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\n * be called properly.\n *\n * Example:\n *\n * ```\n * renderComponent(AppComponent, {hostFeatures: [LifecycleHooksFeature]});\n * ```\n */\nfunction LifecycleHooksFeature() {\n    const tNode = getCurrentTNode();\n    ngDevMode && assertDefined(tNode, 'TNode is required');\n    registerPostOrderHooks(getLView()[TVIEW], tNode);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction getSuperType(type) {\n    return Object.getPrototypeOf(type.prototype).constructor;\n}\n/**\n * Merges the definition from a super class to a sub class.\n * @param definition The definition that is a SubClass of another directive of component\n *\n * @codeGenApi\n */\nfunction \u0275\u0275InheritDefinitionFeature(definition) {\n    let superType = getSuperType(definition.type);\n    let shouldInheritFields = true;\n    const inheritanceChain = [definition];\n    while (superType) {\n        let superDef = undefined;\n        if (isComponentDef(definition)) {\n            // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n            superDef = superType.\u0275cmp || superType.\u0275dir;\n        }\n        else {\n            if (superType.\u0275cmp) {\n                throw new RuntimeError(903 /* RuntimeErrorCode.INVALID_INHERITANCE */, ngDevMode &&\n                    `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);\n            }\n            // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n            superDef = superType.\u0275dir;\n        }\n        if (superDef) {\n            if (shouldInheritFields) {\n                inheritanceChain.push(superDef);\n                // Some fields in the definition may be empty, if there were no values to put in them that\n                // would've justified object creation. Unwrap them if necessary.\n                const writeableDef = definition;\n                writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);\n                writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);\n                writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);\n                // Merge hostBindings\n                const superHostBindings = superDef.hostBindings;\n                superHostBindings && inheritHostBindings(definition, superHostBindings);\n                // Merge queries\n                const superViewQuery = superDef.viewQuery;\n                const superContentQueries = superDef.contentQueries;\n                superViewQuery && inheritViewQuery(definition, superViewQuery);\n                superContentQueries && inheritContentQueries(definition, superContentQueries);\n                // Merge inputs and outputs\n                fillProperties(definition.inputs, superDef.inputs);\n                fillProperties(definition.declaredInputs, superDef.declaredInputs);\n                fillProperties(definition.outputs, superDef.outputs);\n                // Merge animations metadata.\n                // If `superDef` is a Component, the `data` field is present (defaults to an empty object).\n                if (isComponentDef(superDef) && superDef.data.animation) {\n                    // If super def is a Component, the `definition` is also a Component, since Directives can\n                    // not inherit Components (we throw an error above and cannot reach this code).\n                    const defData = definition.data;\n                    defData.animation = (defData.animation || []).concat(superDef.data.animation);\n                }\n            }\n            // Run parent features\n            const features = superDef.features;\n            if (features) {\n                for (let i = 0; i < features.length; i++) {\n                    const feature = features[i];\n                    if (feature && feature.ngInherit) {\n                        feature(definition);\n                    }\n                    // If `InheritDefinitionFeature` is a part of the current `superDef`, it means that this\n                    // def already has all the necessary information inherited from its super class(es), so we\n                    // can stop merging fields from super classes. However we need to iterate through the\n                    // prototype chain to look for classes that might contain other \"features\" (like\n                    // NgOnChanges), which we should invoke for the original `definition`. We set the\n                    // `shouldInheritFields` flag to indicate that, essentially skipping fields inheritance\n                    // logic and only invoking functions from the \"features\" list.\n                    if (feature === \u0275\u0275InheritDefinitionFeature) {\n                        shouldInheritFields = false;\n                    }\n                }\n            }\n        }\n        superType = Object.getPrototypeOf(superType);\n    }\n    mergeHostAttrsAcrossInheritance(inheritanceChain);\n}\n/**\n * Merge the `hostAttrs` and `hostVars` from the inherited parent to the base class.\n *\n * @param inheritanceChain A list of `WritableDefs` starting at the top most type and listing\n * sub-types in order. For each type take the `hostAttrs` and `hostVars` and merge it with the child\n * type.\n */\nfunction mergeHostAttrsAcrossInheritance(inheritanceChain) {\n    let hostVars = 0;\n    let hostAttrs = null;\n    // We process the inheritance order from the base to the leaves here.\n    for (let i = inheritanceChain.length - 1; i >= 0; i--) {\n        const def = inheritanceChain[i];\n        // For each `hostVars`, we need to add the superclass amount.\n        def.hostVars = (hostVars += def.hostVars);\n        // for each `hostAttrs` we need to merge it with superclass.\n        def.hostAttrs =\n            mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));\n    }\n}\nfunction maybeUnwrapEmpty(value) {\n    if (value === EMPTY_OBJ) {\n        return {};\n    }\n    else if (value === EMPTY_ARRAY) {\n        return [];\n    }\n    else {\n        return value;\n    }\n}\nfunction inheritViewQuery(definition, superViewQuery) {\n    const prevViewQuery = definition.viewQuery;\n    if (prevViewQuery) {\n        definition.viewQuery = (rf, ctx) => {\n            superViewQuery(rf, ctx);\n            prevViewQuery(rf, ctx);\n        };\n    }\n    else {\n        definition.viewQuery = superViewQuery;\n    }\n}\nfunction inheritContentQueries(definition, superContentQueries) {\n    const prevContentQueries = definition.contentQueries;\n    if (prevContentQueries) {\n        definition.contentQueries = (rf, ctx, directiveIndex) => {\n            superContentQueries(rf, ctx, directiveIndex);\n            prevContentQueries(rf, ctx, directiveIndex);\n        };\n    }\n    else {\n        definition.contentQueries = superContentQueries;\n    }\n}\nfunction inheritHostBindings(definition, superHostBindings) {\n    const prevHostBindings = definition.hostBindings;\n    if (prevHostBindings) {\n        definition.hostBindings = (rf, ctx) => {\n            superHostBindings(rf, ctx);\n            prevHostBindings(rf, ctx);\n        };\n    }\n    else {\n        definition.hostBindings = superHostBindings;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Fields which exist on either directive or component definitions, and need to be copied from\n * parent to child classes by the `\u0275\u0275CopyDefinitionFeature`.\n */\nconst COPY_DIRECTIVE_FIELDS = [\n    // The child class should use the providers of its parent.\n    'providersResolver',\n    // Not listed here are any fields which are handled by the `\u0275\u0275InheritDefinitionFeature`, such\n    // as inputs, outputs, and host binding functions.\n];\n/**\n * Fields which exist only on component definitions, and need to be copied from parent to child\n * classes by the `\u0275\u0275CopyDefinitionFeature`.\n *\n * The type here allows any field of `ComponentDef` which is not also a property of `DirectiveDef`,\n * since those should go in `COPY_DIRECTIVE_FIELDS` above.\n */\nconst COPY_COMPONENT_FIELDS = [\n    // The child class should use the template function of its parent, including all template\n    // semantics.\n    'template',\n    'decls',\n    'consts',\n    'vars',\n    'onPush',\n    'ngContentSelectors',\n    // The child class should use the CSS styles of its parent, including all styling semantics.\n    'styles',\n    'encapsulation',\n    // The child class should be checked by the runtime in the same way as its parent.\n    'schemas',\n];\n/**\n * Copies the fields not handled by the `\u0275\u0275InheritDefinitionFeature` from the supertype of a\n * definition.\n *\n * This exists primarily to support ngcc migration of an existing View Engine pattern, where an\n * entire decorator is inherited from a parent to a child class. When ngcc detects this case, it\n * generates a skeleton definition on the child class, and applies this feature.\n *\n * The `\u0275\u0275CopyDefinitionFeature` then copies any needed fields from the parent class' definition,\n * including things like the component template function.\n *\n * @param definition The definition of a child class which inherits from a parent class with its\n * own definition.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275CopyDefinitionFeature(definition) {\n    let superType = getSuperType(definition.type);\n    let superDef = undefined;\n    if (isComponentDef(definition)) {\n        // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n        superDef = superType.\u0275cmp;\n    }\n    else {\n        // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.\n        superDef = superType.\u0275dir;\n    }\n    // Needed because `definition` fields are readonly.\n    const defAny = definition;\n    // Copy over any fields that apply to either directives or components.\n    for (const field of COPY_DIRECTIVE_FIELDS) {\n        defAny[field] = superDef[field];\n    }\n    if (isComponentDef(superDef)) {\n        // Copy over any component-specific fields.\n        for (const field of COPY_COMPONENT_FIELDS) {\n            defAny[field] = superDef[field];\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _symbolIterator = null;\nfunction getSymbolIterator() {\n    if (!_symbolIterator) {\n        const Symbol = _global$1['Symbol'];\n        if (Symbol && Symbol.iterator) {\n            _symbolIterator = Symbol.iterator;\n        }\n        else {\n            // es6-shim specific logic\n            const keys = Object.getOwnPropertyNames(Map.prototype);\n            for (let i = 0; i < keys.length; ++i) {\n                const key = keys[i];\n                if (key !== 'entries' && key !== 'size' &&\n                    Map.prototype[key] === Map.prototype['entries']) {\n                    _symbolIterator = key;\n                }\n            }\n        }\n    }\n    return _symbolIterator;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction isIterable(obj) {\n    return obj !== null && typeof obj === 'object' && obj[getSymbolIterator()] !== undefined;\n}\nfunction isListLikeIterable(obj) {\n    if (!isJsObject(obj))\n        return false;\n    return Array.isArray(obj) ||\n        (!(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]\n            getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop\n}\nfunction areIterablesEqual(a, b, comparator) {\n    const iterator1 = a[getSymbolIterator()]();\n    const iterator2 = b[getSymbolIterator()]();\n    while (true) {\n        const item1 = iterator1.next();\n        const item2 = iterator2.next();\n        if (item1.done && item2.done)\n            return true;\n        if (item1.done || item2.done)\n            return false;\n        if (!comparator(item1.value, item2.value))\n            return false;\n    }\n}\nfunction iterateListLike(obj, fn) {\n    if (Array.isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n            fn(obj[i]);\n        }\n    }\n    else {\n        const iterator = obj[getSymbolIterator()]();\n        let item;\n        while (!((item = iterator.next()).done)) {\n            fn(item.value);\n        }\n    }\n}\nfunction isJsObject(o) {\n    return o !== null && (typeof o === 'function' || typeof o === 'object');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction devModeEqual(a, b) {\n    const isListLikeIterableA = isListLikeIterable(a);\n    const isListLikeIterableB = isListLikeIterable(b);\n    if (isListLikeIterableA && isListLikeIterableB) {\n        return areIterablesEqual(a, b, devModeEqual);\n    }\n    else {\n        const isAObject = a && (typeof a === 'object' || typeof a === 'function');\n        const isBObject = b && (typeof b === 'object' || typeof b === 'function');\n        if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {\n            return true;\n        }\n        else {\n            return Object.is(a, b);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO(misko): consider inlining\n/** Updates binding and returns the value. */\nfunction updateBinding(lView, bindingIndex, value) {\n    return lView[bindingIndex] = value;\n}\n/** Gets the current binding value. */\nfunction getBinding(lView, bindingIndex) {\n    ngDevMode && assertIndexInRange(lView, bindingIndex);\n    ngDevMode &&\n        assertNotSame(lView[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\n    return lView[bindingIndex];\n}\n/**\n * Updates binding if changed, then returns whether it was updated.\n *\n * This function also checks the `CheckNoChangesMode` and throws if changes are made.\n * Some changes (Objects/iterables) during `CheckNoChangesMode` are exempt to comply with VE\n * behavior.\n *\n * @param lView current `LView`\n * @param bindingIndex The binding in the `LView` to check\n * @param value New value to check against `lView[bindingIndex]`\n * @returns `true` if the bindings has changed. (Throws if binding has changed during\n *          `CheckNoChangesMode`)\n */\nfunction bindingUpdated(lView, bindingIndex, value) {\n    ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n    ngDevMode &&\n        assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);\n    const oldValue = lView[bindingIndex];\n    if (Object.is(oldValue, value)) {\n        return false;\n    }\n    else {\n        if (ngDevMode && isInCheckNoChangesMode()) {\n            // View engine didn't report undefined values as changed on the first checkNoChanges pass\n            // (before the change detection was run).\n            const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : undefined;\n            if (!devModeEqual(oldValueToCompare, value)) {\n                const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);\n                throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName);\n            }\n            // There was a change, but the `devModeEqual` decided that the change is exempt from an error.\n            // For this reason we exit as if no change. The early exit is needed to prevent the changed\n            // value to be written into `LView` (If we would write the new value that we would not see it\n            // as change on next CD.)\n            return false;\n        }\n        lView[bindingIndex] = value;\n        return true;\n    }\n}\n/** Updates 2 bindings if changed, then returns whether either was updated. */\nfunction bindingUpdated2(lView, bindingIndex, exp1, exp2) {\n    const different = bindingUpdated(lView, bindingIndex, exp1);\n    return bindingUpdated(lView, bindingIndex + 1, exp2) || different;\n}\n/** Updates 3 bindings if changed, then returns whether any was updated. */\nfunction bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {\n    const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n    return bindingUpdated(lView, bindingIndex + 2, exp3) || different;\n}\n/** Updates 4 bindings if changed, then returns whether any was updated. */\nfunction bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {\n    const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n    return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Updates the value of or removes a bound attribute on an Element.\n *\n * Used in the case of `[attr.title]=\"value\"`\n *\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n * @param namespace Optional namespace to use when setting the attribute.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275attribute(name, value, sanitizer, namespace) {\n    const lView = getLView();\n    const bindingIndex = nextBindingIndex();\n    if (bindingUpdated(lView, bindingIndex, value)) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);\n        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, 'attr.' + name, bindingIndex);\n    }\n    return \u0275\u0275attribute;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nfunction interpolationV(lView, values) {\n    ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n    ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n    let isBindingUpdated = false;\n    let bindingIndex = getBindingIndex();\n    for (let i = 1; i < values.length; i += 2) {\n        // Check if bindings (odd indexes) have changed\n        isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;\n    }\n    setBindingIndex(bindingIndex);\n    if (!isBindingUpdated) {\n        return NO_CHANGE;\n    }\n    // Build the updated content\n    let content = values[0];\n    for (let i = 1; i < values.length; i += 2) {\n        content += renderStringify(values[i]) + values[i + 1];\n    }\n    return content;\n}\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nfunction interpolation1(lView, prefix, v0, suffix) {\n    const different = bindingUpdated(lView, nextBindingIndex(), v0);\n    return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 2 expressions.\n */\nfunction interpolation2(lView, prefix, v0, i0, v1, suffix) {\n    const bindingIndex = getBindingIndex();\n    const different = bindingUpdated2(lView, bindingIndex, v0, v1);\n    incrementBindingIndex(2);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 3 expressions.\n */\nfunction interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {\n    const bindingIndex = getBindingIndex();\n    const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);\n    incrementBindingIndex(3);\n    return different ?\n        prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix :\n        NO_CHANGE;\n}\n/**\n * Create an interpolation binding with 4 expressions.\n */\nfunction interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n    const bindingIndex = getBindingIndex();\n    const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    incrementBindingIndex(4);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n        renderStringify(v2) + i2 + renderStringify(v3) + suffix :\n        NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 5 expressions.\n */\nfunction interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n    const bindingIndex = getBindingIndex();\n    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    different = bindingUpdated(lView, bindingIndex + 4, v4) || different;\n    incrementBindingIndex(5);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n        renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix :\n        NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 6 expressions.\n */\nfunction interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n    const bindingIndex = getBindingIndex();\n    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;\n    incrementBindingIndex(6);\n    return different ?\n        prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\n            renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix :\n        NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 7 expressions.\n */\nfunction interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n    const bindingIndex = getBindingIndex();\n    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;\n    incrementBindingIndex(7);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n        renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 +\n        renderStringify(v5) + i5 + renderStringify(v6) + suffix :\n        NO_CHANGE;\n}\n/**\n * Creates an interpolation binding with 8 expressions.\n */\nfunction interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n    const bindingIndex = getBindingIndex();\n    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n    different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;\n    incrementBindingIndex(8);\n    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n        renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 +\n        renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix :\n        NO_CHANGE;\n}\n\n/**\n *\n * Update an interpolated attribute on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275attributeInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275attributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 1, prefix, suffix);\n    }\n    return \u0275\u0275attributeInterpolate1;\n}\n/**\n *\n * Update an interpolated attribute on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275attributeInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275attributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 2, prefix, i0, suffix);\n    }\n    return \u0275\u0275attributeInterpolate2;\n}\n/**\n *\n * Update an interpolated attribute on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275attributeInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275attributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n    }\n    return \u0275\u0275attributeInterpolate3;\n}\n/**\n *\n * Update an interpolated attribute on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275attributeInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275attributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n    }\n    return \u0275\u0275attributeInterpolate4;\n}\n/**\n *\n * Update an interpolated attribute on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275attributeInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275attributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n    }\n    return \u0275\u0275attributeInterpolate5;\n}\n/**\n *\n * Update an interpolated attribute on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275attributeInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275attributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n    }\n    return \u0275\u0275attributeInterpolate6;\n}\n/**\n *\n * Update an interpolated attribute on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275attributeInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275attributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);\n    }\n    return \u0275\u0275attributeInterpolate7;\n}\n/**\n *\n * Update an interpolated attribute on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div attr.title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275attributeInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param attrName The name of the attribute to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275attributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n        ngDevMode &&\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);\n    }\n    return \u0275\u0275attributeInterpolate8;\n}\n/**\n * Update an interpolated attribute on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275attributeInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param attrName The name of the attribute to update.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275attributeInterpolateV(attrName, values, sanitizer, namespace) {\n    const lView = getLView();\n    const interpolated = interpolationV(lView, values);\n    if (interpolated !== NO_CHANGE) {\n        const tNode = getSelectedTNode();\n        elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);\n        if (ngDevMode) {\n            const interpolationInBetween = [values[0]]; // prefix\n            for (let i = 2; i < values.length; i += 2) {\n                interpolationInBetween.push(values[i]);\n            }\n            storePropertyBindingMetadata(getTView().data, tNode, 'attr.' + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n        }\n    }\n    return \u0275\u0275attributeInterpolateV;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component.\n *\n * @param component The component which the change detection should be performed on.\n */\nfunction detectChanges(component) {\n    const view = getComponentViewByInstance(component);\n    detectChangesInternal(view[TVIEW], view, component);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) {\n    ngDevMode && assertFirstCreatePass(tView);\n    ngDevMode && ngDevMode.firstCreatePass++;\n    const tViewConsts = tView.consts;\n    // TODO(pk): refactor getOrCreateTNode to have the \"create\" only version\n    const tNode = getOrCreateTNode(tView, index, 4 /* TNodeType.Container */, tagName || null, getConstant(tViewConsts, attrsIndex));\n    resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));\n    registerPostOrderHooks(tView, tNode);\n    const embeddedTView = tNode.tViews = createTView(2 /* TViewType.Embedded */, tNode, templateFn, decls, vars, tView.directiveRegistry, tView.pipeRegistry, null, tView.schemas, tViewConsts);\n    if (tView.queries !== null) {\n        tView.queries.template(tView, tNode);\n        embeddedTView.queries = tView.queries.embeddedTView(tNode);\n    }\n    return tNode;\n}\n/**\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param decls The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrsIndex Index of template attributes in the `consts` array.\n * @param localRefs Index of the local references in the `consts` array.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275template(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {\n    const lView = getLView();\n    const tView = getTView();\n    const adjustedIndex = index + HEADER_OFFSET;\n    const tNode = tView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) :\n        tView.data[adjustedIndex];\n    setCurrentTNode(tNode, false);\n    const comment = lView[RENDERER].createComment(ngDevMode ? 'container' : '');\n    appendChild(tView, lView, comment, tNode);\n    attachPatchData(comment, lView);\n    addToViewTree(lView, lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode));\n    if (isDirectiveHost(tNode)) {\n        createDirectivesInstances(tView, lView, tNode);\n    }\n    if (localRefsIndex != null) {\n        saveResolvedLocalsInData(lView, tNode, localRefExtractor);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Store a value in the `data` at a given `index`. */\nfunction store(tView, lView, index, value) {\n    // We don't store any static data for local variables, so the first time\n    // we see the template, we should store as null to avoid a sparse array\n    if (index >= tView.data.length) {\n        tView.data[index] = null;\n        tView.blueprint[index] = null;\n    }\n    lView[index] = value;\n}\n/**\n * Retrieves a local reference from the current contextViewData.\n *\n * If the reference to retrieve is in a parent view, this instruction is used in conjunction\n * with a nextContext() call, which walks up the tree and updates the contextViewData instance.\n *\n * @param index The index of the local ref in contextViewData.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275reference(index) {\n    const contextLView = getContextLView();\n    return load(contextLView, HEADER_OFFSET + index);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Update a property on a selected element.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nfunction \u0275\u0275property(propName, value, sanitizer) {\n    const lView = getLView();\n    const bindingIndex = nextBindingIndex();\n    if (bindingUpdated(lView, bindingIndex, value)) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);\n        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n    }\n    return \u0275\u0275property;\n}\n/**\n * Given `<div style=\"...\" my-dir>` and `MyDir` with `@Input('style')` we need to write to\n * directive input.\n */\nfunction setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {\n    const inputs = tNode.inputs;\n    const property = isClassBased ? 'class' : 'style';\n    // We support both 'class' and `className` hence the fallback.\n    setInputsForProperty(tView, lView, inputs[property], property, value);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction elementStartFirstCreatePass(index, tView, lView, native, name, attrsIndex, localRefsIndex) {\n    ngDevMode && assertFirstCreatePass(tView);\n    ngDevMode && ngDevMode.firstCreatePass++;\n    const tViewConsts = tView.consts;\n    const attrs = getConstant(tViewConsts, attrsIndex);\n    const tNode = getOrCreateTNode(tView, index, 2 /* TNodeType.Element */, name, attrs);\n    const hasDirectives = resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));\n    if (ngDevMode) {\n        validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);\n    }\n    if (tNode.attrs !== null) {\n        computeStaticStyling(tNode, tNode.attrs, false);\n    }\n    if (tNode.mergedAttrs !== null) {\n        computeStaticStyling(tNode, tNode.mergedAttrs, true);\n    }\n    if (tView.queries !== null) {\n        tView.queries.elementStart(tView, tNode);\n    }\n    return tNode;\n}\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n *\n * @codeGenApi\n */\nfunction \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex) {\n    const lView = getLView();\n    const tView = getTView();\n    const adjustedIndex = HEADER_OFFSET + index;\n    ngDevMode &&\n        assertEqual(getBindingIndex(), tView.bindingStartIndex, 'elements should be created before any bindings');\n    ngDevMode && assertIndexInRange(lView, adjustedIndex);\n    const renderer = lView[RENDERER];\n    const native = lView[adjustedIndex] = createElementNode(renderer, name, getNamespace$1());\n    const tNode = tView.firstCreatePass ?\n        elementStartFirstCreatePass(adjustedIndex, tView, lView, native, name, attrsIndex, localRefsIndex) :\n        tView.data[adjustedIndex];\n    setCurrentTNode(tNode, true);\n    const mergedAttrs = tNode.mergedAttrs;\n    if (mergedAttrs !== null) {\n        setUpAttributes(renderer, native, mergedAttrs);\n    }\n    const classes = tNode.classes;\n    if (classes !== null) {\n        writeDirectClass(renderer, native, classes);\n    }\n    const styles = tNode.styles;\n    if (styles !== null) {\n        writeDirectStyle(renderer, native, styles);\n    }\n    if ((tNode.flags & 64 /* TNodeFlags.isDetached */) !== 64 /* TNodeFlags.isDetached */) {\n        // In the i18n case, the translation may have removed this element, so only add it if it is not\n        // detached. See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n        appendChild(tView, lView, native, tNode);\n    }\n    // any immediate children of a component or template container must be pre-emptively\n    // monkey-patched with the component view data so that the element can be inspected\n    // later on using any element discovery utility methods (see `element_discovery.ts`)\n    if (getElementDepthCount() === 0) {\n        attachPatchData(native, lView);\n    }\n    increaseElementDepthCount();\n    if (isDirectiveHost(tNode)) {\n        createDirectivesInstances(tView, lView, tNode);\n        executeContentQueries(tView, tNode, lView);\n    }\n    if (localRefsIndex !== null) {\n        saveResolvedLocalsInData(lView, tNode);\n    }\n    return \u0275\u0275elementStart;\n}\n/**\n * Mark the end of the element.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275elementEnd() {\n    let currentTNode = getCurrentTNode();\n    ngDevMode && assertDefined(currentTNode, 'No parent node to close.');\n    if (isCurrentTNodeParent()) {\n        setCurrentTNodeAsNotParent();\n    }\n    else {\n        ngDevMode && assertHasParent(getCurrentTNode());\n        currentTNode = currentTNode.parent;\n        setCurrentTNode(currentTNode, false);\n    }\n    const tNode = currentTNode;\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */);\n    decreaseElementDepthCount();\n    const tView = getTView();\n    if (tView.firstCreatePass) {\n        registerPostOrderHooks(tView, currentTNode);\n        if (isContentQueryHost(currentTNode)) {\n            tView.queries.elementEnd(currentTNode);\n        }\n    }\n    if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {\n        setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);\n    }\n    if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {\n        setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);\n    }\n    return \u0275\u0275elementEnd;\n}\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275element(index, name, attrsIndex, localRefsIndex) {\n    \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex);\n    \u0275\u0275elementEnd();\n    return \u0275\u0275element;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {\n    ngDevMode && ngDevMode.firstCreatePass++;\n    const tViewConsts = tView.consts;\n    const attrs = getConstant(tViewConsts, attrsIndex);\n    const tNode = getOrCreateTNode(tView, index, 8 /* TNodeType.ElementContainer */, 'ng-container', attrs);\n    // While ng-container doesn't necessarily support styling, we use the style context to identify\n    // and execute directives on the ng-container.\n    if (attrs !== null) {\n        computeStaticStyling(tNode, attrs, true);\n    }\n    const localRefs = getConstant(tViewConsts, localRefsIndex);\n    resolveDirectives(tView, lView, tNode, localRefs);\n    if (tView.queries !== null) {\n        tView.queries.elementStart(tView, tNode);\n    }\n    return tNode;\n}\n/**\n * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.\n * The instruction must later be followed by `elementContainerEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * Even if this instruction accepts a set of attributes no actual attribute values are propagated to\n * the DOM (as a comment node can't have attributes). Attributes are here only for directive\n * matching purposes and setting initial inputs of directives.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex) {\n    const lView = getLView();\n    const tView = getTView();\n    const adjustedIndex = index + HEADER_OFFSET;\n    ngDevMode && assertIndexInRange(lView, adjustedIndex);\n    ngDevMode &&\n        assertEqual(getBindingIndex(), tView.bindingStartIndex, 'element containers should be created before any bindings');\n    const tNode = tView.firstCreatePass ?\n        elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) :\n        tView.data[adjustedIndex];\n    setCurrentTNode(tNode, true);\n    ngDevMode && ngDevMode.rendererCreateComment++;\n    const native = lView[adjustedIndex] =\n        lView[RENDERER].createComment(ngDevMode ? 'ng-container' : '');\n    appendChild(tView, lView, native, tNode);\n    attachPatchData(native, lView);\n    if (isDirectiveHost(tNode)) {\n        createDirectivesInstances(tView, lView, tNode);\n        executeContentQueries(tView, tNode, lView);\n    }\n    if (localRefsIndex != null) {\n        saveResolvedLocalsInData(lView, tNode);\n    }\n    return \u0275\u0275elementContainerStart;\n}\n/**\n * Mark the end of the <ng-container>.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275elementContainerEnd() {\n    let currentTNode = getCurrentTNode();\n    const tView = getTView();\n    if (isCurrentTNodeParent()) {\n        setCurrentTNodeAsNotParent();\n    }\n    else {\n        ngDevMode && assertHasParent(currentTNode);\n        currentTNode = currentTNode.parent;\n        setCurrentTNode(currentTNode, false);\n    }\n    ngDevMode && assertTNodeType(currentTNode, 8 /* TNodeType.ElementContainer */);\n    if (tView.firstCreatePass) {\n        registerPostOrderHooks(tView, currentTNode);\n        if (isContentQueryHost(currentTNode)) {\n            tView.queries.elementEnd(currentTNode);\n        }\n    }\n    return \u0275\u0275elementContainerEnd;\n}\n/**\n * Creates an empty logical container using {@link elementContainerStart}\n * and {@link elementContainerEnd}\n *\n * @param index Index of the element in the LView array\n * @param attrsIndex Index of the container attributes in the `consts` array.\n * @param localRefsIndex Index of the container's local references in the `consts` array.\n * @returns This function returns itself so that it may be chained.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275elementContainer(index, attrsIndex, localRefsIndex) {\n    \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex);\n    \u0275\u0275elementContainerEnd();\n    return \u0275\u0275elementContainer;\n}\n\n/**\n * Returns the current OpaqueViewState instance.\n *\n * Used in conjunction with the restoreView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275getCurrentView() {\n    return getLView();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Determine if the argument is shaped like a Promise\n */\nfunction isPromise(obj) {\n    // allow any Promise/A+ compliant thenable.\n    // It's up to the caller to ensure that obj.then conforms to the spec\n    return !!obj && typeof obj.then === 'function';\n}\n/**\n * Determine if the argument is a Subscribable\n */\nfunction isSubscribable(obj) {\n    return !!obj && typeof obj.subscribe === 'function';\n}\n/**\n * Determine if the argument is an Observable\n *\n * Strictly this tests that the `obj` is `Subscribable`, since `Observable`\n * types need additional methods, such as `lift()`. But it is adequate for our\n * needs since within the Angular framework code we only ever need to use the\n * `subscribe()` method, and RxJS has mechanisms to wrap `Subscribable` objects\n * into `Observable` as needed.\n */\nconst isObservable = isSubscribable;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nfunction \u0275\u0275listener(eventName, listenerFn, useCapture, eventTargetResolver) {\n    const lView = getLView();\n    const tView = getTView();\n    const tNode = getCurrentTNode();\n    listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, !!useCapture, eventTargetResolver);\n    return \u0275\u0275listener;\n}\n/**\n * Registers a synthetic host listener (e.g. `(@foo.start)`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host listener (e.g. `@HostListener('@foo.start')`) properly gets rendered\n * in the component's renderer. Normally all host listeners are evaluated with the\n * parent component's renderer, but, in the case of animation @triggers, they need\n * to be evaluated with the sub component's renderer (because that's where the\n * animation triggers are defined).\n *\n * Do not use this instruction as a replacement for `listener`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nfunction \u0275\u0275syntheticHostListener(eventName, listenerFn) {\n    const tNode = getCurrentTNode();\n    const lView = getLView();\n    const tView = getTView();\n    const currentDef = getCurrentDirectiveDef(tView.data);\n    const renderer = loadComponentRenderer(currentDef, tNode, lView);\n    listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, false);\n    return \u0275\u0275syntheticHostListener;\n}\n/**\n * A utility function that checks if a given element has already an event handler registered for an\n * event with a specified name. The TView.cleanup data structure is used to find out which events\n * are registered for a given element.\n */\nfunction findExistingListener(tView, lView, eventName, tNodeIdx) {\n    const tCleanup = tView.cleanup;\n    if (tCleanup != null) {\n        for (let i = 0; i < tCleanup.length - 1; i += 2) {\n            const cleanupEventName = tCleanup[i];\n            if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {\n                // We have found a matching event name on the same node but it might not have been\n                // registered yet, so we must explicitly verify entries in the LView cleanup data\n                // structures.\n                const lCleanup = lView[CLEANUP];\n                const listenerIdxInLCleanup = tCleanup[i + 2];\n                return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;\n            }\n            // TView.cleanup can have a mix of 4-elements entries (for event handler cleanups) or\n            // 2-element entries (for directive and queries destroy hooks). As such we can encounter\n            // blocks of 4 or 2 items in the tView.cleanup and this is why we iterate over 2 elements\n            // first and jump another 2 elements if we detect listeners cleanup (4 elements). Also check\n            // documentation of TView.cleanup for more details of this data structure layout.\n            if (typeof cleanupEventName === 'string') {\n                i += 2;\n            }\n        }\n    }\n    return null;\n}\nfunction listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, useCapture, eventTargetResolver) {\n    const isTNodeDirectiveHost = isDirectiveHost(tNode);\n    const firstCreatePass = tView.firstCreatePass;\n    const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);\n    const context = lView[CONTEXT];\n    // When the \u0275\u0275listener instruction was generated and is executed we know that there is either a\n    // native listener or a directive output on this element. As such we we know that we will have to\n    // register a listener and store its cleanup function on LView.\n    const lCleanup = getOrCreateLViewCleanup(lView);\n    ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */);\n    let processOutputs = true;\n    // Adding a native event listener is applicable when:\n    // - The corresponding TNode represents a DOM element.\n    // - The event target has a resolver (usually resulting in a global object,\n    //   such as `window` or `document`).\n    if ((tNode.type & 3 /* TNodeType.AnyRNode */) || eventTargetResolver) {\n        const native = getNativeByTNode(tNode, lView);\n        const target = eventTargetResolver ? eventTargetResolver(native) : native;\n        const lCleanupIndex = lCleanup.length;\n        const idxOrTargetGetter = eventTargetResolver ?\n            (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) :\n            tNode.index;\n        // In order to match current behavior, native DOM event listeners must be added for all\n        // events (including outputs).\n        // There might be cases where multiple directives on the same element try to register an event\n        // handler function for the same event. In this situation we want to avoid registration of\n        // several native listeners as each registration would be intercepted by NgZone and\n        // trigger change detection. This would mean that a single user action would result in several\n        // change detections being invoked. To avoid this situation we want to have only one call to\n        // native handler registration (for the same element and same type of event).\n        //\n        // In order to have just one native event handler in presence of multiple handler functions,\n        // we just register a first handler function as a native event listener and then chain\n        // (coalesce) other handler functions on top of the first native handler function.\n        let existingListener = null;\n        // Please note that the coalescing described here doesn't happen for events specifying an\n        // alternative target (ex. (document:click)) - this is to keep backward compatibility with the\n        // view engine.\n        // Also, we don't have to search for existing listeners is there are no directives\n        // matching on a given node as we can't register multiple event handlers for the same event in\n        // a template (this would mean having duplicate attributes).\n        if (!eventTargetResolver && isTNodeDirectiveHost) {\n            existingListener = findExistingListener(tView, lView, eventName, tNode.index);\n        }\n        if (existingListener !== null) {\n            // Attach a new listener to coalesced listeners list, maintaining the order in which\n            // listeners are registered. For performance reasons, we keep a reference to the last\n            // listener in that list (in `__ngLastListenerFn__` field), so we can avoid going through\n            // the entire set each time we need to add a new listener.\n            const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;\n            lastListenerFn.__ngNextListenerFn__ = listenerFn;\n            existingListener.__ngLastListenerFn__ = listenerFn;\n            processOutputs = false;\n        }\n        else {\n            listenerFn = wrapListener(tNode, lView, context, listenerFn, false /** preventDefault */);\n            const cleanupFn = renderer.listen(target, eventName, listenerFn);\n            ngDevMode && ngDevMode.rendererAddEventListener++;\n            lCleanup.push(listenerFn, cleanupFn);\n            tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);\n        }\n    }\n    else {\n        // Even if there is no native listener to add, we still need to wrap the listener so that OnPush\n        // ancestors are marked dirty when an event occurs.\n        listenerFn = wrapListener(tNode, lView, context, listenerFn, false /** preventDefault */);\n    }\n    // subscribe to directive outputs\n    const outputs = tNode.outputs;\n    let props;\n    if (processOutputs && outputs !== null && (props = outputs[eventName])) {\n        const propsLength = props.length;\n        if (propsLength) {\n            for (let i = 0; i < propsLength; i += 2) {\n                const index = props[i];\n                ngDevMode && assertIndexInRange(lView, index);\n                const minifiedName = props[i + 1];\n                const directiveInstance = lView[index];\n                const output = directiveInstance[minifiedName];\n                if (ngDevMode && !isObservable(output)) {\n                    throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);\n                }\n                const subscription = output.subscribe(listenerFn);\n                const idx = lCleanup.length;\n                lCleanup.push(listenerFn, subscription);\n                tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));\n            }\n        }\n    }\n}\nfunction executeListenerWithErrorHandling(lView, context, listenerFn, e) {\n    try {\n        profiler(6 /* ProfilerEvent.OutputStart */, context, listenerFn);\n        // Only explicitly returning false from a listener should preventDefault\n        return listenerFn(e) !== false;\n    }\n    catch (error) {\n        handleError(lView, error);\n        return false;\n    }\n    finally {\n        profiler(7 /* ProfilerEvent.OutputEnd */, context, listenerFn);\n    }\n}\n/**\n * Wraps an event listener with a function that marks ancestors dirty and prevents default behavior,\n * if applicable.\n *\n * @param tNode The TNode associated with this listener\n * @param lView The LView that contains this listener\n * @param listenerFn The listener function to call\n * @param wrapWithPreventDefault Whether or not to prevent default behavior\n * (the procedural renderer does this already, so in those cases, we should skip)\n */\nfunction wrapListener(tNode, lView, context, listenerFn, wrapWithPreventDefault) {\n    // Note: we are performing most of the work in the listener function itself\n    // to optimize listener registration.\n    return function wrapListenerIn_markDirtyAndPreventDefault(e) {\n        // Ivy uses `Function` as a special token that allows us to unwrap the function\n        // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`.\n        if (e === Function) {\n            return listenerFn;\n        }\n        // In order to be backwards compatible with View Engine, events on component host nodes\n        // must also mark the component view itself dirty (i.e. the view that it owns).\n        const startView = tNode.flags & 2 /* TNodeFlags.isComponentHost */ ?\n            getComponentLViewByIndex(tNode.index, lView) :\n            lView;\n        markViewDirty(startView);\n        let result = executeListenerWithErrorHandling(lView, context, listenerFn, e);\n        // A just-invoked listener function might have coalesced listeners so we need to check for\n        // their presence and invoke as needed.\n        let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;\n        while (nextListenerFn) {\n            // We should prevent default if any of the listeners explicitly return false\n            result = executeListenerWithErrorHandling(lView, context, nextListenerFn, e) && result;\n            nextListenerFn = nextListenerFn.__ngNextListenerFn__;\n        }\n        if (wrapWithPreventDefault && result === false) {\n            e.preventDefault();\n            // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\n            e.returnValue = false;\n        }\n        return result;\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n *\n * @codeGenApi\n */\nfunction \u0275\u0275nextContext(level = 1) {\n    return nextContextImpl(level);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Checks a given node against matching projection slots and returns the\n * determined slot index. Returns \"null\" if no slot matched the given node.\n *\n * This function takes into account the parsed ngProjectAs selector from the\n * node's attributes. If present, it will check whether the ngProjectAs selector\n * matches any of the projection slot selectors.\n */\nfunction matchingProjectionSlotIndex(tNode, projectionSlots) {\n    let wildcardNgContentIndex = null;\n    const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n    for (let i = 0; i < projectionSlots.length; i++) {\n        const slotValue = projectionSlots[i];\n        // The last wildcard projection slot should match all nodes which aren't matching\n        // any selector. This is necessary to be backwards compatible with view engine.\n        if (slotValue === '*') {\n            wildcardNgContentIndex = i;\n            continue;\n        }\n        // If we ran into an `ngProjectAs` attribute, we should match its parsed selector\n        // to the list of selectors, otherwise we fall back to matching against the node.\n        if (ngProjectAsAttrVal === null ?\n            isNodeMatchingSelectorList(tNode, slotValue, /* isProjectionMode */ true) :\n            isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {\n            return i; // first matching selector \"captures\" a given node\n        }\n    }\n    return wildcardNgContentIndex;\n}\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param projectionSlots? A collection of projection slots. A projection slot can be based\n *        on a parsed CSS selectors or set to the wildcard selector (\"*\") in order to match\n *        all nodes which do not match any selector. If not specified, a single wildcard\n *        selector projection slot will be defined.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275projectionDef(projectionSlots) {\n    const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];\n    if (!componentNode.projection) {\n        // If no explicit projection slots are defined, fall back to a single\n        // projection slot with the wildcard selector.\n        const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;\n        const projectionHeads = componentNode.projection =\n            newArray(numProjectionSlots, null);\n        const tails = projectionHeads.slice();\n        let componentChild = componentNode.child;\n        while (componentChild !== null) {\n            const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;\n            if (slotIndex !== null) {\n                if (tails[slotIndex]) {\n                    tails[slotIndex].projectionNext = componentChild;\n                }\n                else {\n                    projectionHeads[slotIndex] = componentChild;\n                }\n                tails[slotIndex] = componentChild;\n            }\n            componentChild = componentChild.next;\n        }\n    }\n}\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n *\n * @codeGenApi\n */\nfunction \u0275\u0275projection(nodeIndex, selectorIndex = 0, attrs) {\n    const lView = getLView();\n    const tView = getTView();\n    const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16 /* TNodeType.Projection */, null, attrs || null);\n    // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\n    if (tProjectionNode.projection === null)\n        tProjectionNode.projection = selectorIndex;\n    // `<ng-content>` has no content\n    setCurrentTNodeAsNotParent();\n    if ((tProjectionNode.flags & 64 /* TNodeFlags.isDetached */) !== 64 /* TNodeFlags.isDetached */) {\n        // re-distribution of projectable nodes is stored on a component's view level\n        applyProjection(tView, lView, tProjectionNode);\n    }\n}\n\n/**\n *\n * Update an interpolated property on an element with a lone bound value\n *\n * Used when the value passed to a property has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div title=\"{{v0}}\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275propertyInterpolate('title', v0);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275propertyInterpolate(propName, v0, sanitizer) {\n    \u0275\u0275propertyInterpolate1(propName, '', v0, '', sanitizer);\n    return \u0275\u0275propertyInterpolate;\n}\n/**\n *\n * Update an interpolated property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275propertyInterpolate1('title', 'prefix', v0, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275propertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);\n    }\n    return \u0275\u0275propertyInterpolate1;\n}\n/**\n *\n * Update an interpolated property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275propertyInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275propertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);\n    }\n    return \u0275\u0275propertyInterpolate2;\n}\n/**\n *\n * Update an interpolated property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275propertyInterpolate3(\n * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275propertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n    }\n    return \u0275\u0275propertyInterpolate3;\n}\n/**\n *\n * Update an interpolated property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275propertyInterpolate4(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275propertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n    }\n    return \u0275\u0275propertyInterpolate4;\n}\n/**\n *\n * Update an interpolated property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275propertyInterpolate5(\n * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275propertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n    }\n    return \u0275\u0275propertyInterpolate5;\n}\n/**\n *\n * Update an interpolated property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275propertyInterpolate6(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275propertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n    }\n    return \u0275\u0275propertyInterpolate6;\n}\n/**\n *\n * Update an interpolated property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275propertyInterpolate7(\n *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275propertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);\n    }\n    return \u0275\u0275propertyInterpolate7;\n}\n/**\n *\n * Update an interpolated property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275propertyInterpolate8(\n *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275propertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        ngDevMode &&\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);\n    }\n    return \u0275\u0275propertyInterpolate8;\n}\n/**\n * Update an interpolated property on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  title=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is::\n *\n * ```ts\n * \u0275\u0275propertyInterpolateV(\n *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled.\n *\n * @param propName The name of the property to update.\n * @param values The collection of values and the strings in between those values, beginning with a\n * string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param sanitizer An optional sanitizer function\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275propertyInterpolateV(propName, values, sanitizer) {\n    const lView = getLView();\n    const interpolatedValue = interpolationV(lView, values);\n    if (interpolatedValue !== NO_CHANGE) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n        if (ngDevMode) {\n            const interpolationInBetween = [values[0]]; // prefix\n            for (let i = 2; i < values.length; i += 2) {\n                interpolationInBetween.push(values[i]);\n            }\n            storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n        }\n    }\n    return \u0275\u0275propertyInterpolateV;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * NOTE: The word `styling` is used interchangeably as style or class styling.\n *\n * This file contains code to link styling instructions together so that they can be replayed in\n * priority order. The file exists because Ivy styling instruction execution order does not match\n * that of the priority order. The purpose of this code is to create a linked list so that the\n * instructions can be traversed in priority order when computing the styles.\n *\n * Assume we are dealing with the following code:\n * ```\n * @Component({\n *   template: `\n *     <my-cmp [style]=\" {color: '#001'} \"\n *             [style.color]=\" #002 \"\n *             dir-style-color-1\n *             dir-style-color-2> `\n * })\n * class ExampleComponent {\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `\u0275\u0275styleProp` is after `\u0275\u0275styleMap`\n *     \u0275\u0275styleMap({color: '#001'});\n *     \u0275\u0275styleProp('color', '#002');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-1]',\n * })\n * class Style1Directive {\n *   @HostBinding('style') style = {color: '#005'};\n *   @HostBinding('style.color') color = '#006';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `\u0275\u0275styleProp` is after `\u0275\u0275styleMap`\n *     \u0275\u0275styleMap({color: '#005'});\n *     \u0275\u0275styleProp('color', '#006');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-2]',\n * })\n * class Style2Directive {\n *   @HostBinding('style') style = {color: '#007'};\n *   @HostBinding('style.color') color = '#008';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `\u0275\u0275styleProp` is after `\u0275\u0275styleMap`\n *     \u0275\u0275styleMap({color: '#007'});\n *     \u0275\u0275styleProp('color', '#008');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `my-cmp',\n * })\n * class MyComponent {\n *   @HostBinding('style') style = {color: '#003'};\n *   @HostBinding('style.color') color = '#004';\n *\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `\u0275\u0275styleProp` is after `\u0275\u0275styleMap`\n *     \u0275\u0275styleMap({color: '#003'});\n *     \u0275\u0275styleProp('color', '#004');\n *     ...\n *   }\n * }\n * ```\n *\n * The Order of instruction execution is:\n *\n * NOTE: the comment binding location is for illustrative purposes only.\n *\n * ```\n * // Template: (ExampleComponent)\n *     \u0275\u0275styleMap({color: '#001'});   // Binding index: 10\n *     \u0275\u0275styleProp('color', '#002');  // Binding index: 12\n * // MyComponent\n *     \u0275\u0275styleMap({color: '#003'});   // Binding index: 20\n *     \u0275\u0275styleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     \u0275\u0275styleMap({color: '#005'});   // Binding index: 24\n *     \u0275\u0275styleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     \u0275\u0275styleMap({color: '#007'});   // Binding index: 28\n *     \u0275\u0275styleProp('color', '#008');  // Binding index: 30\n * ```\n *\n * The correct priority order of concatenation is:\n *\n * ```\n * // MyComponent\n *     \u0275\u0275styleMap({color: '#003'});   // Binding index: 20\n *     \u0275\u0275styleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     \u0275\u0275styleMap({color: '#005'});   // Binding index: 24\n *     \u0275\u0275styleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     \u0275\u0275styleMap({color: '#007'});   // Binding index: 28\n *     \u0275\u0275styleProp('color', '#008');  // Binding index: 30\n * // Template: (ExampleComponent)\n *     \u0275\u0275styleMap({color: '#001'});   // Binding index: 10\n *     \u0275\u0275styleProp('color', '#002');  // Binding index: 12\n * ```\n *\n * What color should be rendered?\n *\n * Once the items are correctly sorted in the list, the answer is simply the last item in the\n * concatenation list which is `#002`.\n *\n * To do so we keep a linked list of all of the bindings which pertain to this element.\n * Notice that the bindings are inserted in the order of execution, but the `TView.data` allows\n * us to traverse them in the order of priority.\n *\n * |Idx|`TView.data`|`LView`          | Notes\n * |---|------------|-----------------|--------------\n * |...|            |                 |\n * |10 |`null`      |`{color: '#001'}`| `\u0275\u0275styleMap('color', {color: '#001'})`\n * |11 |`30 | 12`   | ...             |\n * |12 |`color`     |`'#002'`         | `\u0275\u0275styleProp('color', '#002')`\n * |13 |`10 | 0`    | ...             |\n * |...|            |                 |\n * |20 |`null`      |`{color: '#003'}`| `\u0275\u0275styleMap('color', {color: '#003'})`\n * |21 |`0 | 22`    | ...             |\n * |22 |`color`     |`'#004'`         | `\u0275\u0275styleProp('color', '#004')`\n * |23 |`20 | 24`   | ...             |\n * |24 |`null`      |`{color: '#005'}`| `\u0275\u0275styleMap('color', {color: '#005'})`\n * |25 |`22 | 26`   | ...             |\n * |26 |`color`     |`'#006'`         | `\u0275\u0275styleProp('color', '#006')`\n * |27 |`24 | 28`   | ...             |\n * |28 |`null`      |`{color: '#007'}`| `\u0275\u0275styleMap('color', {color: '#007'})`\n * |29 |`26 | 30`   | ...             |\n * |30 |`color`     |`'#008'`         | `\u0275\u0275styleProp('color', '#008')`\n * |31 |`28 | 10`   | ...             |\n *\n * The above data structure allows us to re-concatenate the styling no matter which data binding\n * changes.\n *\n * NOTE: in addition to keeping track of next/previous index the `TView.data` also stores prev/next\n * duplicate bit. The duplicate bit if true says there either is a binding with the same name or\n * there is a map (which may contain the name). This information is useful in knowing if other\n * styles with higher priority need to be searched for overwrites.\n *\n * NOTE: See `should support example in 'tnode_linked_list.ts' documentation` in\n * `tnode_linked_list_spec.ts` for working example.\n */\nlet __unused_const_as_closure_does_not_like_standalone_comment_blocks__;\n/**\n * Insert new `tStyleValue` at `TData` and link existing style bindings such that we maintain linked\n * list of styles and compute the duplicate flag.\n *\n * Note: this function is executed during `firstUpdatePass` only to populate the `TView.data`.\n *\n * The function works by keeping track of `tStylingRange` which contains two pointers pointing to\n * the head/tail of the template portion of the styles.\n *  - if `isHost === false` (we are template) then insertion is at tail of `TStylingRange`\n *  - if `isHost === true` (we are host binding) then insertion is at head of `TStylingRange`\n *\n * @param tData The `TData` to insert into.\n * @param tNode `TNode` associated with the styling element.\n * @param tStylingKey See `TStylingKey`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isHostBinding `true` if the insertion is for a `hostBinding`. (insertion is in front of\n *               template.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\nfunction insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {\n    ngDevMode && assertFirstUpdatePass(getTView());\n    let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;\n    let tmplHead = getTStylingRangePrev(tBindings);\n    let tmplTail = getTStylingRangeNext(tBindings);\n    tData[index] = tStylingKeyWithStatic;\n    let isKeyDuplicateOfStatic = false;\n    let tStylingKey;\n    if (Array.isArray(tStylingKeyWithStatic)) {\n        // We are case when the `TStylingKey` contains static fields as well.\n        const staticKeyValueArray = tStylingKeyWithStatic;\n        tStylingKey = staticKeyValueArray[1]; // unwrap.\n        // We need to check if our key is present in the static so that we can mark it as duplicate.\n        if (tStylingKey === null ||\n            keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {\n            // tStylingKey is present in the statics, need to mark it as duplicate.\n            isKeyDuplicateOfStatic = true;\n        }\n    }\n    else {\n        tStylingKey = tStylingKeyWithStatic;\n    }\n    if (isHostBinding) {\n        // We are inserting host bindings\n        // If we don't have template bindings then `tail` is 0.\n        const hasTemplateBindings = tmplTail !== 0;\n        // This is important to know because that means that the `head` can't point to the first\n        // template bindings (there are none.) Instead the head points to the tail of the template.\n        if (hasTemplateBindings) {\n            // template head's \"prev\" will point to last host binding or to 0 if no host bindings yet\n            const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);\n            tData[index + 1] = toTStylingRange(previousNode, tmplHead);\n            // if a host binding has already been registered, we need to update the next of that host\n            // binding to point to this one\n            if (previousNode !== 0) {\n                // We need to update the template-tail value to point to us.\n                tData[previousNode + 1] =\n                    setTStylingRangeNext(tData[previousNode + 1], index);\n            }\n            // The \"previous\" of the template binding head should point to this host binding\n            tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);\n        }\n        else {\n            tData[index + 1] = toTStylingRange(tmplHead, 0);\n            // if a host binding has already been registered, we need to update the next of that host\n            // binding to point to this one\n            if (tmplHead !== 0) {\n                // We need to update the template-tail value to point to us.\n                tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);\n            }\n            // if we don't have template, the head points to template-tail, and needs to be advanced.\n            tmplHead = index;\n        }\n    }\n    else {\n        // We are inserting in template section.\n        // We need to set this binding's \"previous\" to the current template tail\n        tData[index + 1] = toTStylingRange(tmplTail, 0);\n        ngDevMode &&\n            assertEqual(tmplHead !== 0 && tmplTail === 0, false, 'Adding template bindings after hostBindings is not allowed.');\n        if (tmplHead === 0) {\n            tmplHead = index;\n        }\n        else {\n            // We need to update the previous value \"next\" to point to this binding\n            tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);\n        }\n        tmplTail = index;\n    }\n    // Now we need to update / compute the duplicates.\n    // Starting with our location search towards head (least priority)\n    if (isKeyDuplicateOfStatic) {\n        tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);\n    }\n    markDuplicates(tData, tStylingKey, index, true, isClassBinding);\n    markDuplicates(tData, tStylingKey, index, false, isClassBinding);\n    markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);\n    tBindings = toTStylingRange(tmplHead, tmplTail);\n    if (isClassBinding) {\n        tNode.classBindings = tBindings;\n    }\n    else {\n        tNode.styleBindings = tBindings;\n    }\n}\n/**\n * Look into the residual styling to see if the current `tStylingKey` is duplicate of residual.\n *\n * @param tNode `TNode` where the residual is stored.\n * @param tStylingKey `TStylingKey` to store.\n * @param tData `TData` associated with the current `LView`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\nfunction markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {\n    const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;\n    if (residual != null /* or undefined */ && typeof tStylingKey == 'string' &&\n        keyValueArrayIndexOf(residual, tStylingKey) >= 0) {\n        // We have duplicate in the residual so mark ourselves as duplicate.\n        tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);\n    }\n}\n/**\n * Marks `TStyleValue`s as duplicates if another style binding in the list has the same\n * `TStyleValue`.\n *\n * NOTE: this function is intended to be called twice once with `isPrevDir` set to `true` and once\n * with it set to `false` to search both the previous as well as next items in the list.\n *\n * No duplicate case\n * ```\n *   [style.color]\n *   [style.width.px] <<- index\n *   [style.height.px]\n * ```\n *\n * In the above case adding `[style.width.px]` to the existing `[style.color]` produces no\n * duplicates because `width` is not found in any other part of the linked list.\n *\n * Duplicate case\n * ```\n *   [style.color]\n *   [style.width.em]\n *   [style.width.px] <<- index\n * ```\n * In the above case adding `[style.width.px]` will produce a duplicate with `[style.width.em]`\n * because `width` is found in the chain.\n *\n * Map case 1\n * ```\n *   [style.width.px]\n *   [style.color]\n *   [style]  <<- index\n * ```\n * In the above case adding `[style]` will produce a duplicate with any other bindings because\n * `[style]` is a Map and as such is fully dynamic and could produce `color` or `width`.\n *\n * Map case 2\n * ```\n *   [style]\n *   [style.width.px]\n *   [style.color]  <<- index\n * ```\n * In the above case adding `[style.color]` will produce a duplicate because there is already a\n * `[style]` binding which is a Map and as such is fully dynamic and could produce `color` or\n * `width`.\n *\n * NOTE: Once `[style]` (Map) is added into the system all things are mapped as duplicates.\n * NOTE: We use `style` as example, but same logic is applied to `class`es as well.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tStylingKey `TStylingKeyPrimitive` which contains the value to compare to other keys in\n *        the linked list.\n * @param index Starting location in the linked list to search from\n * @param isPrevDir Direction.\n *        - `true` for previous (lower priority);\n *        - `false` for next (higher priority).\n */\nfunction markDuplicates(tData, tStylingKey, index, isPrevDir, isClassBinding) {\n    const tStylingAtIndex = tData[index + 1];\n    const isMap = tStylingKey === null;\n    let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);\n    let foundDuplicate = false;\n    // We keep iterating as long as we have a cursor\n    // AND either:\n    // - we found what we are looking for, OR\n    // - we are a map in which case we have to continue searching even after we find what we were\n    //   looking for since we are a wild card and everything needs to be flipped to duplicate.\n    while (cursor !== 0 && (foundDuplicate === false || isMap)) {\n        ngDevMode && assertIndexInRange(tData, cursor);\n        const tStylingValueAtCursor = tData[cursor];\n        const tStyleRangeAtCursor = tData[cursor + 1];\n        if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {\n            foundDuplicate = true;\n            tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) :\n                setTStylingRangePrevDuplicate(tStyleRangeAtCursor);\n        }\n        cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) :\n            getTStylingRangeNext(tStyleRangeAtCursor);\n    }\n    if (foundDuplicate) {\n        // if we found a duplicate, than mark ourselves.\n        tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) :\n            setTStylingRangeNextDuplicate(tStylingAtIndex);\n    }\n}\n/**\n * Determines if two `TStylingKey`s are a match.\n *\n * When computing whether a binding contains a duplicate, we need to compare if the instruction\n * `TStylingKey` has a match.\n *\n * Here are examples of `TStylingKey`s which match given `tStylingKeyCursor` is:\n * - `color`\n *    - `color`    // Match another color\n *    - `null`     // That means that `tStylingKey` is a `classMap`/`styleMap` instruction\n *    - `['', 'color', 'other', true]` // wrapped `color` so match\n *    - `['', null, 'other', true]`       // wrapped `null` so match\n *    - `['', 'width', 'color', 'value']` // wrapped static value contains a match on `'color'`\n * - `null`       // `tStylingKeyCursor` always match as it is `classMap`/`styleMap` instruction\n *\n * @param tStylingKeyCursor\n * @param tStylingKey\n */\nfunction isStylingMatch(tStylingKeyCursor, tStylingKey) {\n    ngDevMode &&\n        assertNotEqual(Array.isArray(tStylingKey), true, 'Expected that \\'tStylingKey\\' has been unwrapped');\n    if (tStylingKeyCursor === null || // If the cursor is `null` it means that we have map at that\n        // location so we must assume that we have a match.\n        tStylingKey == null || // If `tStylingKey` is `null` then it is a map therefor assume that it\n        // contains a match.\n        (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) ===\n            tStylingKey // If the keys match explicitly than we are a match.\n    ) {\n        return true;\n    }\n    else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === 'string') {\n        // if we did not find a match, but `tStylingKeyCursor` is `KeyValueArray` that means cursor has\n        // statics and we need to check those as well.\n        return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >=\n            0; // see if we are matching the key\n    }\n    return false;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Global state of the parser. (This makes parser non-reentrant, but that is not an issue)\nconst parserState = {\n    textEnd: 0,\n    key: 0,\n    keyEnd: 0,\n    value: 0,\n    valueEnd: 0,\n};\n/**\n * Retrieves the last parsed `key` of style.\n * @param text the text to substring the key from.\n */\nfunction getLastParsedKey(text) {\n    return text.substring(parserState.key, parserState.keyEnd);\n}\n/**\n * Retrieves the last parsed `value` of style.\n * @param text the text to substring the key from.\n */\nfunction getLastParsedValue(text) {\n    return text.substring(parserState.value, parserState.valueEnd);\n}\n/**\n * Initializes `className` string for parsing and parses the first token.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n *   const key = getLastParsedKey();\n *   ...\n * }\n * ```\n * @param text `className` to parse\n * @returns index where the next invocation of `parseClassNameNext` should resume.\n */\nfunction parseClassName(text) {\n    resetParserState(text);\n    return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\n/**\n * Parses next `className` token.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n *   const key = getLastParsedKey();\n *   ...\n * }\n * ```\n *\n * @param text `className` to parse\n * @param index where the parsing should resume.\n * @returns index where the next invocation of `parseClassNameNext` should resume.\n */\nfunction parseClassNameNext(text, index) {\n    const end = parserState.textEnd;\n    if (end === index) {\n        return -1;\n    }\n    index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);\n    return consumeWhitespace(text, index, end);\n}\n/**\n * Initializes `cssText` string for parsing and parses the first key/values.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))) {\n *   const key = getLastParsedKey();\n *   const value = getLastParsedValue();\n *   ...\n * }\n * ```\n * @param text `cssText` to parse\n * @returns index where the next invocation of `parseStyleNext` should resume.\n */\nfunction parseStyle(text) {\n    resetParserState(text);\n    return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\n/**\n * Parses the next `cssText` key/values.\n *\n * This function is intended to be used in this format:\n * ```\n * for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i))) {\n *   const key = getLastParsedKey();\n *   const value = getLastParsedValue();\n *   ...\n * }\n *\n * @param text `cssText` to parse\n * @param index where the parsing should resume.\n * @returns index where the next invocation of `parseStyleNext` should resume.\n */\nfunction parseStyleNext(text, startIndex) {\n    const end = parserState.textEnd;\n    let index = parserState.key = consumeWhitespace(text, startIndex, end);\n    if (end === index) {\n        // we reached an end so just quit\n        return -1;\n    }\n    index = parserState.keyEnd = consumeStyleKey(text, index, end);\n    index = consumeSeparator(text, index, end, 58 /* CharCode.COLON */);\n    index = parserState.value = consumeWhitespace(text, index, end);\n    index = parserState.valueEnd = consumeStyleValue(text, index, end);\n    return consumeSeparator(text, index, end, 59 /* CharCode.SEMI_COLON */);\n}\n/**\n * Reset the global state of the styling parser.\n * @param text The styling text to parse.\n */\nfunction resetParserState(text) {\n    parserState.key = 0;\n    parserState.keyEnd = 0;\n    parserState.value = 0;\n    parserState.valueEnd = 0;\n    parserState.textEnd = text.length;\n}\n/**\n * Returns index of next non-whitespace character.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index of next non-whitespace character (May be the same as `start` if no whitespace at\n *          that location.)\n */\nfunction consumeWhitespace(text, startIndex, endIndex) {\n    while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32 /* CharCode.SPACE */) {\n        startIndex++;\n    }\n    return startIndex;\n}\n/**\n * Returns index of last char in class token.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last char in class token.\n */\nfunction consumeClassToken(text, startIndex, endIndex) {\n    while (startIndex < endIndex && text.charCodeAt(startIndex) > 32 /* CharCode.SPACE */) {\n        startIndex++;\n    }\n    return startIndex;\n}\n/**\n * Consumes all of the characters belonging to style key and token.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last style key character.\n */\nfunction consumeStyleKey(text, startIndex, endIndex) {\n    let ch;\n    while (startIndex < endIndex &&\n        ((ch = text.charCodeAt(startIndex)) === 45 /* CharCode.DASH */ || ch === 95 /* CharCode.UNDERSCORE */ ||\n            ((ch & -33 /* CharCode.UPPER_CASE */) >= 65 /* CharCode.A */ && (ch & -33 /* CharCode.UPPER_CASE */) <= 90 /* CharCode.Z */) ||\n            (ch >= 48 /* CharCode.ZERO */ && ch <= 57 /* CharCode.NINE */))) {\n        startIndex++;\n    }\n    return startIndex;\n}\n/**\n * Consumes all whitespace and the separator `:` after the style key.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after separator and surrounding whitespace.\n */\nfunction consumeSeparator(text, startIndex, endIndex, separator) {\n    startIndex = consumeWhitespace(text, startIndex, endIndex);\n    if (startIndex < endIndex) {\n        if (ngDevMode && text.charCodeAt(startIndex) !== separator) {\n            malformedStyleError(text, String.fromCharCode(separator), startIndex);\n        }\n        startIndex++;\n    }\n    return startIndex;\n}\n/**\n * Consumes style value honoring `url()` and `\"\"` text.\n *\n * @param text Text to scan\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after last style value character.\n */\nfunction consumeStyleValue(text, startIndex, endIndex) {\n    let ch1 = -1; // 1st previous character\n    let ch2 = -1; // 2nd previous character\n    let ch3 = -1; // 3rd previous character\n    let i = startIndex;\n    let lastChIndex = i;\n    while (i < endIndex) {\n        const ch = text.charCodeAt(i++);\n        if (ch === 59 /* CharCode.SEMI_COLON */) {\n            return lastChIndex;\n        }\n        else if (ch === 34 /* CharCode.DOUBLE_QUOTE */ || ch === 39 /* CharCode.SINGLE_QUOTE */) {\n            lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);\n        }\n        else if (startIndex ===\n            i - 4 && // We have seen only 4 characters so far \"URL(\" (Ignore \"foo_URL()\")\n            ch3 === 85 /* CharCode.U */ &&\n            ch2 === 82 /* CharCode.R */ && ch1 === 76 /* CharCode.L */ && ch === 40 /* CharCode.OPEN_PAREN */) {\n            lastChIndex = i = consumeQuotedText(text, 41 /* CharCode.CLOSE_PAREN */, i, endIndex);\n        }\n        else if (ch > 32 /* CharCode.SPACE */) {\n            // if we have a non-whitespace character then capture its location\n            lastChIndex = i;\n        }\n        ch3 = ch2;\n        ch2 = ch1;\n        ch1 = ch & -33 /* CharCode.UPPER_CASE */;\n    }\n    return lastChIndex;\n}\n/**\n * Consumes all of the quoted characters.\n *\n * @param text Text to scan\n * @param quoteCharCode CharCode of either `\"` or `'` quote or `)` for `url(...)`.\n * @param startIndex Starting index of character where the scan should start.\n * @param endIndex Ending index of character where the scan should end.\n * @returns Index after quoted characters.\n */\nfunction consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {\n    let ch1 = -1; // 1st previous character\n    let index = startIndex;\n    while (index < endIndex) {\n        const ch = text.charCodeAt(index++);\n        if (ch == quoteCharCode && ch1 !== 92 /* CharCode.BACK_SLASH */) {\n            return index;\n        }\n        if (ch == 92 /* CharCode.BACK_SLASH */ && ch1 === 92 /* CharCode.BACK_SLASH */) {\n            // two back slashes cancel each other out. For example `\"\\\\\"` should properly end the\n            // quotation. (It should not assume that the last `\"` is escaped.)\n            ch1 = 0;\n        }\n        else {\n            ch1 = ch;\n        }\n    }\n    throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) :\n        new Error();\n}\nfunction malformedStyleError(text, expecting, index) {\n    ngDevMode && assertEqual(typeof text === 'string', true, 'String expected here');\n    throw throwError(`Malformed style at location ${index} in string '` + text.substring(0, index) + '[>>' +\n        text.substring(index, index + 1) + '<<]' + text.slice(index + 1) +\n        `'. Expecting '${expecting}'.`);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Update a style binding on an element with the provided value.\n *\n * If the style value is falsy then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `styleMap` or any static styles that are\n * present from when the element was created with `styling`).\n *\n * Note that the styling element is updated as part of `stylingApply`.\n *\n * @param prop A valid CSS property.\n * @param value New value to write (`null` or an empty string to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *\n * Note that this will apply the provided style value to the host element if this function is called\n * within a host binding function.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275styleProp(prop, value, suffix) {\n    checkStylingProperty(prop, value, suffix, false);\n    return \u0275\u0275styleProp;\n}\n/**\n * Update a class binding on an element with the provided value.\n *\n * This instruction is meant to handle the `[class.foo]=\"exp\"` case and,\n * therefore, the class binding itself must already be allocated using\n * `styling` within the creation block.\n *\n * @param prop A valid CSS class (only one).\n * @param value A true/false value which will turn the class on or off.\n *\n * Note that this will apply the provided class value to the host element if this function\n * is called within a host binding function.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275classProp(className, value) {\n    checkStylingProperty(className, value, null, true);\n    return \u0275\u0275classProp;\n}\n/**\n * Update style bindings using an object literal on an element.\n *\n * This instruction is meant to apply styling via the `[style]=\"exp\"` template bindings.\n * When styles are applied to the element they will then be updated with respect to\n * any styles/classes set via `styleProp`. If any styles are set to falsy\n * then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n *\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n *\n * Note that this will apply the provided styleMap value to the host element if this function\n * is called within a host binding.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275styleMap(styles) {\n    checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);\n}\n/**\n * Parse text as style and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `\u0275\u0275styleMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\nfunction styleStringParser(keyValueArray, text) {\n    for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {\n        styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));\n    }\n}\n/**\n * Update class bindings using an object literal or class-string on an element.\n *\n * This instruction is meant to apply styling via the `[class]=\"exp\"` template bindings.\n * When classes are applied to the element they will then be updated with\n * respect to any styles/classes set via `classProp`. If any\n * classes are set to falsy then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n * Note that this will the provided classMap value to the host element if this function is called\n * within a host binding.\n *\n * @param classes A key/value map or string of CSS classes that will be added to the\n *        given element. Any missing classes (that have already been applied to the element\n *        beforehand) will be removed (unset) from the element's list of CSS classes.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275classMap(classes) {\n    checkStylingMap(keyValueArraySet, classStringParser, classes, true);\n}\n/**\n * Parse text as class and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `\u0275\u0275classMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\nfunction classStringParser(keyValueArray, text) {\n    for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n        keyValueArraySet(keyValueArray, getLastParsedKey(text), true);\n    }\n}\n/**\n * Common code between `\u0275\u0275classProp` and `\u0275\u0275styleProp`.\n *\n * @param prop property name.\n * @param value binding value.\n * @param suffix suffix for the property (e.g. `em` or `px`)\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction checkStylingProperty(prop, value, suffix, isClassBased) {\n    const lView = getLView();\n    const tView = getTView();\n    // Styling instructions use 2 slots per binding.\n    // 1. one for the value / TStylingKey\n    // 2. one for the intermittent-value / TStylingRange\n    const bindingIndex = incrementBindingIndex(2);\n    if (tView.firstUpdatePass) {\n        stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);\n    }\n    if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n        const tNode = tView.data[getSelectedIndex()];\n        updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);\n    }\n}\n/**\n * Common code between `\u0275\u0275classMap` and `\u0275\u0275styleMap`.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done for tree shaking purposes.\n * @param stringParser Parser used to parse `value` if `string`. (Passed in as `style` and `class`\n *        have different parsers.)\n * @param value bound value from application\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction checkStylingMap(keyValueArraySet, stringParser, value, isClassBased) {\n    const tView = getTView();\n    const bindingIndex = incrementBindingIndex(2);\n    if (tView.firstUpdatePass) {\n        stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);\n    }\n    const lView = getLView();\n    if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n        // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n        // if so as not to read unnecessarily.\n        const tNode = tView.data[getSelectedIndex()];\n        if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {\n            if (ngDevMode) {\n                // verify that if we are shadowing then `TData` is appropriately marked so that we skip\n                // processing this binding in styling resolution.\n                const tStylingKey = tView.data[bindingIndex];\n                assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, 'Styling linked list shadow input should be marked as \\'false\\'');\n            }\n            // VE does not concatenate the static portion like we are doing here.\n            // Instead VE just ignores the static completely if dynamic binding is present.\n            // Because of locality we have already set the static portion because we don't know if there\n            // is a dynamic portion until later. If we would ignore the static portion it would look like\n            // the binding has removed it. This would confuse `[ngStyle]`/`[ngClass]` to do the wrong\n            // thing as it would think that the static portion was removed. For this reason we\n            // concatenate it so that `[ngStyle]`/`[ngClass]`  can continue to work on changed.\n            let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;\n            ngDevMode && isClassBased === false && staticPrefix !== null &&\n                assertEqual(staticPrefix.endsWith(';'), true, 'Expecting static portion to end with \\';\\'');\n            if (staticPrefix !== null) {\n                // We want to make sure that falsy values of `value` become empty strings.\n                value = concatStringsWithSpace(staticPrefix, value ? value : '');\n            }\n            // Given `<div [style] my-dir>` such that `my-dir` has `@Input('style')`.\n            // This takes over the `[style]` binding. (Same for `[class]`)\n            setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);\n        }\n        else {\n            updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet, stringParser, value), isClassBased, bindingIndex);\n        }\n    }\n}\n/**\n * Determines when the binding is in `hostBindings` section\n *\n * @param tView Current `TView`\n * @param bindingIndex index of binding which we would like if it is in `hostBindings`\n */\nfunction isInHostBindings(tView, bindingIndex) {\n    // All host bindings are placed after the expando section.\n    return bindingIndex >= tView.expandoStartIndex;\n}\n/**\n * Collects the necessary information to insert the binding into a linked list of style bindings\n * using `insertTStylingBinding`.\n *\n * @param tView `TView` where the binding linked list will be stored.\n * @param tStylingKey Property/key of the binding.\n * @param bindingIndex Index of binding associated with the `prop`\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {\n    ngDevMode && assertFirstUpdatePass(tView);\n    const tData = tView.data;\n    if (tData[bindingIndex + 1] === null) {\n        // The above check is necessary because we don't clear first update pass until first successful\n        // (no exception) template execution. This prevents the styling instruction from double adding\n        // itself to the list.\n        // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n        // if so as not to read unnecessarily.\n        const tNode = tData[getSelectedIndex()];\n        ngDevMode && assertDefined(tNode, 'TNode expected');\n        const isHostBindings = isInHostBindings(tView, bindingIndex);\n        if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {\n            // `tStylingKey === null` implies that we are either `[style]` or `[class]` binding.\n            // If there is a directive which uses `@Input('style')` or `@Input('class')` than\n            // we need to neutralize this binding since that directive is shadowing it.\n            // We turn this into a noop by setting the key to `false`\n            tStylingKey = false;\n        }\n        tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);\n        insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);\n    }\n}\n/**\n * Adds static styling information to the binding if applicable.\n *\n * The linked list of styles not only stores the list and keys, but also stores static styling\n * information on some of the keys. This function determines if the key should contain the styling\n * information and computes it.\n *\n * See `TStylingStatic` for more details.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey `TStylingKeyPrimitive` which may need to be wrapped into `TStylingKey`\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {\n    const hostDirectiveDef = getCurrentDirectiveDef(tData);\n    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n    if (hostDirectiveDef === null) {\n        // We are in template node.\n        // If template node already had styling instruction then it has already collected the static\n        // styling and there is no need to collect them again. We know that we are the first styling\n        // instruction because the `TNode.*Bindings` points to 0 (nothing has been inserted yet).\n        const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;\n        if (isFirstStylingInstructionInTemplate) {\n            // It would be nice to be able to get the statics from `mergeAttrs`, however, at this point\n            // they are already merged and it would not be possible to figure which property belongs where\n            // in the priority.\n            stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);\n            stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);\n            // We know that if we have styling binding in template we can't have residual.\n            residual = null;\n        }\n    }\n    else {\n        // We are in host binding node and there was no binding instruction in template node.\n        // This means that we need to compute the residual.\n        const directiveStylingLast = tNode.directiveStylingLast;\n        const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;\n        if (isFirstStylingInstructionInHostBinding) {\n            stylingKey =\n                collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);\n            if (residual === null) {\n                // - If `null` than either:\n                //    - Template styling instruction already ran and it has consumed the static\n                //      styling into its `TStylingKey` and so there is no need to update residual. Instead\n                //      we need to update the `TStylingKey` associated with the first template node\n                //      instruction. OR\n                //    - Some other styling instruction ran and determined that there are no residuals\n                let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);\n                if (templateStylingKey !== undefined && Array.isArray(templateStylingKey)) {\n                    // Only recompute if `templateStylingKey` had static values. (If no static value found\n                    // then there is nothing to do since this operation can only produce less static keys, not\n                    // more.)\n                    templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1] /* unwrap previous statics */, isClassBased);\n                    templateStylingKey =\n                        collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);\n                    setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);\n                }\n            }\n            else {\n                // We only need to recompute residual if it is not `null`.\n                // - If existing residual (implies there was no template styling). This means that some of\n                //   the statics may have moved from the residual to the `stylingKey` and so we have to\n                //   recompute.\n                // - If `undefined` this is the first time we are running.\n                residual = collectResidual(tData, tNode, isClassBased);\n            }\n        }\n    }\n    if (residual !== undefined) {\n        isClassBased ? (tNode.residualClasses = residual) : (tNode.residualStyles = residual);\n    }\n    return stylingKey;\n}\n/**\n * Retrieve the `TStylingKey` for the template styling instruction.\n *\n * This is needed since `hostBinding` styling instructions are inserted after the template\n * instruction. While the template instruction needs to update the residual in `TNode` the\n * `hostBinding` instructions need to update the `TStylingKey` of the template instruction because\n * the template instruction is downstream from the `hostBindings` instructions.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @return `TStylingKey` if found or `undefined` if not found.\n */\nfunction getTemplateHeadTStylingKey(tData, tNode, isClassBased) {\n    const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n    if (getTStylingRangeNext(bindings) === 0) {\n        // There does not seem to be a styling instruction in the `template`.\n        return undefined;\n    }\n    return tData[getTStylingRangePrev(bindings)];\n}\n/**\n * Update the `TStylingKey` of the first template instruction in `TNode`.\n *\n * Logically `hostBindings` styling instructions are of lower priority than that of the template.\n * However, they execute after the template styling instructions. This means that they get inserted\n * in front of the template styling instructions.\n *\n * If we have a template styling instruction and a new `hostBindings` styling instruction is\n * executed it means that it may need to steal static fields from the template instruction. This\n * method allows us to update the first template instruction `TStylingKey` with a new value.\n *\n * Assume:\n * ```\n * <div my-dir style=\"color: red\" [style.color]=\"tmplExp\"></div>\n *\n * @Directive({\n *   host: {\n *     'style': 'width: 100px',\n *     '[style.color]': 'dirExp',\n *   }\n * })\n * class MyDir {}\n * ```\n *\n * when `[style.color]=\"tmplExp\"` executes it creates this data structure.\n * ```\n *  ['', 'color', 'color', 'red', 'width', '100px'],\n * ```\n *\n * The reason for this is that the template instruction does not know if there are styling\n * instructions and must assume that there are none and must collect all of the static styling.\n * (both\n * `color' and 'width`)\n *\n * When `'[style.color]': 'dirExp',` executes we need to insert a new data into the linked list.\n * ```\n *  ['', 'color', 'width', '100px'],  // newly inserted\n *  ['', 'color', 'color', 'red', 'width', '100px'], // this is wrong\n * ```\n *\n * Notice that the template statics is now wrong as it incorrectly contains `width` so we need to\n * update it like so:\n * ```\n *  ['', 'color', 'width', '100px'],\n *  ['', 'color', 'color', 'red'],    // UPDATE\n * ```\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param tStylingKey New `TStylingKey` which is replacing the old one.\n */\nfunction setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {\n    const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n    ngDevMode &&\n        assertNotEqual(getTStylingRangeNext(bindings), 0, 'Expecting to have at least one template styling binding.');\n    tData[getTStylingRangePrev(bindings)] = tStylingKey;\n}\n/**\n * Collect all static values after the current `TNode.directiveStylingLast` index.\n *\n * Collect the remaining styling information which has not yet been collected by an existing\n * styling instruction.\n *\n * @param tData `TData` where the `DirectiveDefs` are stored.\n * @param tNode `TNode` which contains the directive range.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectResidual(tData, tNode, isClassBased) {\n    let residual = undefined;\n    const directiveEnd = tNode.directiveEnd;\n    ngDevMode &&\n        assertNotEqual(tNode.directiveStylingLast, -1, 'By the time this function gets called at least one hostBindings-node styling instruction must have executed.');\n    // We add `1 + tNode.directiveStart` because we need to skip the current directive (as we are\n    // collecting things after the last `hostBindings` directive which had a styling instruction.)\n    for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {\n        const attrs = tData[i].hostAttrs;\n        residual = collectStylingFromTAttrs(residual, attrs, isClassBased);\n    }\n    return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);\n}\n/**\n * Collect the static styling information with lower priority than `hostDirectiveDef`.\n *\n * (This is opposite of residual styling.)\n *\n * @param hostDirectiveDef `DirectiveDef` for which we want to collect lower priority static\n *        styling. (Or `null` if template styling)\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey Existing `TStylingKey` to update or wrap.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {\n    // We need to loop because there can be directives which have `hostAttrs` but don't have\n    // `hostBindings` so this loop catches up to the current directive..\n    let currentDirective = null;\n    const directiveEnd = tNode.directiveEnd;\n    let directiveStylingLast = tNode.directiveStylingLast;\n    if (directiveStylingLast === -1) {\n        directiveStylingLast = tNode.directiveStart;\n    }\n    else {\n        directiveStylingLast++;\n    }\n    while (directiveStylingLast < directiveEnd) {\n        currentDirective = tData[directiveStylingLast];\n        ngDevMode && assertDefined(currentDirective, 'expected to be defined');\n        stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);\n        if (currentDirective === hostDirectiveDef)\n            break;\n        directiveStylingLast++;\n    }\n    if (hostDirectiveDef !== null) {\n        // we only advance the styling cursor if we are collecting data from host bindings.\n        // Template executes before host bindings and so if we would update the index,\n        // host bindings would not get their statics.\n        tNode.directiveStylingLast = directiveStylingLast;\n    }\n    return stylingKey;\n}\n/**\n * Convert `TAttrs` into `TStylingStatic`.\n *\n * @param stylingKey existing `TStylingKey` to update or wrap.\n * @param attrs `TAttributes` to process.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {\n    const desiredMarker = isClassBased ? 1 /* AttributeMarker.Classes */ : 2 /* AttributeMarker.Styles */;\n    let currentMarker = -1 /* AttributeMarker.ImplicitAttributes */;\n    if (attrs !== null) {\n        for (let i = 0; i < attrs.length; i++) {\n            const item = attrs[i];\n            if (typeof item === 'number') {\n                currentMarker = item;\n            }\n            else {\n                if (currentMarker === desiredMarker) {\n                    if (!Array.isArray(stylingKey)) {\n                        stylingKey = stylingKey === undefined ? [] : ['', stylingKey];\n                    }\n                    keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);\n                }\n            }\n        }\n    }\n    return stylingKey === undefined ? null : stylingKey;\n}\n/**\n * Convert user input to `KeyValueArray`.\n *\n * This function takes user input which could be `string`, Object literal, or iterable and converts\n * it into a consistent representation. The output of this is `KeyValueArray` (which is an array\n * where\n * even indexes contain keys and odd indexes contain values for those keys).\n *\n * The advantage of converting to `KeyValueArray` is that we can perform diff in an input\n * independent\n * way.\n * (ie we can compare `foo bar` to `['bar', 'baz'] and determine a set of changes which need to be\n * applied)\n *\n * The fact that `KeyValueArray` is sorted is very important because it allows us to compute the\n * difference in linear fashion without the need to allocate any additional data.\n *\n * For example if we kept this as a `Map` we would have to iterate over previous `Map` to determine\n * which values need to be deleted, over the new `Map` to determine additions, and we would have to\n * keep additional `Map` to keep track of duplicates or items which have not yet been visited.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done\n *        for tree shaking purposes.\n * @param stringParser The parser is passed in so that it will be tree shakable. See\n *        `styleStringParser` and `classStringParser`\n * @param value The value to parse/convert to `KeyValueArray`\n */\nfunction toStylingKeyValueArray(keyValueArraySet, stringParser, value) {\n    if (value == null /*|| value === undefined */ || value === '')\n        return EMPTY_ARRAY;\n    const styleKeyValueArray = [];\n    const unwrappedValue = unwrapSafeValue(value);\n    if (Array.isArray(unwrappedValue)) {\n        for (let i = 0; i < unwrappedValue.length; i++) {\n            keyValueArraySet(styleKeyValueArray, unwrappedValue[i], true);\n        }\n    }\n    else if (typeof unwrappedValue === 'object') {\n        for (const key in unwrappedValue) {\n            if (unwrappedValue.hasOwnProperty(key)) {\n                keyValueArraySet(styleKeyValueArray, key, unwrappedValue[key]);\n            }\n        }\n    }\n    else if (typeof unwrappedValue === 'string') {\n        stringParser(styleKeyValueArray, unwrappedValue);\n    }\n    else {\n        ngDevMode &&\n            throwError('Unsupported styling type ' + typeof unwrappedValue + ': ' + unwrappedValue);\n    }\n    return styleKeyValueArray;\n}\n/**\n * Set a `value` for a `key`.\n *\n * See: `keyValueArraySet` for details\n *\n * @param keyValueArray KeyValueArray to add to.\n * @param key Style key to add.\n * @param value The value to set.\n */\nfunction styleKeyValueArraySet(keyValueArray, key, value) {\n    keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));\n}\n/**\n * Update map based styling.\n *\n * Map based styling could be anything which contains more than one binding. For example `string`,\n * or object literal. Dealing with all of these types would complicate the logic so\n * instead this function expects that the complex input is first converted into normalized\n * `KeyValueArray`. The advantage of normalization is that we get the values sorted, which makes it\n * very cheap to compute deltas between the previous and current value.\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param oldKeyValueArray Previous value represented as `KeyValueArray`\n * @param newKeyValueArray Current value represented as `KeyValueArray`\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\nfunction updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {\n    if (oldKeyValueArray === NO_CHANGE) {\n        // On first execution the oldKeyValueArray is NO_CHANGE => treat it as empty KeyValueArray.\n        oldKeyValueArray = EMPTY_ARRAY;\n    }\n    let oldIndex = 0;\n    let newIndex = 0;\n    let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;\n    let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;\n    while (oldKey !== null || newKey !== null) {\n        ngDevMode && assertLessThan(oldIndex, 999, 'Are we stuck in infinite loop?');\n        ngDevMode && assertLessThan(newIndex, 999, 'Are we stuck in infinite loop?');\n        const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : undefined;\n        const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : undefined;\n        let setKey = null;\n        let setValue = undefined;\n        if (oldKey === newKey) {\n            // UPDATE: Keys are equal => new value is overwriting old value.\n            oldIndex += 2;\n            newIndex += 2;\n            if (oldValue !== newValue) {\n                setKey = newKey;\n                setValue = newValue;\n            }\n        }\n        else if (newKey === null || oldKey !== null && oldKey < newKey) {\n            // DELETE: oldKey key is missing or we did not find the oldKey in the newValue\n            // (because the keyValueArray is sorted and `newKey` is found later alphabetically).\n            // `\"background\" < \"color\"` so we need to delete `\"background\"` because it is not found in the\n            // new array.\n            oldIndex += 2;\n            setKey = oldKey;\n        }\n        else {\n            // CREATE: newKey's is earlier alphabetically than oldKey's (or no oldKey) => we have new key.\n            // `\"color\" > \"background\"` so we need to add `color` because it is in new array but not in\n            // old array.\n            ngDevMode && assertDefined(newKey, 'Expecting to have a valid key');\n            newIndex += 2;\n            setKey = newKey;\n            setValue = newValue;\n        }\n        if (setKey !== null) {\n            updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);\n        }\n        oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;\n        newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;\n    }\n}\n/**\n * Update a simple (property name) styling.\n *\n * This function takes `prop` and updates the DOM to that value. The function takes the binding\n * value as well as binding priority into consideration to determine which value should be written\n * to DOM. (For example it may be determined that there is a higher priority overwrite which blocks\n * the DOM write, or if the value goes to `undefined` a lower priority overwrite may be consulted.)\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param prop Either style property name or a class name.\n * @param value Either style value for `prop` or `true`/`false` if `prop` is class.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\nfunction updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {\n    if (!(tNode.type & 3 /* TNodeType.AnyRNode */)) {\n        // It is possible to have styling on non-elements (such as ng-container).\n        // This is rare, but it does happen. In such a case, just ignore the binding.\n        return;\n    }\n    const tData = tView.data;\n    const tRange = tData[bindingIndex + 1];\n    const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ?\n        findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) :\n        undefined;\n    if (!isStylingValuePresent(higherPriorityValue)) {\n        // We don't have a next duplicate, or we did not find a duplicate value.\n        if (!isStylingValuePresent(value)) {\n            // We should delete current value or restore to lower priority value.\n            if (getTStylingRangePrevDuplicate(tRange)) {\n                // We have a possible prev duplicate, let's retrieve it.\n                value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);\n            }\n        }\n        const rNode = getNativeByIndex(getSelectedIndex(), lView);\n        applyStyling(renderer, isClassBased, rNode, prop, value);\n    }\n}\n/**\n * Search for styling value with higher priority which is overwriting current value, or a\n * value of lower priority to which we should fall back if the value is `undefined`.\n *\n * When value is being applied at a location, related values need to be consulted.\n * - If there is a higher priority binding, we should be using that one instead.\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp1`\n *   requires that we check `exp2` to see if it is set to value other than `undefined`.\n * - If there is a lower priority binding and we are changing to `undefined`\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp2` to\n *   `undefined` requires that we check `exp1` (and static values) and use that as new value.\n *\n * NOTE: The styling stores two values.\n * 1. The raw value which came from the application is stored at `index + 0` location. (This value\n *    is used for dirty checking).\n * 2. The normalized value is stored at `index + 1`.\n *\n * @param tData `TData` used for traversing the priority.\n * @param tNode `TNode` to use for resolving static styling. Also controls search direction.\n *   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n *      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n *   - `null` search prev and go all the way to end. Return last value where\n *     `isStylingValuePresent(value)` is true.\n * @param lView `LView` used for retrieving the actual values.\n * @param prop Property which we are interested in.\n * @param index Starting index in the linked list of styling bindings where the search should start.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction findStylingValue(tData, tNode, lView, prop, index, isClassBased) {\n    // `TNode` to use for resolving static styling. Also controls search direction.\n    //   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n    //      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n    //   - `null` search prev and go all the way to end. Return last value where\n    //     `isStylingValuePresent(value)` is true.\n    const isPrevDirection = tNode === null;\n    let value = undefined;\n    while (index > 0) {\n        const rawKey = tData[index];\n        const containsStatics = Array.isArray(rawKey);\n        // Unwrap the key if we contain static values.\n        const key = containsStatics ? rawKey[1] : rawKey;\n        const isStylingMap = key === null;\n        let valueAtLViewIndex = lView[index + 1];\n        if (valueAtLViewIndex === NO_CHANGE) {\n            // In firstUpdatePass the styling instructions create a linked list of styling.\n            // On subsequent passes it is possible for a styling instruction to try to read a binding\n            // which\n            // has not yet executed. In that case we will find `NO_CHANGE` and we should assume that\n            // we have `undefined` (or empty array in case of styling-map instruction) instead. This\n            // allows the resolution to apply the value (which may later be overwritten when the\n            // binding actually executes.)\n            valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : undefined;\n        }\n        let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) :\n            (key === prop ? valueAtLViewIndex : undefined);\n        if (containsStatics && !isStylingValuePresent(currentValue)) {\n            currentValue = keyValueArrayGet(rawKey, prop);\n        }\n        if (isStylingValuePresent(currentValue)) {\n            value = currentValue;\n            if (isPrevDirection) {\n                return value;\n            }\n        }\n        const tRange = tData[index + 1];\n        index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);\n    }\n    if (tNode !== null) {\n        // in case where we are going in next direction AND we did not find anything, we need to\n        // consult residual styling\n        let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n        if (residual != null /** OR residual !=== undefined */) {\n            value = keyValueArrayGet(residual, prop);\n        }\n    }\n    return value;\n}\n/**\n * Determines if the binding value should be used (or if the value is 'undefined' and hence priority\n * resolution should be used.)\n *\n * @param value Binding style value.\n */\nfunction isStylingValuePresent(value) {\n    // Currently only `undefined` value is considered non-binding. That is `undefined` says I don't\n    // have an opinion as to what this binding should be and you should consult other bindings by\n    // priority to determine the valid value.\n    // This is extracted into a single function so that we have a single place to control this.\n    return value !== undefined;\n}\n/**\n * Normalizes and/or adds a suffix to the value.\n *\n * If value is `null`/`undefined` no suffix is added\n * @param value\n * @param suffix\n */\nfunction normalizeSuffix(value, suffix) {\n    if (value == null /** || value === undefined */) {\n        // do nothing\n    }\n    else if (typeof suffix === 'string') {\n        value = value + suffix;\n    }\n    else if (typeof value === 'object') {\n        value = stringify(unwrapSafeValue(value));\n    }\n    return value;\n}\n/**\n * Tests if the `TNode` has input shadow.\n *\n * An input shadow is when a directive steals (shadows) the input by using `@Input('style')` or\n * `@Input('class')` as input.\n *\n * @param tNode `TNode` which we would like to see if it has shadow.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction hasStylingInputShadow(tNode, isClassBased) {\n    return (tNode.flags & (isClassBased ? 16 /* TNodeFlags.hasClassInput */ : 32 /* TNodeFlags.hasStyleInput */)) !== 0;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Static string value to write.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275text(index, value = '') {\n    const lView = getLView();\n    const tView = getTView();\n    const adjustedIndex = index + HEADER_OFFSET;\n    ngDevMode &&\n        assertEqual(getBindingIndex(), tView.bindingStartIndex, 'text nodes should be created before any bindings');\n    ngDevMode && assertIndexInRange(lView, adjustedIndex);\n    const tNode = tView.firstCreatePass ?\n        getOrCreateTNode(tView, adjustedIndex, 1 /* TNodeType.Text */, value, null) :\n        tView.data[adjustedIndex];\n    const textNative = lView[adjustedIndex] = createTextNode(lView[RENDERER], value);\n    appendChild(tView, lView, textNative, tNode);\n    // Text nodes are self closing.\n    setCurrentTNode(tNode, false);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n *\n * Update text content with a lone bound value\n *\n * Used when a text node has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div>{{v0}}</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275textInterpolate(v0);\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction \u0275\u0275textInterpolate(v0) {\n    \u0275\u0275textInterpolate1('', v0, '');\n    return \u0275\u0275textInterpolate;\n}\n/**\n *\n * Update text content with single bound value surrounded by other text.\n *\n * Used when a text node has 1 interpolated value in it:\n *\n * ```html\n * <div>prefix{{v0}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275textInterpolate1('prefix', v0, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction \u0275\u0275textInterpolate1(prefix, v0, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation1(lView, prefix, v0, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return \u0275\u0275textInterpolate1;\n}\n/**\n *\n * Update text content with 2 bound values surrounded by other text.\n *\n * Used when a text node has 2 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275textInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction \u0275\u0275textInterpolate2(prefix, v0, i0, v1, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return \u0275\u0275textInterpolate2;\n}\n/**\n *\n * Update text content with 3 bound values surrounded by other text.\n *\n * Used when a text node has 3 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275textInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction \u0275\u0275textInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return \u0275\u0275textInterpolate3;\n}\n/**\n *\n * Update text content with 4 bound values surrounded by other text.\n *\n * Used when a text node has 4 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275textInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see \u0275\u0275textInterpolateV\n * @codeGenApi\n */\nfunction \u0275\u0275textInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return \u0275\u0275textInterpolate4;\n}\n/**\n *\n * Update text content with 5 bound values surrounded by other text.\n *\n * Used when a text node has 5 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275textInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction \u0275\u0275textInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return \u0275\u0275textInterpolate5;\n}\n/**\n *\n * Update text content with 6 bound values surrounded by other text.\n *\n * Used when a text node has 6 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275textInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change. @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction \u0275\u0275textInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return \u0275\u0275textInterpolate6;\n}\n/**\n *\n * Update text content with 7 bound values surrounded by other text.\n *\n * Used when a text node has 7 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275textInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction \u0275\u0275textInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return \u0275\u0275textInterpolate7;\n}\n/**\n *\n * Update text content with 8 bound values surrounded by other text.\n *\n * Used when a text node has 8 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275textInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nfunction \u0275\u0275textInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n    const lView = getLView();\n    const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return \u0275\u0275textInterpolate8;\n}\n/**\n * Update text content with 9 or more bound values other surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275textInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n *\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275textInterpolateV(values) {\n    const lView = getLView();\n    const interpolated = interpolationV(lView, values);\n    if (interpolated !== NO_CHANGE) {\n        textBindingInternal(lView, getSelectedIndex(), interpolated);\n    }\n    return \u0275\u0275textInterpolateV;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n *\n * Update an interpolated class on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275classMapInterpolate1('prefix', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275classMapInterpolate1(prefix, v0, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275classMapInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275classMapInterpolate2(prefix, v0, i0, v1, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275classMapInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275classMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275classMapInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275classMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275classMapInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275classMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275classMapInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275classMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275classMapInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275classMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n *\n * Update an interpolated class on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275classMapInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275classMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n/**\n * Update an interpolated class on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275classMapInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nfunction \u0275\u0275classMapInterpolateV(values) {\n    const lView = getLView();\n    const interpolatedValue = interpolationV(lView, values);\n    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n *\n * Update an interpolated style on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style=\"key: {{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275styleMapInterpolate1('key: ', v0, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275styleMapInterpolate1(prefix, v0, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    \u0275\u0275styleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275styleMapInterpolate2('key: ', v0, '; key1: ', v1, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275styleMapInterpolate2(prefix, v0, i0, v1, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    \u0275\u0275styleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key2: {{v1}}; key2: {{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275styleMapInterpolate3(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275styleMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    \u0275\u0275styleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275styleMapInterpolate4(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275styleMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    \u0275\u0275styleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275styleMapInterpolate5(\n *     'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275styleMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    \u0275\u0275styleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}};\n *             key5: {{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275styleMapInterpolate6(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275styleMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    \u0275\u0275styleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275styleMapInterpolate7(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275styleMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    \u0275\u0275styleMap(interpolatedValue);\n}\n/**\n *\n * Update an interpolated style on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *             key6: {{v6}}; key7: {{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275styleMapInterpolate8(\n *    'key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *    '; key6: ', v6, '; key7: ', v7, 'suffix');\n * ```\n *\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @codeGenApi\n */\nfunction \u0275\u0275styleMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    \u0275\u0275styleMap(interpolatedValue);\n}\n/**\n * Update an interpolated style on an element with 9 or more bound values surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  class=\"key: {{v0}}; key1: {{v1}}; key2: {{v2}}; key3: {{v3}}; key4: {{v4}}; key5: {{v5}};\n *         key6: {{v6}}; key7: {{v7}}; key8: {{v8}}; key9: {{v9}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275styleMapInterpolateV(\n *    ['key: ', v0, '; key1: ', v1, '; key2: ', v2, '; key3: ', v3, '; key4: ', v4, '; key5: ', v5,\n *     '; key6: ', v6, '; key7: ', v7, '; key8: ', v8, '; key9: ', v9, 'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '; key2: ', value1, '; key2: ', value2, ..., value99, 'suffix']`)\n * @codeGenApi\n */\nfunction \u0275\u0275styleMapInterpolateV(values) {\n    const lView = getLView();\n    const interpolatedValue = interpolationV(lView, values);\n    \u0275\u0275styleMap(interpolatedValue);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n *\n * Update an interpolated style property on an element with single bound value surrounded by text.\n *\n * Used when the value passed to a property has 1 interpolated value in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275stylePropInterpolate1(0, 'prefix', v0, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275stylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return \u0275\u0275stylePropInterpolate1;\n}\n/**\n *\n * Update an interpolated style property on an element with 2 bound values surrounded by text.\n *\n * Used when the value passed to a property has 2 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275stylePropInterpolate2(0, 'prefix', v0, '-', v1, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275stylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return \u0275\u0275stylePropInterpolate2;\n}\n/**\n *\n * Update an interpolated style property on an element with 3 bound values surrounded by text.\n *\n * Used when the value passed to a property has 3 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275stylePropInterpolate3(0, 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275stylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return \u0275\u0275stylePropInterpolate3;\n}\n/**\n *\n * Update an interpolated style property on an element with 4 bound values surrounded by text.\n *\n * Used when the value passed to a property has 4 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275stylePropInterpolate4(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275stylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return \u0275\u0275stylePropInterpolate4;\n}\n/**\n *\n * Update an interpolated style property on an element with 5 bound values surrounded by text.\n *\n * Used when the value passed to a property has 5 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275stylePropInterpolate5(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275stylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return \u0275\u0275stylePropInterpolate5;\n}\n/**\n *\n * Update an interpolated style property on an element with 6 bound values surrounded by text.\n *\n * Used when the value passed to a property has 6 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275stylePropInterpolate6(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275stylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return \u0275\u0275stylePropInterpolate6;\n}\n/**\n *\n * Update an interpolated style property on an element with 7 bound values surrounded by text.\n *\n * Used when the value passed to a property has 7 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275stylePropInterpolate7(\n *    0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275stylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return \u0275\u0275stylePropInterpolate7;\n}\n/**\n *\n * Update an interpolated style property on an element with 8 bound values surrounded by text.\n *\n * Used when the value passed to a property has 8 interpolated values in it:\n *\n * ```html\n * <div style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix\"></div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275stylePropInterpolate8(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6,\n * '-', v7, 'suffix');\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`.\n * @param prefix Static value used for concatenation only.\n * @param v0 Value checked for change.\n * @param i0 Static value used for concatenation only.\n * @param v1 Value checked for change.\n * @param i1 Static value used for concatenation only.\n * @param v2 Value checked for change.\n * @param i2 Static value used for concatenation only.\n * @param v3 Value checked for change.\n * @param i3 Static value used for concatenation only.\n * @param v4 Value checked for change.\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change.\n * @param i5 Static value used for concatenation only.\n * @param v6 Value checked for change.\n * @param i6 Static value used for concatenation only.\n * @param v7 Value checked for change.\n * @param suffix Static value used for concatenation only.\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275stylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return \u0275\u0275stylePropInterpolate8;\n}\n/**\n * Update an interpolated style property on an element with 9 or more bound values surrounded by\n * text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div\n *  style.color=\"prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix\">\n * </div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * \u0275\u0275stylePropInterpolateV(\n *  0, ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *\n * @param styleIndex Index of style to update. This index value refers to the\n *        index of the style in the style bindings array that was passed into\n *        `styling`..\n * @param values The collection of values and the strings in-between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n * @param valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nfunction \u0275\u0275stylePropInterpolateV(prop, values, valueSuffix) {\n    const lView = getLView();\n    const interpolatedValue = interpolationV(lView, values);\n    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n    return \u0275\u0275stylePropInterpolateV;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Update a property on a host element. Only applies to native node properties, not inputs.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nfunction \u0275\u0275hostProperty(propName, value, sanitizer) {\n    const lView = getLView();\n    const bindingIndex = nextBindingIndex();\n    if (bindingUpdated(lView, bindingIndex, value)) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);\n        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n    }\n    return \u0275\u0275hostProperty;\n}\n/**\n * Updates a synthetic host binding (e.g. `[@foo]`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host binding (e.g. `@HostBinding('@foo')`) properly gets rendered in\n * the component's renderer. Normally all host bindings are evaluated with the parent\n * component's renderer, but, in the case of animation @triggers, they need to be\n * evaluated with the sub component's renderer (because that's where the animation\n * triggers are defined).\n *\n * Do not use this instruction as a replacement for `elementProperty`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275syntheticHostProperty(propName, value, sanitizer) {\n    const lView = getLView();\n    const bindingIndex = nextBindingIndex();\n    if (bindingUpdated(lView, bindingIndex, value)) {\n        const tView = getTView();\n        const tNode = getSelectedTNode();\n        const currentDef = getCurrentDirectiveDef(tView.data);\n        const renderer = loadComponentRenderer(currentDef, tNode, lView);\n        elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);\n        ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n    }\n    return \u0275\u0275syntheticHostProperty;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * NOTE: changes to the `ngI18nClosureMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nif (typeof ngI18nClosureMode === 'undefined') {\n    // These property accesses can be ignored because ngI18nClosureMode will be set to false\n    // when optimizing code and the whole if statement will be dropped.\n    // Make sure to refer to ngI18nClosureMode as ['ngI18nClosureMode'] for closure.\n    // NOTE: we need to have it in IIFE so that the tree-shaker is happy.\n    (function () {\n        // tslint:disable-next-line:no-toplevel-property-access\n        _global$1['ngI18nClosureMode'] =\n            // TODO(FW-1250): validate that this actually, you know, works.\n            // tslint:disable-next-line:no-toplevel-property-access\n            typeof goog !== 'undefined' && typeof goog.getMsg === 'function';\n    })();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// THIS CODE IS GENERATED - DO NOT MODIFY.\nconst u = undefined;\nfunction plural(val) {\n    const n = val, i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\\.?/, '').length;\n    if (i === 1 && v === 0)\n        return 1;\n    return 5;\n}\nvar localeEn = [\"en\", [[\"a\", \"p\"], [\"AM\", \"PM\"], u], [[\"AM\", \"PM\"], u, u], [[\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"], [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"], [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"], [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"]], u, [[\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"], [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]], u, [[\"B\", \"A\"], [\"BC\", \"AD\"], [\"Before Christ\", \"Anno Domini\"]], 0, [6, 0], [\"M/d/yy\", \"MMM d, y\", \"MMMM d, y\", \"EEEE, MMMM d, y\"], [\"h:mm a\", \"h:mm:ss a\", \"h:mm:ss a z\", \"h:mm:ss a zzzz\"], [\"{1}, {0}\", u, \"{1} 'at' {0}\", u], [\".\", \",\", \";\", \"%\", \"+\", \"-\", \"E\", \"\u00D7\", \"\u2030\", \"\u221E\", \"NaN\", \":\"], [\"#,##0.###\", \"#,##0%\", \"\u00A4#,##0.00\", \"#E0\"], \"USD\", \"$\", \"US Dollar\", {}, \"ltr\", plural];\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This const is used to store the locale data registered with `registerLocaleData`\n */\nlet LOCALE_DATA = {};\n/**\n * Register locale data to be used internally by Angular. See the\n * [\"I18n guide\"](guide/i18n-common-format-data-locale) to know how to import additional locale\n * data.\n *\n * The signature `registerLocaleData(data: any, extraData?: any)` is deprecated since v5.1\n */\nfunction registerLocaleData(data, localeId, extraData) {\n    if (typeof localeId !== 'string') {\n        extraData = localeId;\n        localeId = data[LocaleDataIndex.LocaleId];\n    }\n    localeId = localeId.toLowerCase().replace(/_/g, '-');\n    LOCALE_DATA[localeId] = data;\n    if (extraData) {\n        LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData;\n    }\n}\n/**\n * Finds the locale data for a given locale.\n *\n * @param locale The locale code.\n * @returns The locale data.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n-overview)\n */\nfunction findLocaleData(locale) {\n    const normalizedLocale = normalizeLocale(locale);\n    let match = getLocaleData(normalizedLocale);\n    if (match) {\n        return match;\n    }\n    // let's try to find a parent locale\n    const parentLocale = normalizedLocale.split('-')[0];\n    match = getLocaleData(parentLocale);\n    if (match) {\n        return match;\n    }\n    if (parentLocale === 'en') {\n        return localeEn;\n    }\n    throw new RuntimeError(701 /* RuntimeErrorCode.MISSING_LOCALE_DATA */, ngDevMode && `Missing locale data for the locale \"${locale}\".`);\n}\n/**\n * Retrieves the default currency code for the given locale.\n *\n * The default is defined as the first currency which is still in use.\n *\n * @param locale The code of the locale whose currency code we want.\n * @returns The code of the default currency for the given locale.\n *\n */\nfunction getLocaleCurrencyCode(locale) {\n    const data = findLocaleData(locale);\n    return data[LocaleDataIndex.CurrencyCode] || null;\n}\n/**\n * Retrieves the plural function used by ICU expressions to determine the plural case to use\n * for a given locale.\n * @param locale A locale code for the locale format rules to use.\n * @returns The plural function for the locale.\n * @see `NgPlural`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n-overview)\n */\nfunction getLocalePluralCase(locale) {\n    const data = findLocaleData(locale);\n    return data[LocaleDataIndex.PluralCase];\n}\n/**\n * Helper function to get the given `normalizedLocale` from `LOCALE_DATA`\n * or from the global `ng.common.locale`.\n */\nfunction getLocaleData(normalizedLocale) {\n    if (!(normalizedLocale in LOCALE_DATA)) {\n        LOCALE_DATA[normalizedLocale] = _global$1.ng && _global$1.ng.common && _global$1.ng.common.locales &&\n            _global$1.ng.common.locales[normalizedLocale];\n    }\n    return LOCALE_DATA[normalizedLocale];\n}\n/**\n * Helper function to remove all the locale data from `LOCALE_DATA`.\n */\nfunction unregisterAllLocaleData() {\n    LOCALE_DATA = {};\n}\n/**\n * Index of each type of locale data from the locale data array\n */\nvar LocaleDataIndex;\n(function (LocaleDataIndex) {\n    LocaleDataIndex[LocaleDataIndex[\"LocaleId\"] = 0] = \"LocaleId\";\n    LocaleDataIndex[LocaleDataIndex[\"DayPeriodsFormat\"] = 1] = \"DayPeriodsFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"DayPeriodsStandalone\"] = 2] = \"DayPeriodsStandalone\";\n    LocaleDataIndex[LocaleDataIndex[\"DaysFormat\"] = 3] = \"DaysFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"DaysStandalone\"] = 4] = \"DaysStandalone\";\n    LocaleDataIndex[LocaleDataIndex[\"MonthsFormat\"] = 5] = \"MonthsFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"MonthsStandalone\"] = 6] = \"MonthsStandalone\";\n    LocaleDataIndex[LocaleDataIndex[\"Eras\"] = 7] = \"Eras\";\n    LocaleDataIndex[LocaleDataIndex[\"FirstDayOfWeek\"] = 8] = \"FirstDayOfWeek\";\n    LocaleDataIndex[LocaleDataIndex[\"WeekendRange\"] = 9] = \"WeekendRange\";\n    LocaleDataIndex[LocaleDataIndex[\"DateFormat\"] = 10] = \"DateFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"TimeFormat\"] = 11] = \"TimeFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"DateTimeFormat\"] = 12] = \"DateTimeFormat\";\n    LocaleDataIndex[LocaleDataIndex[\"NumberSymbols\"] = 13] = \"NumberSymbols\";\n    LocaleDataIndex[LocaleDataIndex[\"NumberFormats\"] = 14] = \"NumberFormats\";\n    LocaleDataIndex[LocaleDataIndex[\"CurrencyCode\"] = 15] = \"CurrencyCode\";\n    LocaleDataIndex[LocaleDataIndex[\"CurrencySymbol\"] = 16] = \"CurrencySymbol\";\n    LocaleDataIndex[LocaleDataIndex[\"CurrencyName\"] = 17] = \"CurrencyName\";\n    LocaleDataIndex[LocaleDataIndex[\"Currencies\"] = 18] = \"Currencies\";\n    LocaleDataIndex[LocaleDataIndex[\"Directionality\"] = 19] = \"Directionality\";\n    LocaleDataIndex[LocaleDataIndex[\"PluralCase\"] = 20] = \"PluralCase\";\n    LocaleDataIndex[LocaleDataIndex[\"ExtraData\"] = 21] = \"ExtraData\";\n})(LocaleDataIndex || (LocaleDataIndex = {}));\n/**\n * Returns the canonical form of a locale name - lowercase with `_` replaced with `-`.\n */\nfunction normalizeLocale(locale) {\n    return locale.toLowerCase().replace(/_/g, '-');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst pluralMapping = ['zero', 'one', 'two', 'few', 'many'];\n/**\n * Returns the plural case based on the locale\n */\nfunction getPluralCase(value, locale) {\n    const plural = getLocalePluralCase(locale)(parseInt(value, 10));\n    const result = pluralMapping[plural];\n    return (result !== undefined) ? result : 'other';\n}\n/**\n * The locale id that the application is using by default (for translations and ICU expressions).\n */\nconst DEFAULT_LOCALE_ID = 'en-US';\n/**\n * USD currency code that the application uses by default for CurrencyPipe when no\n * DEFAULT_CURRENCY_CODE is provided.\n */\nconst USD_CURRENCY_CODE = 'USD';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Marks that the next string is an element name.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nconst ELEMENT_MARKER = {\n    marker: 'element'\n};\n/**\n * Marks that the next string is comment text need for ICU.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nconst ICU_MARKER = {\n    marker: 'ICU'\n};\n/**\n * See `I18nCreateOpCodes`\n */\nvar I18nCreateOpCode;\n(function (I18nCreateOpCode) {\n    /**\n     * Number of bits to shift index so that it can be combined with the `APPEND_EAGERLY` and\n     * `COMMENT`.\n     */\n    I18nCreateOpCode[I18nCreateOpCode[\"SHIFT\"] = 2] = \"SHIFT\";\n    /**\n     * Should the node be appended to parent immediately after creation.\n     */\n    I18nCreateOpCode[I18nCreateOpCode[\"APPEND_EAGERLY\"] = 1] = \"APPEND_EAGERLY\";\n    /**\n     * If set the node should be comment (rather than a text) node.\n     */\n    I18nCreateOpCode[I18nCreateOpCode[\"COMMENT\"] = 2] = \"COMMENT\";\n})(I18nCreateOpCode || (I18nCreateOpCode = {}));\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$2 = 1;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The locale id that the application is currently using (for translations and ICU expressions).\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n */\nlet LOCALE_ID = DEFAULT_LOCALE_ID;\n/**\n * Sets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n *\n * @param localeId\n */\nfunction setLocaleId(localeId) {\n    assertDefined(localeId, `Expected localeId to be defined`);\n    if (typeof localeId === 'string') {\n        LOCALE_ID = localeId.toLowerCase().replace(/_/g, '-');\n    }\n}\n/**\n * Gets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n */\nfunction getLocaleId() {\n    return LOCALE_ID;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Find a node in front of which `currentTNode` should be inserted (takes i18n into account).\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {\n    const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;\n    const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;\n    if (insertBeforeIndex === null) {\n        return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);\n    }\n    else {\n        ngDevMode && assertIndexInRange(lView, insertBeforeIndex);\n        return unwrapRNode(lView[insertBeforeIndex]);\n    }\n}\n/**\n * Process `TNode.insertBeforeIndex` by adding i18n text nodes.\n *\n * See `TNode.insertBeforeIndex`\n */\nfunction processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {\n    const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;\n    if (Array.isArray(tNodeInsertBeforeIndex)) {\n        // An array indicates that there are i18n nodes that need to be added as children of this\n        // `childRNode`. These i18n nodes were created before this `childRNode` was available and so\n        // only now can be added. The first element of the array is the normal index where we should\n        // insert the `childRNode`. Additional elements are the extra nodes to be added as children of\n        // `childRNode`.\n        ngDevMode && assertDomNode(childRNode);\n        let i18nParent = childRNode;\n        let anchorRNode = null;\n        if (!(childTNode.type & 3 /* TNodeType.AnyRNode */)) {\n            anchorRNode = i18nParent;\n            i18nParent = parentRElement;\n        }\n        if (i18nParent !== null && (childTNode.flags & 2 /* TNodeFlags.isComponentHost */) === 0) {\n            for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {\n                // No need to `unwrapRNode` because all of the indexes point to i18n text nodes.\n                // see `assertDomNode` below.\n                const i18nChild = lView[tNodeInsertBeforeIndex[i]];\n                nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);\n            }\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Add `tNode` to `previousTNodes` list and update relevant `TNode`s in `previousTNodes` list\n * `tNode.insertBeforeIndex`.\n *\n * Things to keep in mind:\n * 1. All i18n text nodes are encoded as `TNodeType.Element` and are created eagerly by the\n *    `\u0275\u0275i18nStart` instruction.\n * 2. All `TNodeType.Placeholder` `TNodes` are elements which will be created later by\n *    `\u0275\u0275elementStart` instruction.\n * 3. `\u0275\u0275elementStart` instruction will create `TNode`s in the ascending `TNode.index` order. (So a\n *    smaller index `TNode` is guaranteed to be created before a larger one)\n *\n * We use the above three invariants to determine `TNode.insertBeforeIndex`.\n *\n * In an ideal world `TNode.insertBeforeIndex` would always be `TNode.next.index`. However,\n * this will not work because `TNode.next.index` may be larger than `TNode.index` which means that\n * the next node is not yet created and therefore we can't insert in front of it.\n *\n * Rule1: `TNode.insertBeforeIndex = null` if `TNode.next === null` (Initial condition, as we don't\n *        know if there will be further `TNode`s inserted after.)\n * Rule2: If `previousTNode` is created after the `tNode` being inserted, then\n *        `previousTNode.insertBeforeNode = tNode.index` (So when a new `tNode` is added we check\n *        previous to see if we can update its `insertBeforeTNode`)\n *\n * See `TNode.insertBeforeIndex` for more context.\n *\n * @param previousTNodes A list of previous TNodes so that we can easily traverse `TNode`s in\n *     reverse order. (If `TNode` would have `previous` this would not be necessary.)\n * @param newTNode A TNode to add to the `previousTNodes` list.\n */\nfunction addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {\n    // Start with Rule1\n    ngDevMode &&\n        assertEqual(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');\n    previousTNodes.push(newTNode);\n    if (previousTNodes.length > 1) {\n        for (let i = previousTNodes.length - 2; i >= 0; i--) {\n            const existingTNode = previousTNodes[i];\n            // Text nodes are created eagerly and so they don't need their `indexBeforeIndex` updated.\n            // It is safe to ignore them.\n            if (!isI18nText(existingTNode)) {\n                if (isNewTNodeCreatedBefore(existingTNode, newTNode) &&\n                    getInsertBeforeIndex(existingTNode) === null) {\n                    // If it was created before us in time, (and it does not yet have `insertBeforeIndex`)\n                    // then add the `insertBeforeIndex`.\n                    setInsertBeforeIndex(existingTNode, newTNode.index);\n                }\n            }\n        }\n    }\n}\nfunction isI18nText(tNode) {\n    return !(tNode.type & 64 /* TNodeType.Placeholder */);\n}\nfunction isNewTNodeCreatedBefore(existingTNode, newTNode) {\n    return isI18nText(newTNode) || existingTNode.index > newTNode.index;\n}\nfunction getInsertBeforeIndex(tNode) {\n    const index = tNode.insertBeforeIndex;\n    return Array.isArray(index) ? index[0] : index;\n}\nfunction setInsertBeforeIndex(tNode, value) {\n    const index = tNode.insertBeforeIndex;\n    if (Array.isArray(index)) {\n        // Array is stored if we have to insert child nodes. See `TNode.insertBeforeIndex`\n        index[0] = value;\n    }\n    else {\n        setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n        tNode.insertBeforeIndex = value;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Retrieve `TIcu` at a given `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be read from.\n */\nfunction getTIcu(tView, index) {\n    const value = tView.data[index];\n    if (value === null || typeof value === 'string')\n        return null;\n    if (ngDevMode &&\n        !(value.hasOwnProperty('tViews') || value.hasOwnProperty('currentCaseLViewIndex'))) {\n        throwError('We expect to get \\'null\\'|\\'TIcu\\'|\\'TIcuContainer\\', but got: ' + value);\n    }\n    // Here the `value.hasOwnProperty('currentCaseLViewIndex')` is a polymorphic read as it can be\n    // either TIcu or TIcuContainerNode. This is not ideal, but we still think it is OK because it\n    // will be just two cases which fits into the browser inline cache (inline cache can take up to\n    // 4)\n    const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ? value :\n        value.value;\n    ngDevMode && assertTIcu(tIcu);\n    return tIcu;\n}\n/**\n * Store `TIcu` at a give `index`.\n *\n * The `TIcu` can be stored either directly (if it is nested ICU) OR\n * it is stored inside tho `TIcuContainer` if it is top level ICU.\n *\n * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n * expressed (parent ICU may have selected a case which does not contain it.)\n *\n * @param tView Current `TView`.\n * @param index Index where the value should be stored at in `Tview.data`\n * @param tIcu The TIcu to store.\n */\nfunction setTIcu(tView, index, tIcu) {\n    const tNode = tView.data[index];\n    ngDevMode &&\n        assertEqual(tNode === null || tNode.hasOwnProperty('tViews'), true, 'We expect to get \\'null\\'|\\'TIcuContainer\\'');\n    if (tNode === null) {\n        tView.data[index] = tIcu;\n    }\n    else {\n        ngDevMode && assertTNodeType(tNode, 32 /* TNodeType.Icu */);\n        tNode.value = tIcu;\n    }\n}\n/**\n * Set `TNode.insertBeforeIndex` taking the `Array` into account.\n *\n * See `TNode.insertBeforeIndex`\n */\nfunction setTNodeInsertBeforeIndex(tNode, index) {\n    ngDevMode && assertTNode(tNode);\n    let insertBeforeIndex = tNode.insertBeforeIndex;\n    if (insertBeforeIndex === null) {\n        setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n        insertBeforeIndex = tNode.insertBeforeIndex =\n            [null /* may be updated to number later */, index];\n    }\n    else {\n        assertEqual(Array.isArray(insertBeforeIndex), true, 'Expecting array here');\n        insertBeforeIndex.push(index);\n    }\n}\n/**\n * Create `TNode.type=TNodeType.Placeholder` node.\n *\n * See `TNodeType.Placeholder` for more information.\n */\nfunction createTNodePlaceholder(tView, previousTNodes, index) {\n    const tNode = createTNodeAtIndex(tView, index, 64 /* TNodeType.Placeholder */, null, null);\n    addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);\n    return tNode;\n}\n/**\n * Returns current ICU case.\n *\n * ICU cases are stored as index into the `TIcu.cases`.\n * At times it is necessary to communicate that the ICU case just switched and that next ICU update\n * should update all bindings regardless of the mask. In such a case the we store negative numbers\n * for cases which have just been switched. This function removes the negative flag.\n */\nfunction getCurrentICUCaseIndex(tIcu, lView) {\n    const currentCase = lView[tIcu.currentCaseLViewIndex];\n    return currentCase === null ? currentCase : (currentCase < 0 ? ~currentCase : currentCase);\n}\nfunction getParentFromIcuCreateOpCode(mergedCode) {\n    return mergedCode >>> 17 /* IcuCreateOpCode.SHIFT_PARENT */;\n}\nfunction getRefFromIcuCreateOpCode(mergedCode) {\n    return (mergedCode & 131070 /* IcuCreateOpCode.MASK_REF */) >>> 1 /* IcuCreateOpCode.SHIFT_REF */;\n}\nfunction getInstructionFromIcuCreateOpCode(mergedCode) {\n    return mergedCode & 1 /* IcuCreateOpCode.MASK_INSTRUCTION */;\n}\nfunction icuCreateOpCode(opCode, parentIdx, refIdx) {\n    ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, 'Missing parent index');\n    ngDevMode && assertGreaterThan(refIdx, 0, 'Missing ref index');\n    return opCode | parentIdx << 17 /* IcuCreateOpCode.SHIFT_PARENT */ | refIdx << 1 /* IcuCreateOpCode.SHIFT_REF */;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Keep track of which input bindings in `\u0275\u0275i18nExp` have changed.\n *\n * This is used to efficiently update expressions in i18n only when the corresponding input has\n * changed.\n *\n * 1) Each bit represents which of the `\u0275\u0275i18nExp` has changed.\n * 2) There are 32 bits allowed in JS.\n * 3) Bit 32 is special as it is shared for all changes past 32. (In other words if you have more\n * than 32 `\u0275\u0275i18nExp` then all changes past 32nd `\u0275\u0275i18nExp` will be mapped to same bit. This means\n * that we may end up changing more than we need to. But i18n expressions with 32 bindings is rare\n * so in practice it should not be an issue.)\n */\nlet changeMask = 0b0;\n/**\n * Keeps track of which bit needs to be updated in `changeMask`\n *\n * This value gets incremented on every call to `\u0275\u0275i18nExp`\n */\nlet changeMaskCounter = 0;\n/**\n * Keep track of which input bindings in `\u0275\u0275i18nExp` have changed.\n *\n * `setMaskBit` gets invoked by each call to `\u0275\u0275i18nExp`.\n *\n * @param hasChange did `\u0275\u0275i18nExp` detect a change.\n */\nfunction setMaskBit(hasChange) {\n    if (hasChange) {\n        changeMask = changeMask | (1 << Math.min(changeMaskCounter, 31));\n    }\n    changeMaskCounter++;\n}\nfunction applyI18n(tView, lView, index) {\n    if (changeMaskCounter > 0) {\n        ngDevMode && assertDefined(tView, `tView should be defined`);\n        const tI18n = tView.data[index];\n        // When `index` points to an `\u0275\u0275i18nAttributes` then we have an array otherwise `TI18n`\n        const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;\n        const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;\n        applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);\n    }\n    // Reset changeMask & maskBit to default for the next update cycle\n    changeMask = 0b0;\n    changeMaskCounter = 0;\n}\n/**\n * Apply `I18nCreateOpCodes` op-codes as stored in `TI18n.create`.\n *\n * Creates text (and comment) nodes which are internationalized.\n *\n * @param lView Current lView\n * @param createOpCodes Set of op-codes to apply\n * @param parentRNode Parent node (so that direct children can be added eagerly) or `null` if it is\n *     a root node.\n * @param insertInFrontOf DOM node that should be used as an anchor.\n */\nfunction applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {\n    const renderer = lView[RENDERER];\n    for (let i = 0; i < createOpCodes.length; i++) {\n        const opCode = createOpCodes[i++];\n        const text = createOpCodes[i];\n        const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n        const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n        const index = opCode >>> I18nCreateOpCode.SHIFT;\n        let rNode = lView[index];\n        if (rNode === null) {\n            // We only create new DOM nodes if they don't already exist: If ICU switches case back to a\n            // case which was already instantiated, no need to create new DOM nodes.\n            rNode = lView[index] =\n                isComment ? renderer.createComment(text) : createTextNode(renderer, text);\n        }\n        if (appendNow && parentRNode !== null) {\n            nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);\n        }\n    }\n}\n/**\n * Apply `I18nMutateOpCodes` OpCodes.\n *\n * @param tView Current `TView`\n * @param mutableOpCodes Mutable OpCodes to process\n * @param lView Current `LView`\n * @param anchorRNode place where the i18n node should be inserted.\n */\nfunction applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {\n    ngDevMode && assertDomNode(anchorRNode);\n    const renderer = lView[RENDERER];\n    // `rootIdx` represents the node into which all inserts happen.\n    let rootIdx = null;\n    // `rootRNode` represents the real node into which we insert. This can be different from\n    // `lView[rootIdx]` if we have projection.\n    //  - null we don't have a parent (as can be the case in when we are inserting into a root of\n    //    LView which has no parent.)\n    //  - `RElement` The element representing the root after taking projection into account.\n    let rootRNode;\n    for (let i = 0; i < mutableOpCodes.length; i++) {\n        const opCode = mutableOpCodes[i];\n        if (typeof opCode == 'string') {\n            const textNodeIndex = mutableOpCodes[++i];\n            if (lView[textNodeIndex] === null) {\n                ngDevMode && ngDevMode.rendererCreateTextNode++;\n                ngDevMode && assertIndexInRange(lView, textNodeIndex);\n                lView[textNodeIndex] = createTextNode(renderer, opCode);\n            }\n        }\n        else if (typeof opCode == 'number') {\n            switch (opCode & 1 /* IcuCreateOpCode.MASK_INSTRUCTION */) {\n                case 0 /* IcuCreateOpCode.AppendChild */:\n                    const parentIdx = getParentFromIcuCreateOpCode(opCode);\n                    if (rootIdx === null) {\n                        // The first operation should save the `rootIdx` because the first operation\n                        // must insert into the root. (Only subsequent operations can insert into a dynamic\n                        // parent)\n                        rootIdx = parentIdx;\n                        rootRNode = nativeParentNode(renderer, anchorRNode);\n                    }\n                    let insertInFrontOf;\n                    let parentRNode;\n                    if (parentIdx === rootIdx) {\n                        insertInFrontOf = anchorRNode;\n                        parentRNode = rootRNode;\n                    }\n                    else {\n                        insertInFrontOf = null;\n                        parentRNode = unwrapRNode(lView[parentIdx]);\n                    }\n                    // FIXME(misko): Refactor with `processI18nText`\n                    if (parentRNode !== null) {\n                        // This can happen if the `LView` we are adding to is not attached to a parent `LView`.\n                        // In such a case there is no \"root\" we can attach to. This is fine, as we still need to\n                        // create the elements. When the `LView` gets later added to a parent these \"root\" nodes\n                        // get picked up and added.\n                        ngDevMode && assertDomNode(parentRNode);\n                        const refIdx = getRefFromIcuCreateOpCode(opCode);\n                        ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, 'Missing ref');\n                        // `unwrapRNode` is not needed here as all of these point to RNodes as part of the i18n\n                        // which can't have components.\n                        const child = lView[refIdx];\n                        ngDevMode && assertDomNode(child);\n                        nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);\n                        const tIcu = getTIcu(tView, refIdx);\n                        if (tIcu !== null && typeof tIcu === 'object') {\n                            // If we just added a comment node which has ICU then that ICU may have already been\n                            // rendered and therefore we need to re-add it here.\n                            ngDevMode && assertTIcu(tIcu);\n                            const caseIndex = getCurrentICUCaseIndex(tIcu, lView);\n                            if (caseIndex !== null) {\n                                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);\n                            }\n                        }\n                    }\n                    break;\n                case 1 /* IcuCreateOpCode.Attr */:\n                    const elementNodeIndex = opCode >>> 1 /* IcuCreateOpCode.SHIFT_REF */;\n                    const attrName = mutableOpCodes[++i];\n                    const attrValue = mutableOpCodes[++i];\n                    // This code is used for ICU expressions only, since we don't support\n                    // directives/components in ICUs, we don't need to worry about inputs here\n                    setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);\n                    break;\n                default:\n                    if (ngDevMode) {\n                        throw new RuntimeError(700 /* RuntimeErrorCode.INVALID_I18N_STRUCTURE */, `Unable to determine the type of mutate operation for \"${opCode}\"`);\n                    }\n            }\n        }\n        else {\n            switch (opCode) {\n                case ICU_MARKER:\n                    const commentValue = mutableOpCodes[++i];\n                    const commentNodeIndex = mutableOpCodes[++i];\n                    if (lView[commentNodeIndex] === null) {\n                        ngDevMode &&\n                            assertEqual(typeof commentValue, 'string', `Expected \"${commentValue}\" to be a comment node value`);\n                        ngDevMode && ngDevMode.rendererCreateComment++;\n                        ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);\n                        const commentRNode = lView[commentNodeIndex] =\n                            createCommentNode(renderer, commentValue);\n                        // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n                        attachPatchData(commentRNode, lView);\n                    }\n                    break;\n                case ELEMENT_MARKER:\n                    const tagName = mutableOpCodes[++i];\n                    const elementNodeIndex = mutableOpCodes[++i];\n                    if (lView[elementNodeIndex] === null) {\n                        ngDevMode &&\n                            assertEqual(typeof tagName, 'string', `Expected \"${tagName}\" to be an element node tag name`);\n                        ngDevMode && ngDevMode.rendererCreateElement++;\n                        ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);\n                        const elementRNode = lView[elementNodeIndex] =\n                            createElementNode(renderer, tagName, null);\n                        // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n                        attachPatchData(elementRNode, lView);\n                    }\n                    break;\n                default:\n                    ngDevMode &&\n                        throwError(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n            }\n        }\n    }\n}\n/**\n * Apply `I18nUpdateOpCodes` OpCodes\n *\n * @param tView Current `TView`\n * @param lView Current `LView`\n * @param updateOpCodes OpCodes to process\n * @param bindingsStartIndex Location of the first `\u0275\u0275i18nApply`\n * @param changeMask Each bit corresponds to a `\u0275\u0275i18nExp` (Counting backwards from\n *     `bindingsStartIndex`)\n */\nfunction applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask) {\n    for (let i = 0; i < updateOpCodes.length; i++) {\n        // bit code to check if we should apply the next update\n        const checkBit = updateOpCodes[i];\n        // Number of opCodes to skip until next set of update codes\n        const skipCodes = updateOpCodes[++i];\n        if (checkBit & changeMask) {\n            // The value has been updated since last checked\n            let value = '';\n            for (let j = i + 1; j <= (i + skipCodes); j++) {\n                const opCode = updateOpCodes[j];\n                if (typeof opCode == 'string') {\n                    value += opCode;\n                }\n                else if (typeof opCode == 'number') {\n                    if (opCode < 0) {\n                        // Negative opCode represent `i18nExp` values offset.\n                        value += renderStringify(lView[bindingsStartIndex - opCode]);\n                    }\n                    else {\n                        const nodeIndex = (opCode >>> 2 /* I18nUpdateOpCode.SHIFT_REF */);\n                        switch (opCode & 3 /* I18nUpdateOpCode.MASK_OPCODE */) {\n                            case 1 /* I18nUpdateOpCode.Attr */:\n                                const propName = updateOpCodes[++j];\n                                const sanitizeFn = updateOpCodes[++j];\n                                const tNodeOrTagName = tView.data[nodeIndex];\n                                ngDevMode && assertDefined(tNodeOrTagName, 'Experting TNode or string');\n                                if (typeof tNodeOrTagName === 'string') {\n                                    // IF we don't have a `TNode`, then we are an element in ICU (as ICU content does\n                                    // not have TNode), in which case we know that there are no directives, and hence\n                                    // we use attribute setting.\n                                    setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);\n                                }\n                                else {\n                                    elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);\n                                }\n                                break;\n                            case 0 /* I18nUpdateOpCode.Text */:\n                                const rText = lView[nodeIndex];\n                                rText !== null && updateTextNode(lView[RENDERER], rText, value);\n                                break;\n                            case 2 /* I18nUpdateOpCode.IcuSwitch */:\n                                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);\n                                break;\n                            case 3 /* I18nUpdateOpCode.IcuUpdate */:\n                                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            const opCode = updateOpCodes[i + 1];\n            if (opCode > 0 && (opCode & 3 /* I18nUpdateOpCode.MASK_OPCODE */) === 3 /* I18nUpdateOpCode.IcuUpdate */) {\n                // Special case for the `icuUpdateCase`. It could be that the mask did not match, but\n                // we still need to execute `icuUpdateCase` because the case has changed recently due to\n                // previous `icuSwitchCase` instruction. (`icuSwitchCase` and `icuUpdateCase` always come in\n                // pairs.)\n                const nodeIndex = (opCode >>> 2 /* I18nUpdateOpCode.SHIFT_REF */);\n                const tIcu = getTIcu(tView, nodeIndex);\n                const currentIndex = lView[tIcu.currentCaseLViewIndex];\n                if (currentIndex < 0) {\n                    applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);\n                }\n            }\n        }\n        i += skipCodes;\n    }\n}\n/**\n * Apply OpCodes associated with updating an existing ICU.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param bindingsStartIndex Location of the first `\u0275\u0275i18nApply`\n * @param lView Current `LView`\n */\nfunction applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {\n    ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n    let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n    if (activeCaseIndex !== null) {\n        let mask = changeMask;\n        if (activeCaseIndex < 0) {\n            // Clear the flag.\n            // Negative number means that the ICU was freshly created and we need to force the update.\n            activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;\n            // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n            mask = -1;\n        }\n        applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n    }\n}\n/**\n * Apply OpCodes associated with switching a case on ICU.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n * @param value Value of the case to update to.\n */\nfunction applyIcuSwitchCase(tView, tIcu, lView, value) {\n    // Rebuild a new case for this ICU\n    const caseIndex = getCaseIndex(tIcu, value);\n    let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n    if (activeCaseIndex !== caseIndex) {\n        applyIcuSwitchCaseRemove(tView, tIcu, lView);\n        lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;\n        if (caseIndex !== null) {\n            // Add the nodes for the new case\n            const anchorRNode = lView[tIcu.anchorIdx];\n            if (anchorRNode) {\n                ngDevMode && assertDomNode(anchorRNode);\n                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);\n            }\n        }\n    }\n}\n/**\n * Apply OpCodes associated with tearing ICU case.\n *\n * This involves tearing down existing case and than building up a new case.\n *\n * @param tView Current `TView`\n * @param tIcu Current `TIcu`\n * @param lView Current `LView`\n */\nfunction applyIcuSwitchCaseRemove(tView, tIcu, lView) {\n    let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n    if (activeCaseIndex !== null) {\n        const removeCodes = tIcu.remove[activeCaseIndex];\n        for (let i = 0; i < removeCodes.length; i++) {\n            const nodeOrIcuIndex = removeCodes[i];\n            if (nodeOrIcuIndex > 0) {\n                // Positive numbers are `RNode`s.\n                const rNode = getNativeByIndex(nodeOrIcuIndex, lView);\n                rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);\n            }\n            else {\n                // Negative numbers are ICUs\n                applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);\n            }\n        }\n    }\n}\n/**\n * Returns the index of the current case of an ICU expression depending on the main binding value\n *\n * @param icuExpression\n * @param bindingValue The value of the main binding used by this ICU expression\n */\nfunction getCaseIndex(icuExpression, bindingValue) {\n    let index = icuExpression.cases.indexOf(bindingValue);\n    if (index === -1) {\n        switch (icuExpression.type) {\n            case 1 /* IcuType.plural */: {\n                const resolvedCase = getPluralCase(bindingValue, getLocaleId());\n                index = icuExpression.cases.indexOf(resolvedCase);\n                if (index === -1 && resolvedCase !== 'other') {\n                    index = icuExpression.cases.indexOf('other');\n                }\n                break;\n            }\n            case 0 /* IcuType.select */: {\n                index = icuExpression.cases.indexOf('other');\n                break;\n            }\n        }\n    }\n    return index === -1 ? null : index;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction loadIcuContainerVisitor() {\n    const _stack = [];\n    let _index = -1;\n    let _lView;\n    let _removes;\n    /**\n     * Retrieves a set of root nodes from `TIcu.remove`. Used by `TNodeType.ICUContainer`\n     * to determine which root belong to the ICU.\n     *\n     * Example of usage.\n     * ```\n     * const nextRNode = icuContainerIteratorStart(tIcuContainerNode, lView);\n     * let rNode: RNode|null;\n     * while(rNode = nextRNode()) {\n     *   console.log(rNode);\n     * }\n     * ```\n     *\n     * @param tIcuContainerNode Current `TIcuContainerNode`\n     * @param lView `LView` where the `RNode`s should be looked up.\n     */\n    function icuContainerIteratorStart(tIcuContainerNode, lView) {\n        _lView = lView;\n        while (_stack.length)\n            _stack.pop();\n        ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);\n        enterIcu(tIcuContainerNode.value, lView);\n        return icuContainerIteratorNext;\n    }\n    function enterIcu(tIcu, lView) {\n        _index = 0;\n        const currentCase = getCurrentICUCaseIndex(tIcu, lView);\n        if (currentCase !== null) {\n            ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);\n            _removes = tIcu.remove[currentCase];\n        }\n        else {\n            _removes = EMPTY_ARRAY;\n        }\n    }\n    function icuContainerIteratorNext() {\n        if (_index < _removes.length) {\n            const removeOpCode = _removes[_index++];\n            ngDevMode && assertNumber(removeOpCode, 'Expecting OpCode number');\n            if (removeOpCode > 0) {\n                const rNode = _lView[removeOpCode];\n                ngDevMode && assertDomNode(rNode);\n                return rNode;\n            }\n            else {\n                _stack.push(_index, _removes);\n                // ICUs are represented by negative indices\n                const tIcuIndex = ~removeOpCode;\n                const tIcu = _lView[TVIEW].data[tIcuIndex];\n                ngDevMode && assertTIcu(tIcu);\n                enterIcu(tIcu, _lView);\n                return icuContainerIteratorNext();\n            }\n        }\n        else {\n            if (_stack.length === 0) {\n                return null;\n            }\n            else {\n                _removes = _stack.pop();\n                _index = _stack.pop();\n                return icuContainerIteratorNext();\n            }\n        }\n    }\n    return icuContainerIteratorStart;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Converts `I18nCreateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nCreateOpCodes.debug` property if `ngDevMode` is enabled.\n * This function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nCreateOpCodes` if attached as a method.\n * @param opcodes `I18nCreateOpCodes` if invoked as a function.\n */\nfunction i18nCreateOpCodesToString(opcodes) {\n    const createOpCodes = opcodes || (Array.isArray(this) ? this : []);\n    let lines = [];\n    for (let i = 0; i < createOpCodes.length; i++) {\n        const opCode = createOpCodes[i++];\n        const text = createOpCodes[i];\n        const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n        const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n        const index = opCode >>> I18nCreateOpCode.SHIFT;\n        lines.push(`lView[${index}] = document.${isComment ? 'createComment' : 'createText'}(${JSON.stringify(text)});`);\n        if (appendNow) {\n            lines.push(`parent.appendChild(lView[${index}]);`);\n        }\n    }\n    return lines;\n}\n/**\n * Converts `I18nUpdateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nUpdateOpCodes.debug` property if `ngDevMode` is enabled.\n * This function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nUpdateOpCodes` if attached as a method.\n * @param opcodes `I18nUpdateOpCodes` if invoked as a function.\n */\nfunction i18nUpdateOpCodesToString(opcodes) {\n    const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n    let lines = [];\n    function consumeOpCode(value) {\n        const ref = value >>> 2 /* I18nUpdateOpCode.SHIFT_REF */;\n        const opCode = value & 3 /* I18nUpdateOpCode.MASK_OPCODE */;\n        switch (opCode) {\n            case 0 /* I18nUpdateOpCode.Text */:\n                return `(lView[${ref}] as Text).textContent = $$$`;\n            case 1 /* I18nUpdateOpCode.Attr */:\n                const attrName = parser.consumeString();\n                const sanitizationFn = parser.consumeFunction();\n                const value = sanitizationFn ? `(${sanitizationFn})($$$)` : '$$$';\n                return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value})`;\n            case 2 /* I18nUpdateOpCode.IcuSwitch */:\n                return `icuSwitchCase(${ref}, $$$)`;\n            case 3 /* I18nUpdateOpCode.IcuUpdate */:\n                return `icuUpdateCase(${ref})`;\n        }\n        throw new Error('unexpected OpCode');\n    }\n    while (parser.hasMore()) {\n        let mask = parser.consumeNumber();\n        let size = parser.consumeNumber();\n        const end = parser.i + size;\n        const statements = [];\n        let statement = '';\n        while (parser.i < end) {\n            let value = parser.consumeNumberOrString();\n            if (typeof value === 'string') {\n                statement += value;\n            }\n            else if (value < 0) {\n                // Negative numbers are ref indexes\n                // Here `i` refers to current binding index. It is to signify that the value is relative,\n                // rather than absolute.\n                statement += '${lView[i' + value + ']}';\n            }\n            else {\n                // Positive numbers are operations.\n                const opCodeText = consumeOpCode(value);\n                statements.push(opCodeText.replace('$$$', '`' + statement + '`') + ';');\n                statement = '';\n            }\n        }\n        lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(' ')} }`);\n    }\n    return lines;\n}\n/**\n * Converts `I18nCreateOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nCreateOpCodes.debug` if `ngDevMode` is enabled. This\n * function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nCreateOpCodes` if attached as a method.\n * @param opcodes `I18nCreateOpCodes` if invoked as a function.\n */\nfunction icuCreateOpCodesToString(opcodes) {\n    const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n    let lines = [];\n    function consumeOpCode(opCode) {\n        const parent = getParentFromIcuCreateOpCode(opCode);\n        const ref = getRefFromIcuCreateOpCode(opCode);\n        switch (getInstructionFromIcuCreateOpCode(opCode)) {\n            case 0 /* IcuCreateOpCode.AppendChild */:\n                return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;\n            case 1 /* IcuCreateOpCode.Attr */:\n                return `(lView[${ref}] as Element).setAttribute(\"${parser.consumeString()}\", \"${parser.consumeString()}\")`;\n        }\n        throw new Error('Unexpected OpCode: ' + getInstructionFromIcuCreateOpCode(opCode));\n    }\n    let lastRef = -1;\n    while (parser.hasMore()) {\n        let value = parser.consumeNumberStringOrMarker();\n        if (value === ICU_MARKER) {\n            const text = parser.consumeString();\n            lastRef = parser.consumeNumber();\n            lines.push(`lView[${lastRef}] = document.createComment(\"${text}\")`);\n        }\n        else if (value === ELEMENT_MARKER) {\n            const text = parser.consumeString();\n            lastRef = parser.consumeNumber();\n            lines.push(`lView[${lastRef}] = document.createElement(\"${text}\")`);\n        }\n        else if (typeof value === 'string') {\n            lastRef = parser.consumeNumber();\n            lines.push(`lView[${lastRef}] = document.createTextNode(\"${value}\")`);\n        }\n        else if (typeof value === 'number') {\n            const line = consumeOpCode(value);\n            line && lines.push(line);\n        }\n        else {\n            throw new Error('Unexpected value');\n        }\n    }\n    return lines;\n}\n/**\n * Converts `I18nRemoveOpCodes` array into a human readable format.\n *\n * This function is attached to the `I18nRemoveOpCodes.debug` if `ngDevMode` is enabled. This\n * function provides a human readable view of the opcodes. This is useful when debugging the\n * application as well as writing more readable tests.\n *\n * @param this `I18nRemoveOpCodes` if attached as a method.\n * @param opcodes `I18nRemoveOpCodes` if invoked as a function.\n */\nfunction i18nRemoveOpCodesToString(opcodes) {\n    const removeCodes = opcodes || (Array.isArray(this) ? this : []);\n    let lines = [];\n    for (let i = 0; i < removeCodes.length; i++) {\n        const nodeOrIcuIndex = removeCodes[i];\n        if (nodeOrIcuIndex > 0) {\n            // Positive numbers are `RNode`s.\n            lines.push(`remove(lView[${nodeOrIcuIndex}])`);\n        }\n        else {\n            // Negative numbers are ICUs\n            lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);\n        }\n    }\n    return lines;\n}\nclass OpCodeParser {\n    constructor(codes) {\n        this.i = 0;\n        this.codes = codes;\n    }\n    hasMore() {\n        return this.i < this.codes.length;\n    }\n    consumeNumber() {\n        let value = this.codes[this.i++];\n        assertNumber(value, 'expecting number in OpCode');\n        return value;\n    }\n    consumeString() {\n        let value = this.codes[this.i++];\n        assertString(value, 'expecting string in OpCode');\n        return value;\n    }\n    consumeFunction() {\n        let value = this.codes[this.i++];\n        if (value === null || typeof value === 'function') {\n            return value;\n        }\n        throw new Error('expecting function in OpCode');\n    }\n    consumeNumberOrString() {\n        let value = this.codes[this.i++];\n        if (typeof value === 'string') {\n            return value;\n        }\n        assertNumber(value, 'expecting number or string in OpCode');\n        return value;\n    }\n    consumeNumberStringOrMarker() {\n        let value = this.codes[this.i++];\n        if (typeof value === 'string' || typeof value === 'number' || value == ICU_MARKER ||\n            value == ELEMENT_MARKER) {\n            return value;\n        }\n        assertNumber(value, 'expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode');\n        return value;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst BINDING_REGEXP = /\uFFFD(\\d+):?\\d*\uFFFD/gi;\nconst ICU_REGEXP = /({\\s*\uFFFD\\d+:?\\d*\uFFFD\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\nconst NESTED_ICU = /\uFFFD(\\d+)\uFFFD/;\nconst ICU_BLOCK_REGEXP = /^\\s*(\uFFFD\\d+:?\\d*\uFFFD)\\s*,\\s*(select|plural)\\s*,/;\nconst MARKER = `\uFFFD`;\nconst SUBTEMPLATE_REGEXP = /\uFFFD\\/?\\*(\\d+:\\d+)\uFFFD/gi;\nconst PH_REGEXP = /\uFFFD(\\/?[#*]\\d+):?\\d*\uFFFD/gi;\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here, since translations\n * might contain this special character.\n */\nconst NGSP_UNICODE_REGEXP = /\\uE500/g;\nfunction replaceNgsp(value) {\n    return value.replace(NGSP_UNICODE_REGEXP, ' ');\n}\n/**\n * Create dynamic nodes from i18n translation block.\n *\n * - Text nodes are created synchronously\n * - TNodes are linked into tree lazily\n *\n * @param tView Current `TView`\n * @parentTNodeIndex index to the parent TNode of this i18n block\n * @param lView Current `LView`\n * @param index Index of `\u0275\u0275i18nStart` instruction.\n * @param message Message to translate.\n * @param subTemplateIndex Index into the sub template of message translation. (ie in case of\n *     `ngIf`) (-1 otherwise)\n */\nfunction i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {\n    const rootTNode = getCurrentParentTNode();\n    const createOpCodes = [];\n    const updateOpCodes = [];\n    const existingTNodeStack = [[]];\n    if (ngDevMode) {\n        attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);\n        attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n    }\n    message = getTranslationForTemplate(message, subTemplateIndex);\n    const msgParts = replaceNgsp(message).split(PH_REGEXP);\n    for (let i = 0; i < msgParts.length; i++) {\n        let value = msgParts[i];\n        if ((i & 1) === 0) {\n            // Even indexes are text (including bindings & ICU expressions)\n            const parts = i18nParseTextIntoPartsAndICU(value);\n            for (let j = 0; j < parts.length; j++) {\n                let part = parts[j];\n                if ((j & 1) === 0) {\n                    // `j` is odd therefore `part` is string\n                    const text = part;\n                    ngDevMode && assertString(text, 'Parsed ICU part should be string');\n                    if (text !== '') {\n                        i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);\n                    }\n                }\n                else {\n                    // `j` is Even therefor `part` is an `ICUExpression`\n                    const icuExpression = part;\n                    // Verify that ICU expression has the right shape. Translations might contain invalid\n                    // constructions (while original messages were correct), so ICU parsing at runtime may\n                    // not succeed (thus `icuExpression` remains a string).\n                    // Note: we intentionally retain the error here by not using `ngDevMode`, because\n                    // the value can change based on the locale and users aren't guaranteed to hit\n                    // an invalid string while they're developing.\n                    if (typeof icuExpression !== 'object') {\n                        throw new Error(`Unable to parse ICU expression in \"${message}\" message.`);\n                    }\n                    const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);\n                    const icuNodeIndex = icuContainerTNode.index;\n                    ngDevMode &&\n                        assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, 'Index must be in absolute LView offset');\n                    icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);\n                }\n            }\n        }\n        else {\n            // Odd indexes are placeholders (elements and sub-templates)\n            // At this point value is something like: '/#1:2' (originally coming from '\uFFFD/#1:2\uFFFD')\n            const isClosing = value.charCodeAt(0) === 47 /* CharCode.SLASH */;\n            const type = value.charCodeAt(isClosing ? 1 : 0);\n            ngDevMode && assertOneOf(type, 42 /* CharCode.STAR */, 35 /* CharCode.HASH */);\n            const index = HEADER_OFFSET + Number.parseInt(value.substring((isClosing ? 2 : 1)));\n            if (isClosing) {\n                existingTNodeStack.shift();\n                setCurrentTNode(getCurrentParentTNode(), false);\n            }\n            else {\n                const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);\n                existingTNodeStack.unshift([]);\n                setCurrentTNode(tNode, true);\n            }\n        }\n    }\n    tView.data[index] = {\n        create: createOpCodes,\n        update: updateOpCodes,\n    };\n}\n/**\n * Allocate space in i18n Range add create OpCode instruction to create a text or comment node.\n *\n * @param tView Current `TView` needed to allocate space in i18n range.\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will be\n *     added as part of the `i18nStart` instruction or as part of the `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param lView Current `LView` needed to allocate space in i18n range.\n * @param createOpCodes Array storing `I18nCreateOpCodes` where new opCodes will be added.\n * @param text Text to be added when the `Text` or `Comment` node will be created.\n * @param isICU true if a `Comment` node for ICU (instead of `Text`) node should be created.\n */\nfunction createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {\n    const i18nNodeIdx = allocExpando(tView, lView, 1, null);\n    let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;\n    let parentTNode = getCurrentParentTNode();\n    if (rootTNode === parentTNode) {\n        // FIXME(misko): A null `parentTNode` should represent when we fall of the `LView` boundary.\n        // (there is no parent), but in some circumstances (because we are inconsistent about how we set\n        // `previousOrParentTNode`) it could point to `rootTNode` So this is a work around.\n        parentTNode = null;\n    }\n    if (parentTNode === null) {\n        // If we don't have a parent that means that we can eagerly add nodes.\n        // If we have a parent than these nodes can't be added now (as the parent has not been created\n        // yet) and instead the `parentTNode` is responsible for adding it. See\n        // `TNode.insertBeforeIndex`\n        opCode |= I18nCreateOpCode.APPEND_EAGERLY;\n    }\n    if (isICU) {\n        opCode |= I18nCreateOpCode.COMMENT;\n        ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);\n    }\n    createOpCodes.push(opCode, text === null ? '' : text);\n    // We store `{{?}}` so that when looking at debug `TNodeType.template` we can see where the\n    // bindings are.\n    const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 /* TNodeType.Icu */ : 1 /* TNodeType.Text */, text === null ? (ngDevMode ? '{{?}}' : '') : text, null);\n    addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);\n    const tNodeIdx = tNode.index;\n    setCurrentTNode(tNode, false /* Text nodes are self closing */);\n    if (parentTNode !== null && rootTNode !== parentTNode) {\n        // We are a child of deeper node (rather than a direct child of `i18nStart` instruction.)\n        // We have to make sure to add ourselves to the parent.\n        setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);\n    }\n    return tNode;\n}\n/**\n * Processes text node in i18n block.\n *\n * Text nodes can have:\n * - Create instruction in `createOpCodes` for creating the text node.\n * - Allocate spec for text node in i18n range of `LView`\n * - If contains binding:\n *    - bindings => allocate space in i18n range of `LView` to store the binding value.\n *    - populate `updateOpCodes` with update instructions.\n *\n * @param tView Current `TView`\n * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will\n *     be added as part of the `i18nStart` instruction or as part of the\n *     `TNode.insertBeforeIndex`.\n * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n * @param createOpCodes Location where the creation OpCodes will be stored.\n * @param lView Current `LView`\n * @param text The translated text (which may contain binding)\n */\nfunction i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {\n    const hasBinding = text.match(BINDING_REGEXP);\n    const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);\n    if (hasBinding) {\n        generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);\n    }\n}\n/**\n * See `i18nAttributes` above.\n */\nfunction i18nAttributesFirstPass(tView, index, values) {\n    const previousElement = getCurrentTNode();\n    const previousElementIndex = previousElement.index;\n    const updateOpCodes = [];\n    if (ngDevMode) {\n        attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n    }\n    if (tView.firstCreatePass && tView.data[index] === null) {\n        for (let i = 0; i < values.length; i += 2) {\n            const attrName = values[i];\n            const message = values[i + 1];\n            if (message !== '') {\n                // Check if attribute value contains an ICU and throw an error if that's the case.\n                // ICUs in element attributes are not supported.\n                // Note: we intentionally retain the error here by not using `ngDevMode`, because\n                // the `value` can change based on the locale and users aren't guaranteed to hit\n                // an invalid string while they're developing.\n                if (ICU_REGEXP.test(message)) {\n                    throw new Error(`ICU expressions are not supported in attributes. Message: \"${message}\".`);\n                }\n                // i18n attributes that hit this code path are guaranteed to have bindings, because\n                // the compiler treats static i18n attributes as regular attribute bindings.\n                // Since this may not be the first i18n attribute on this element we need to pass in how\n                // many previous bindings there have already been.\n                generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);\n            }\n        }\n        tView.data[index] = updateOpCodes;\n    }\n}\n/**\n * Generate the OpCodes to update the bindings of a string.\n *\n * @param updateOpCodes Place where the update opcodes will be stored.\n * @param str The string containing the bindings.\n * @param destinationNode Index of the destination node which will receive the binding.\n * @param attrName Name of the attribute, if the string belongs to an attribute.\n * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\n * @param bindingStart The lView index of the next expression that can be bound via an opCode.\n * @returns The mask value for these bindings\n */\nfunction generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {\n    ngDevMode &&\n        assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, 'Index must be in absolute LView offset');\n    const maskIndex = updateOpCodes.length; // Location of mask\n    const sizeIndex = maskIndex + 1; // location of size for skipping\n    updateOpCodes.push(null, null); // Alloc space for mask and size\n    const startIndex = maskIndex + 2; // location of first allocation.\n    if (ngDevMode) {\n        attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n    }\n    const textParts = str.split(BINDING_REGEXP);\n    let mask = 0;\n    for (let j = 0; j < textParts.length; j++) {\n        const textValue = textParts[j];\n        if (j & 1) {\n            // Odd indexes are bindings\n            const bindingIndex = bindingStart + parseInt(textValue, 10);\n            updateOpCodes.push(-1 - bindingIndex);\n            mask = mask | toMaskBit(bindingIndex);\n        }\n        else if (textValue !== '') {\n            // Even indexes are text\n            updateOpCodes.push(textValue);\n        }\n    }\n    updateOpCodes.push(destinationNode << 2 /* I18nUpdateOpCode.SHIFT_REF */ |\n        (attrName ? 1 /* I18nUpdateOpCode.Attr */ : 0 /* I18nUpdateOpCode.Text */));\n    if (attrName) {\n        updateOpCodes.push(attrName, sanitizeFn);\n    }\n    updateOpCodes[maskIndex] = mask;\n    updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;\n    return mask;\n}\n/**\n * Count the number of bindings in the given `opCodes`.\n *\n * It could be possible to speed this up, by passing the number of bindings found back from\n * `generateBindingUpdateOpCodes()` to `i18nAttributesFirstPass()` but this would then require more\n * complexity in the code and/or transient objects to be created.\n *\n * Since this function is only called once when the template is instantiated, is trivial in the\n * first instance (since `opCodes` will be an empty array), and it is not common for elements to\n * contain multiple i18n bound attributes, it seems like this is a reasonable compromise.\n */\nfunction countBindings(opCodes) {\n    let count = 0;\n    for (let i = 0; i < opCodes.length; i++) {\n        const opCode = opCodes[i];\n        // Bindings are negative numbers.\n        if (typeof opCode === 'number' && opCode < 0) {\n            count++;\n        }\n    }\n    return count;\n}\n/**\n * Convert binding index to mask bit.\n *\n * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\n * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to\n * have more than 32 bindings this will be hit very rarely. The downside of hitting this corner\n * case is that we will execute binding code more often than necessary. (penalty of performance)\n */\nfunction toMaskBit(bindingIndex) {\n    return 1 << Math.min(bindingIndex, 31);\n}\nfunction isRootTemplateMessage(subTemplateIndex) {\n    return subTemplateIndex === -1;\n}\n/**\n * Removes everything inside the sub-templates of a message.\n */\nfunction removeInnerTemplateTranslation(message) {\n    let match;\n    let res = '';\n    let index = 0;\n    let inTemplate = false;\n    let tagMatched;\n    while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\n        if (!inTemplate) {\n            res += message.substring(index, match.index + match[0].length);\n            tagMatched = match[1];\n            inTemplate = true;\n        }\n        else {\n            if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {\n                index = match.index;\n                inTemplate = false;\n            }\n        }\n    }\n    ngDevMode &&\n        assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation \"${message}\"`);\n    res += message.slice(index);\n    return res;\n}\n/**\n * Extracts a part of a message and removes the rest.\n *\n * This method is used for extracting a part of the message associated with a template. A\n * translated message can span multiple templates.\n *\n * Example:\n * ```\n * <div i18n>Translate <span *ngIf>me</span>!</div>\n * ```\n *\n * @param message The message to crop\n * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n * external template and removes all sub-templates.\n */\nfunction getTranslationForTemplate(message, subTemplateIndex) {\n    if (isRootTemplateMessage(subTemplateIndex)) {\n        // We want the root template message, ignore all sub-templates\n        return removeInnerTemplateTranslation(message);\n    }\n    else {\n        // We want a specific sub-template\n        const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;\n        const end = message.search(new RegExp(`${MARKER}\\\\/\\\\*\\\\d+:${subTemplateIndex}${MARKER}`));\n        return removeInnerTemplateTranslation(message.substring(start, end));\n    }\n}\n/**\n * Generate the OpCodes for ICU expressions.\n *\n * @param icuExpression\n * @param index Index where the anchor is stored and an optional `TIcuContainerNode`\n *   - `lView[anchorIdx]` points to a `Comment` node representing the anchor for the ICU.\n *   - `tView.data[anchorIdx]` points to the `TIcuContainerNode` if ICU is root (`null` otherwise)\n */\nfunction icuStart(tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {\n    ngDevMode && assertDefined(icuExpression, 'ICU expression must be defined');\n    let bindingMask = 0;\n    const tIcu = {\n        type: icuExpression.type,\n        currentCaseLViewIndex: allocExpando(tView, lView, 1, null),\n        anchorIdx,\n        cases: [],\n        create: [],\n        remove: [],\n        update: []\n    };\n    addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);\n    setTIcu(tView, anchorIdx, tIcu);\n    const values = icuExpression.values;\n    for (let i = 0; i < values.length; i++) {\n        // Each value is an array of strings & other ICU expressions\n        const valueArr = values[i];\n        const nestedIcus = [];\n        for (let j = 0; j < valueArr.length; j++) {\n            const value = valueArr[j];\n            if (typeof value !== 'string') {\n                // It is an nested ICU expression\n                const icuIndex = nestedIcus.push(value) - 1;\n                // Replace nested ICU expression by a comment node\n                valueArr[j] = `<!--\uFFFD${icuIndex}\uFFFD-->`;\n            }\n        }\n        bindingMask = parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(''), nestedIcus) |\n            bindingMask;\n    }\n    if (bindingMask) {\n        addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);\n    }\n}\n/**\n * Parses text containing an ICU expression and produces a JSON object for it.\n * Original code from closure library, modified for Angular.\n *\n * @param pattern Text containing an ICU expression that needs to be parsed.\n *\n */\nfunction parseICUBlock(pattern) {\n    const cases = [];\n    const values = [];\n    let icuType = 1 /* IcuType.plural */;\n    let mainBinding = 0;\n    pattern = pattern.replace(ICU_BLOCK_REGEXP, function (str, binding, type) {\n        if (type === 'select') {\n            icuType = 0 /* IcuType.select */;\n        }\n        else {\n            icuType = 1 /* IcuType.plural */;\n        }\n        mainBinding = parseInt(binding.slice(1), 10);\n        return '';\n    });\n    const parts = i18nParseTextIntoPartsAndICU(pattern);\n    // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n    for (let pos = 0; pos < parts.length;) {\n        let key = parts[pos++].trim();\n        if (icuType === 1 /* IcuType.plural */) {\n            // Key can be \"=x\", we just want \"x\"\n            key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1');\n        }\n        if (key.length) {\n            cases.push(key);\n        }\n        const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);\n        if (cases.length > values.length) {\n            values.push(blocks);\n        }\n    }\n    // TODO(ocombe): support ICU expressions in attributes, see #21615\n    return { type: icuType, mainBinding: mainBinding, cases, values };\n}\n/**\n * Breaks pattern into strings and top level {...} blocks.\n * Can be used to break a message into text and ICU expressions, or to break an ICU expression\n * into keys and cases. Original code from closure library, modified for Angular.\n *\n * @param pattern (sub)Pattern to be broken.\n * @returns An `Array<string|IcuExpression>` where:\n *   - odd positions: `string` => text between ICU expressions\n *   - even positions: `ICUExpression` => ICU expression parsed into `ICUExpression` record.\n */\nfunction i18nParseTextIntoPartsAndICU(pattern) {\n    if (!pattern) {\n        return [];\n    }\n    let prevPos = 0;\n    const braceStack = [];\n    const results = [];\n    const braces = /[{}]/g;\n    // lastIndex doesn't get set to 0 so we have to.\n    braces.lastIndex = 0;\n    let match;\n    while (match = braces.exec(pattern)) {\n        const pos = match.index;\n        if (match[0] == '}') {\n            braceStack.pop();\n            if (braceStack.length == 0) {\n                // End of the block.\n                const block = pattern.substring(prevPos, pos);\n                if (ICU_BLOCK_REGEXP.test(block)) {\n                    results.push(parseICUBlock(block));\n                }\n                else {\n                    results.push(block);\n                }\n                prevPos = pos + 1;\n            }\n        }\n        else {\n            if (braceStack.length == 0) {\n                const substring = pattern.substring(prevPos, pos);\n                results.push(substring);\n                prevPos = pos + 1;\n            }\n            braceStack.push('{');\n        }\n    }\n    const substring = pattern.substring(prevPos);\n    results.push(substring);\n    return results;\n}\n/**\n * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\n *\n */\nfunction parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {\n    const create = [];\n    const remove = [];\n    const update = [];\n    if (ngDevMode) {\n        attachDebugGetter(create, icuCreateOpCodesToString);\n        attachDebugGetter(remove, i18nRemoveOpCodesToString);\n        attachDebugGetter(update, i18nUpdateOpCodesToString);\n    }\n    tIcu.cases.push(caseName);\n    tIcu.create.push(create);\n    tIcu.remove.push(remove);\n    tIcu.update.push(update);\n    const inertBodyHelper = getInertBodyHelper(getDocument());\n    const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);\n    ngDevMode && assertDefined(inertBodyElement, 'Unable to generate inert body element');\n    const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;\n    if (inertRootNode) {\n        return walkIcuTree(tView, tIcu, lView, updateOpCodes, create, remove, update, inertRootNode, parentIdx, nestedIcus, 0);\n    }\n    else {\n        return 0;\n    }\n}\nfunction walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, parentNode, parentIdx, nestedIcus, depth) {\n    let bindingMask = 0;\n    let currentNode = parentNode.firstChild;\n    while (currentNode) {\n        const newIndex = allocExpando(tView, lView, 1, null);\n        switch (currentNode.nodeType) {\n            case Node.ELEMENT_NODE:\n                const element = currentNode;\n                const tagName = element.tagName.toLowerCase();\n                if (VALID_ELEMENTS.hasOwnProperty(tagName)) {\n                    addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);\n                    tView.data[newIndex] = tagName;\n                    const elAttrs = element.attributes;\n                    for (let i = 0; i < elAttrs.length; i++) {\n                        const attr = elAttrs.item(i);\n                        const lowerAttrName = attr.name.toLowerCase();\n                        const hasBinding = !!attr.value.match(BINDING_REGEXP);\n                        // we assume the input string is safe, unless it's using a binding\n                        if (hasBinding) {\n                            if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n                                if (URI_ATTRS[lowerAttrName]) {\n                                    generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);\n                                }\n                                else {\n                                    generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);\n                                }\n                            }\n                            else {\n                                ngDevMode &&\n                                    console.warn(`WARNING: ignoring unsafe attribute value ` +\n                                        `${lowerAttrName} on element ${tagName} ` +\n                                        `(see https://g.co/ng/security#xss)`);\n                            }\n                        }\n                        else {\n                            addCreateAttribute(create, newIndex, attr);\n                        }\n                    }\n                    // Parse the children of this node (if any)\n                    bindingMask = walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update, currentNode, newIndex, nestedIcus, depth + 1) |\n                        bindingMask;\n                    addRemoveNode(remove, newIndex, depth);\n                }\n                break;\n            case Node.TEXT_NODE:\n                const value = currentNode.textContent || '';\n                const hasBinding = value.match(BINDING_REGEXP);\n                addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);\n                addRemoveNode(remove, newIndex, depth);\n                if (hasBinding) {\n                    bindingMask =\n                        generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;\n                }\n                break;\n            case Node.COMMENT_NODE:\n                // Check if the comment node is a placeholder for a nested ICU\n                const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');\n                if (isNestedIcu) {\n                    const nestedIcuIndex = parseInt(isNestedIcu[1], 10);\n                    const icuExpression = nestedIcus[nestedIcuIndex];\n                    // Create the comment node that will anchor the ICU expression\n                    addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx, newIndex);\n                    icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);\n                    addRemoveNestedIcu(remove, newIndex, depth);\n                }\n                break;\n        }\n        currentNode = currentNode.nextSibling;\n    }\n    return bindingMask;\n}\nfunction addRemoveNode(remove, index, depth) {\n    if (depth === 0) {\n        remove.push(index);\n    }\n}\nfunction addRemoveNestedIcu(remove, index, depth) {\n    if (depth === 0) {\n        remove.push(~index); // remove ICU at `index`\n        remove.push(index); // remove ICU comment at `index`\n    }\n}\nfunction addUpdateIcuSwitch(update, icuExpression, index) {\n    update.push(toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding, index << 2 /* I18nUpdateOpCode.SHIFT_REF */ | 2 /* I18nUpdateOpCode.IcuSwitch */);\n}\nfunction addUpdateIcuUpdate(update, bindingMask, index) {\n    update.push(bindingMask, 1, index << 2 /* I18nUpdateOpCode.SHIFT_REF */ | 3 /* I18nUpdateOpCode.IcuUpdate */);\n}\nfunction addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {\n    if (marker !== null) {\n        create.push(marker);\n    }\n    create.push(text, createAtIdx, icuCreateOpCode(0 /* IcuCreateOpCode.AppendChild */, appendToParentIdx, createAtIdx));\n}\nfunction addCreateAttribute(create, newIndex, attr) {\n    create.push(newIndex << 1 /* IcuCreateOpCode.SHIFT_REF */ | 1 /* IcuCreateOpCode.Attr */, attr.name, attr.value);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// i18nPostprocess consts\nconst ROOT_TEMPLATE_ID = 0;\nconst PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(\uFFFD.+?\uFFFD?)\\]/;\nconst PP_PLACEHOLDERS_REGEXP = /\\[(\uFFFD.+?\uFFFD?)\\]|(\uFFFD\\/?\\*\\d+:\\d+\uFFFD)/g;\nconst PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\nconst PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\nconst PP_ICUS_REGEXP = /\uFFFDI18N_EXP_(ICU(_\\d+)?)\uFFFD/g;\nconst PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\nconst PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [\uFFFD*1:1\uFFFD\uFFFD#2:1\uFFFD|\uFFFD#4:1\uFFFD|\uFFFD5\uFFFD])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like \uFFFDICU_EXP_ICU_1\uFFFD)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nfunction i18nPostprocess(message, replacements = {}) {\n    /**\n     * Step 1: resolve all multi-value placeholders like [\uFFFD#5\uFFFD|\uFFFD*1:1\uFFFD\uFFFD#2:1\uFFFD|\uFFFD#4:1\uFFFD]\n     *\n     * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically\n     * grouped by templates, for example: [\uFFFD#5\uFFFD|\uFFFD#6\uFFFD|\uFFFD#1:1\uFFFD|\uFFFD#3:2\uFFFD] where \uFFFD#5\uFFFD and \uFFFD#6\uFFFD belong to root\n     * template, \uFFFD#1:1\uFFFD belong to nested template with index 1 and \uFFFD#1:2\uFFFD - nested template with index\n     * 3. However in real templates the order might be different: i.e. \uFFFD#1:1\uFFFD and/or \uFFFD#3:2\uFFFD may go in\n     * front of \uFFFD#6\uFFFD. The post processing step restores the right order by keeping track of the\n     * template id stack and looks for placeholders that belong to the currently active template.\n     */\n    let result = message;\n    if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\n        const matches = {};\n        const templateIdsStack = [ROOT_TEMPLATE_ID];\n        result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {\n            const content = phs || tmpl;\n            const placeholders = matches[content] || [];\n            if (!placeholders.length) {\n                content.split('|').forEach((placeholder) => {\n                    const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);\n                    const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;\n                    const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);\n                    placeholders.push([templateId, isCloseTemplateTag, placeholder]);\n                });\n                matches[content] = placeholders;\n            }\n            if (!placeholders.length) {\n                throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);\n            }\n            const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];\n            let idx = 0;\n            // find placeholder index that matches current template id\n            for (let i = 0; i < placeholders.length; i++) {\n                if (placeholders[i][0] === currentTemplateId) {\n                    idx = i;\n                    break;\n                }\n            }\n            // update template id stack based on the current tag extracted\n            const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];\n            if (isCloseTemplateTag) {\n                templateIdsStack.pop();\n            }\n            else if (currentTemplateId !== templateId) {\n                templateIdsStack.push(templateId);\n            }\n            // remove processed tag from the list\n            placeholders.splice(idx, 1);\n            return placeholder;\n        });\n    }\n    // return current result if no replacements specified\n    if (!Object.keys(replacements).length) {\n        return result;\n    }\n    /**\n     * Step 2: replace all ICU vars (like \"VAR_PLURAL\")\n     */\n    result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end) => {\n        return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;\n    });\n    /**\n     * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n     */\n    result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key) => {\n        return replacements.hasOwnProperty(key) ? replacements[key] : match;\n    });\n    /**\n     * Step 4: replace all ICU references with corresponding values (like \uFFFDICU_EXP_ICU_1\uFFFD) in case\n     * multiple ICUs have the same placeholder name\n     */\n    result = result.replace(PP_ICUS_REGEXP, (match, key) => {\n        if (replacements.hasOwnProperty(key)) {\n            const list = replacements[key];\n            if (!list.length) {\n                throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);\n            }\n            return list.shift();\n        }\n        return match;\n    });\n    return result;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Marks a block of text as translatable.\n *\n * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `\uFFFD{index}(:{block})\uFFFD`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `\uFFFD#{index}(:{block})\uFFFD`/`\uFFFD/#{index}(:{block})\uFFFD`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `\uFFFD*{index}:{block}\uFFFD`/`\uFFFD/*{index}:{block}\uFFFD`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex = -1) {\n    const tView = getTView();\n    const lView = getLView();\n    const adjustedIndex = HEADER_OFFSET + index;\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const message = getConstant(tView.consts, messageIndex);\n    const parentTNode = getCurrentParentTNode();\n    if (tView.firstCreatePass) {\n        i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);\n    }\n    const tI18n = tView.data[adjustedIndex];\n    const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;\n    const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);\n    // If `parentTNode` is an `ElementContainer` than it has `<!--ng-container--->`.\n    // When we do inserts we have to make sure to insert in front of `<!--ng-container--->`.\n    const insertInFrontOf = parentTNode && (parentTNode.type & 8 /* TNodeType.ElementContainer */) ?\n        lView[parentTNode.index] :\n        null;\n    applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);\n    setInI18nBlock(true);\n}\n/**\n * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\n * into the render tree, moves the placeholder nodes and removes the deleted nodes.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275i18nEnd() {\n    setInI18nBlock(false);\n}\n/**\n *\n * Use this instruction to create a translation block that doesn't contain any placeholder.\n * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\n *\n * The translation `message` is the value which is locale specific. The translation string may\n * contain placeholders which associate inner elements and sub-templates within the translation.\n *\n * The translation `message` placeholders are:\n * - `\uFFFD{index}(:{block})\uFFFD`: *Binding Placeholder*: Marks a location where an expression will be\n *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n *   `block` that matches the sub-template in which it was declared.\n * - `\uFFFD#{index}(:{block})\uFFFD`/`\uFFFD/#{index}(:{block})\uFFFD`: *Element Placeholder*:  Marks the beginning\n *   and end of DOM element that were embedded in the original translation block. The placeholder\n *   `index` points to the element index in the template instructions set. An optional `block` that\n *   matches the sub-template in which it was declared.\n * - `\uFFFD*{index}:{block}\uFFFD`/`\uFFFD/*{index}:{block}\uFFFD`: *Sub-template Placeholder*: Sub-templates must be\n *   split up and translated separately in each angular template function. The `index` points to the\n *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n *\n * @param index A unique index of the translation in the static block.\n * @param messageIndex An index of the translation message from the `def.consts` array.\n * @param subTemplateIndex Optional sub-template index in the `message`.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275i18n(index, messageIndex, subTemplateIndex) {\n    \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex);\n    \u0275\u0275i18nEnd();\n}\n/**\n * Marks a list of attributes as translatable.\n *\n * @param index A unique index in the static block\n * @param values\n *\n * @codeGenApi\n */\nfunction \u0275\u0275i18nAttributes(index, attrsIndex) {\n    const tView = getTView();\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const attrs = getConstant(tView.consts, attrsIndex);\n    i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);\n}\n/**\n * Stores the values of the bindings during each update cycle in order to determine if we need to\n * update the translated nodes.\n *\n * @param value The binding's value\n * @returns This function returns itself so that it may be chained\n * (e.g. `i18nExp(ctx.name)(ctx.title)`)\n *\n * @codeGenApi\n */\nfunction \u0275\u0275i18nExp(value) {\n    const lView = getLView();\n    setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));\n    return \u0275\u0275i18nExp;\n}\n/**\n * Updates a translation block or an i18n attribute when the bindings have changed.\n *\n * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\n * (i18n attribute) on which it should update the content.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275i18nApply(index) {\n    applyI18n(getTView(), getLView(), index + HEADER_OFFSET);\n}\n/**\n * Handles message string post-processing for internationalization.\n *\n * Handles message string post-processing by transforming it from intermediate\n * format (that might contain some markers that we need to replace) to the final\n * form, consumable by i18nStart instruction. Post processing steps include:\n *\n * 1. Resolve all multi-value cases (like [\uFFFD*1:1\uFFFD\uFFFD#2:1\uFFFD|\uFFFD#4:1\uFFFD|\uFFFD5\uFFFD])\n * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n * 4. Replace all ICU references with corresponding values (like \uFFFDICU_EXP_ICU_1\uFFFD)\n *    in case multiple ICUs have the same placeholder name\n *\n * @param message Raw translation string for post processing\n * @param replacements Set of replacements that should be applied\n *\n * @returns Transformed string that can be consumed by i18nStart instruction\n *\n * @codeGenApi\n */\nfunction \u0275\u0275i18nPostprocess(message, replacements = {}) {\n    return i18nPostprocess(message, replacements);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Resolves the providers which are defined in the DirectiveDef.\n *\n * When inserting the tokens and the factories in their respective arrays, we can assume that\n * this method is called first for the component (if any), and then for other directives on the same\n * node.\n * As a consequence,the providers are always processed in that order:\n * 1) The view providers of the component\n * 2) The providers of the component\n * 3) The providers of the other directives\n * This matches the structure of the injectables arrays of a view (for each node).\n * So the tokens and the factories can be pushed at the end of the arrays, except\n * in one case for multi providers.\n *\n * @param def the directive definition\n * @param providers: Array of `providers`.\n * @param viewProviders: Array of `viewProviders`.\n */\nfunction providersResolver(def, providers, viewProviders) {\n    const tView = getTView();\n    if (tView.firstCreatePass) {\n        const isComponent = isComponentDef(def);\n        // The list of view providers is processed first, and the flags are updated\n        resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent, true);\n        // Then, the list of providers is processed, and the flags are updated\n        resolveProvider(providers, tView.data, tView.blueprint, isComponent, false);\n    }\n}\n/**\n * Resolves a provider and publishes it to the DI system.\n */\nfunction resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {\n    provider = resolveForwardRef(provider);\n    if (Array.isArray(provider)) {\n        // Recursively call `resolveProvider`\n        // Recursion is OK in this case because this code will not be in hot-path once we implement\n        // cloning of the initial state.\n        for (let i = 0; i < provider.length; i++) {\n            resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);\n        }\n    }\n    else {\n        const tView = getTView();\n        const lView = getLView();\n        let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\n        let providerFactory = providerToFactory(provider);\n        const tNode = getCurrentTNode();\n        const beginIndex = tNode.providerIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n        const endIndex = tNode.directiveStart;\n        const cptViewProvidersCount = tNode.providerIndexes >> 20 /* TNodeProviderIndexes.CptViewProvidersCountShift */;\n        if (isTypeProvider(provider) || !provider.multi) {\n            // Single provider case: the factory is created and pushed immediately\n            const factory = new NodeInjectorFactory(providerFactory, isViewProvider, \u0275\u0275directiveInject);\n            const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);\n            if (existingFactoryIndex === -1) {\n                diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);\n                registerDestroyHooksIfSupported(tView, provider, tInjectables.length);\n                tInjectables.push(token);\n                tNode.directiveStart++;\n                tNode.directiveEnd++;\n                if (isViewProvider) {\n                    tNode.providerIndexes += 1048576 /* TNodeProviderIndexes.CptViewProvidersCountShifter */;\n                }\n                lInjectablesBlueprint.push(factory);\n                lView.push(factory);\n            }\n            else {\n                lInjectablesBlueprint[existingFactoryIndex] = factory;\n                lView[existingFactoryIndex] = factory;\n            }\n        }\n        else {\n            // Multi provider case:\n            // We create a multi factory which is going to aggregate all the values.\n            // Since the output of such a factory depends on content or view injection,\n            // we create two of them, which are linked together.\n            //\n            // The first one (for view providers) is always in the first block of the injectables array,\n            // and the second one (for providers) is always in the second block.\n            // This is important because view providers have higher priority. When a multi token\n            // is being looked up, the view providers should be found first.\n            // Note that it is not possible to have a multi factory in the third block (directive block).\n            //\n            // The algorithm to process multi providers is as follows:\n            // 1) If the multi provider comes from the `viewProviders` of the component:\n            //   a) If the special view providers factory doesn't exist, it is created and pushed.\n            //   b) Else, the multi provider is added to the existing multi factory.\n            // 2) If the multi provider comes from the `providers` of the component or of another\n            // directive:\n            //   a) If the multi factory doesn't exist, it is created and provider pushed into it.\n            //      It is also linked to the multi factory for view providers, if it exists.\n            //   b) Else, the multi provider is added to the existing multi factory.\n            const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);\n            const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);\n            const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 &&\n                lInjectablesBlueprint[existingProvidersFactoryIndex];\n            const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 &&\n                lInjectablesBlueprint[existingViewProvidersFactoryIndex];\n            if (isViewProvider && !doesViewProvidersFactoryExist ||\n                !isViewProvider && !doesProvidersFactoryExist) {\n                // Cases 1.a and 2.a\n                diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);\n                const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);\n                if (!isViewProvider && doesViewProvidersFactoryExist) {\n                    lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;\n                }\n                registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);\n                tInjectables.push(token);\n                tNode.directiveStart++;\n                tNode.directiveEnd++;\n                if (isViewProvider) {\n                    tNode.providerIndexes += 1048576 /* TNodeProviderIndexes.CptViewProvidersCountShifter */;\n                }\n                lInjectablesBlueprint.push(factory);\n                lView.push(factory);\n            }\n            else {\n                // Cases 1.b and 2.b\n                const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex :\n                    existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);\n                registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex :\n                    existingViewProvidersFactoryIndex, indexInFactory);\n            }\n            if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {\n                lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;\n            }\n        }\n    }\n}\n/**\n * Registers the `ngOnDestroy` hook of a provider, if the provider supports destroy hooks.\n * @param tView `TView` in which to register the hook.\n * @param provider Provider whose hook should be registered.\n * @param contextIndex Index under which to find the context for the hook when it's being invoked.\n * @param indexInFactory Only required for `multi` providers. Index of the provider in the multi\n * provider factory.\n */\nfunction registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {\n    const providerIsTypeProvider = isTypeProvider(provider);\n    const providerIsClassProvider = isClassProvider(provider);\n    if (providerIsTypeProvider || providerIsClassProvider) {\n        // Resolve forward references as `useClass` can hold a forward reference.\n        const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;\n        const prototype = classToken.prototype;\n        const ngOnDestroy = prototype.ngOnDestroy;\n        if (ngOnDestroy) {\n            const hooks = tView.destroyHooks || (tView.destroyHooks = []);\n            if (!providerIsTypeProvider && provider.multi) {\n                ngDevMode &&\n                    assertDefined(indexInFactory, 'indexInFactory when registering multi factory destroy hook');\n                const existingCallbacksIndex = hooks.indexOf(contextIndex);\n                if (existingCallbacksIndex === -1) {\n                    hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);\n                }\n                else {\n                    hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);\n                }\n            }\n            else {\n                hooks.push(contextIndex, ngOnDestroy);\n            }\n        }\n    }\n}\n/**\n * Add a factory in a multi factory.\n * @returns Index at which the factory was inserted.\n */\nfunction multiFactoryAdd(multiFactory, factory, isComponentProvider) {\n    if (isComponentProvider) {\n        multiFactory.componentProviders++;\n    }\n    return multiFactory.multi.push(factory) - 1;\n}\n/**\n * Returns the index of item in the array, but only in the begin to end range.\n */\nfunction indexOf(item, arr, begin, end) {\n    for (let i = begin; i < end; i++) {\n        if (arr[i] === item)\n            return i;\n    }\n    return -1;\n}\n/**\n * Use this with `multi` `providers`.\n */\nfunction multiProvidersFactoryResolver(_, tData, lData, tNode) {\n    return multiResolve(this.multi, []);\n}\n/**\n * Use this with `multi` `viewProviders`.\n *\n * This factory knows how to concatenate itself with the existing `multi` `providers`.\n */\nfunction multiViewProvidersFactoryResolver(_, tData, lView, tNode) {\n    const factories = this.multi;\n    let result;\n    if (this.providerFactory) {\n        const componentCount = this.providerFactory.componentProviders;\n        const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);\n        // Copy the section of the array which contains `multi` `providers` from the component\n        result = multiProviders.slice(0, componentCount);\n        // Insert the `viewProvider` instances.\n        multiResolve(factories, result);\n        // Copy the section of the array which contains `multi` `providers` from other directives\n        for (let i = componentCount; i < multiProviders.length; i++) {\n            result.push(multiProviders[i]);\n        }\n    }\n    else {\n        result = [];\n        // Insert the `viewProvider` instances.\n        multiResolve(factories, result);\n    }\n    return result;\n}\n/**\n * Maps an array of factories into an array of values.\n */\nfunction multiResolve(factories, result) {\n    for (let i = 0; i < factories.length; i++) {\n        const factory = factories[i];\n        result.push(factory());\n    }\n    return result;\n}\n/**\n * Creates a multi factory.\n */\nfunction multiFactory(factoryFn, index, isViewProvider, isComponent, f) {\n    const factory = new NodeInjectorFactory(factoryFn, isViewProvider, \u0275\u0275directiveInject);\n    factory.multi = [];\n    factory.index = index;\n    factory.componentProviders = 0;\n    multiFactoryAdd(factory, f, isComponent && !isViewProvider);\n    return factory;\n}\n\n/**\n * This feature resolves the providers of a directive (or component),\n * and publish them into the DI system, making it visible to others for injection.\n *\n * For example:\n * ```ts\n * class ComponentWithProviders {\n *   constructor(private greeter: GreeterDE) {}\n *\n *   static \u0275cmp = defineComponent({\n *     type: ComponentWithProviders,\n *     selectors: [['component-with-providers']],\n *    factory: () => new ComponentWithProviders(directiveInject(GreeterDE as any)),\n *    decls: 1,\n *    vars: 1,\n *    template: function(fs: RenderFlags, ctx: ComponentWithProviders) {\n *      if (fs & RenderFlags.Create) {\n *        \u0275\u0275text(0);\n *      }\n *      if (fs & RenderFlags.Update) {\n *        \u0275\u0275textInterpolate(ctx.greeter.greet());\n *      }\n *    },\n *    features: [\u0275\u0275ProvidersFeature([GreeterDE])]\n *  });\n * }\n * ```\n *\n * @param definition\n *\n * @codeGenApi\n */\nfunction \u0275\u0275ProvidersFeature(providers, viewProviders = []) {\n    return (definition) => {\n        definition.providersResolver =\n            (def, processProvidersFn) => {\n                return providersResolver(def, //\n                processProvidersFn ? processProvidersFn(providers) : providers, //\n                viewProviders);\n            };\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Represents an instance of an `NgModule` created by an `NgModuleFactory`.\n * Provides access to the `NgModule` instance and related objects.\n *\n * @publicApi\n */\nclass NgModuleRef$1 {\n}\n/**\n * @publicApi\n *\n * @deprecated\n * This class was mostly used as a part of ViewEngine-based JIT API and is no longer needed in Ivy\n * JIT mode. See [JIT API changes due to ViewEngine deprecation](guide/deprecations#jit-api-changes)\n * for additional context. Angular provides APIs that accept NgModule classes directly (such as\n * [PlatformRef.bootstrapModule](api/core/PlatformRef#bootstrapModule) and\n * [createNgModule](api/core/createNgModule)), consider switching to those APIs instead of\n * using factory-based ones.\n */\nclass NgModuleFactory$1 {\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns a new NgModuleRef instance based on the NgModule class and parent injector provided.\n *\n * @param ngModule NgModule class.\n * @param parentInjector Optional injector instance to use as a parent for the module injector. If\n *     not provided, `NullInjector` will be used instead.\n * @returns NgModuleRef that represents an NgModule instance.\n *\n * @publicApi\n */\nfunction createNgModule(ngModule, parentInjector) {\n    return new NgModuleRef(ngModule, parentInjector ?? null);\n}\n/**\n * The `createNgModule` function alias for backwards-compatibility.\n * Please avoid using it directly and use `createNgModule` instead.\n *\n * @deprecated Use `createNgModule` instead.\n */\nconst createNgModuleRef = createNgModule;\nclass NgModuleRef extends NgModuleRef$1 {\n    constructor(ngModuleType, _parent) {\n        super();\n        this._parent = _parent;\n        // tslint:disable-next-line:require-internal-with-underscore\n        this._bootstrapComponents = [];\n        this.destroyCbs = [];\n        // When bootstrapping a module we have a dependency graph that looks like this:\n        // ApplicationRef -> ComponentFactoryResolver -> NgModuleRef. The problem is that if the\n        // module being resolved tries to inject the ComponentFactoryResolver, it'll create a\n        // circular dependency which will result in a runtime error, because the injector doesn't\n        // exist yet. We work around the issue by creating the ComponentFactoryResolver ourselves\n        // and providing it, rather than letting the injector resolve it.\n        this.componentFactoryResolver = new ComponentFactoryResolver(this);\n        const ngModuleDef = getNgModuleDef(ngModuleType);\n        ngDevMode &&\n            assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);\n        this._bootstrapComponents = maybeUnwrapFn$1(ngModuleDef.bootstrap);\n        this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [\n            { provide: NgModuleRef$1, useValue: this }, {\n                provide: ComponentFactoryResolver$1,\n                useValue: this.componentFactoryResolver\n            }\n        ], stringify(ngModuleType), new Set(['environment']));\n        // We need to resolve the injector types separately from the injector creation, because\n        // the module might be trying to use this ref in its constructor for DI which will cause a\n        // circular error that will eventually error out, because the injector isn't created yet.\n        this._r3Injector.resolveInjectorInitializers();\n        this.instance = this._r3Injector.get(ngModuleType);\n    }\n    get injector() {\n        return this._r3Injector;\n    }\n    destroy() {\n        ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n        const injector = this._r3Injector;\n        !injector.destroyed && injector.destroy();\n        this.destroyCbs.forEach(fn => fn());\n        this.destroyCbs = null;\n    }\n    onDestroy(callback) {\n        ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n        this.destroyCbs.push(callback);\n    }\n}\nclass NgModuleFactory extends NgModuleFactory$1 {\n    constructor(moduleType) {\n        super();\n        this.moduleType = moduleType;\n    }\n    create(parentInjector) {\n        return new NgModuleRef(this.moduleType, parentInjector);\n    }\n}\nclass EnvironmentNgModuleRefAdapter extends NgModuleRef$1 {\n    constructor(providers, parent, source) {\n        super();\n        this.componentFactoryResolver = new ComponentFactoryResolver(this);\n        this.instance = null;\n        const injector = new R3Injector([\n            ...providers,\n            { provide: NgModuleRef$1, useValue: this },\n            { provide: ComponentFactoryResolver$1, useValue: this.componentFactoryResolver },\n        ], parent || getNullInjector(), source, new Set(['environment']));\n        this.injector = injector;\n        injector.resolveInjectorInitializers();\n    }\n    destroy() {\n        this.injector.destroy();\n    }\n    onDestroy(callback) {\n        this.injector.onDestroy(callback);\n    }\n}\n/**\n * Create a new environment injector.\n *\n * Learn more about environment injectors in\n * [this guide](guide/standalone-components#environment-injectors).\n *\n * @param providers An array of providers.\n * @param parent A parent environment injector.\n * @param debugName An optional name for this injector instance, which will be used in error\n *     messages.\n *\n * @publicApi\n * @developerPreview\n */\nfunction createEnvironmentInjector(providers, parent, debugName = null) {\n    const adapter = new EnvironmentNgModuleRefAdapter(providers, parent, debugName);\n    return adapter.injector;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A service used by the framework to create instances of standalone injectors. Those injectors are\n * created on demand in case of dynamic component instantiation and contain ambient providers\n * collected from the imports graph rooted at a given standalone component.\n */\nclass StandaloneService {\n    constructor(_injector) {\n        this._injector = _injector;\n        this.cachedInjectors = new Map();\n    }\n    getOrCreateStandaloneInjector(componentDef) {\n        if (!componentDef.standalone) {\n            return null;\n        }\n        if (!this.cachedInjectors.has(componentDef.id)) {\n            const providers = internalImportProvidersFrom(false, componentDef.type);\n            const standaloneInjector = providers.length > 0 ?\n                createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) :\n                null;\n            this.cachedInjectors.set(componentDef.id, standaloneInjector);\n        }\n        return this.cachedInjectors.get(componentDef.id);\n    }\n    ngOnDestroy() {\n        try {\n            for (const injector of this.cachedInjectors.values()) {\n                if (injector !== null) {\n                    injector.destroy();\n                }\n            }\n        }\n        finally {\n            this.cachedInjectors.clear();\n        }\n    }\n}\n/** @nocollapse */\nStandaloneService.\u0275prov = \u0275\u0275defineInjectable({\n    token: StandaloneService,\n    providedIn: 'environment',\n    factory: () => new StandaloneService(\u0275\u0275inject(EnvironmentInjector)),\n});\n/**\n * A feature that acts as a setup code for the {@link StandaloneService}.\n *\n * The most important responsibility of this feature is to expose the \"getStandaloneInjector\"\n * function (an entry points to a standalone injector creation) on a component definition object. We\n * go through the features infrastructure to make sure that the standalone injector creation logic\n * is tree-shakable and not included in applications that don't use standalone components.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275StandaloneFeature(definition) {\n    definition.getStandaloneInjector = (parentInjector) => {\n        return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(definition);\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Retrieves the component instance associated with a given DOM element.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <div>\n *     <child-comp></child-comp>\n *   </div>\n * </app-root>\n * ```\n *\n * Calling `getComponent` on `<child-comp>` will return the instance of `ChildComponent`\n * associated with this DOM element.\n *\n * Calling the function on `<app-root>` will return the `MyApp` instance.\n *\n *\n * @param element DOM element from which the component should be retrieved.\n * @returns Component instance associated with the element or `null` if there\n *    is no component associated with it.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getComponent(element) {\n    ngDevMode && assertDomElement(element);\n    const context = getLContext(element);\n    if (context === null)\n        return null;\n    if (context.component === undefined) {\n        const lView = context.lView;\n        if (lView === null) {\n            return null;\n        }\n        context.component = getComponentAtNodeIndex(context.nodeIndex, lView);\n    }\n    return context.component;\n}\n/**\n * If inside an embedded view (e.g. `*ngIf` or `*ngFor`), retrieves the context of the embedded\n * view that the element is part of. Otherwise retrieves the instance of the component whose view\n * owns the element (in this case, the result is the same as calling `getOwningComponent`).\n *\n * @param element Element for which to get the surrounding component instance.\n * @returns Instance of the component that is around the element or null if the element isn't\n *    inside any component.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getContext(element) {\n    assertDomElement(element);\n    const context = getLContext(element);\n    const lView = context ? context.lView : null;\n    return lView === null ? null : lView[CONTEXT];\n}\n/**\n * Retrieves the component instance whose view contains the DOM element.\n *\n * For example, if `<child-comp>` is used in the template of `<app-comp>`\n * (i.e. a `ViewChild` of `<app-comp>`), calling `getOwningComponent` on `<child-comp>`\n * would return `<app-comp>`.\n *\n * @param elementOrDir DOM element, component or directive instance\n *    for which to retrieve the root components.\n * @returns Component instance whose view owns the DOM element or null if the element is not\n *    part of a component view.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getOwningComponent(elementOrDir) {\n    const context = getLContext(elementOrDir);\n    let lView = context ? context.lView : null;\n    if (lView === null)\n        return null;\n    let parent;\n    while (lView[TVIEW].type === 2 /* TViewType.Embedded */ && (parent = getLViewParent(lView))) {\n        lView = parent;\n    }\n    return lView[FLAGS] & 256 /* LViewFlags.IsRoot */ ? null : lView[CONTEXT];\n}\n/**\n * Retrieves all root components associated with a DOM element, directive or component instance.\n * Root components are those which have been bootstrapped by Angular.\n *\n * @param elementOrDir DOM element, component or directive instance\n *    for which to retrieve the root components.\n * @returns Root components associated with the target object.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getRootComponents(elementOrDir) {\n    const lView = readPatchedLView(elementOrDir);\n    return lView !== null ? [getRootContext(lView)] : [];\n}\n/**\n * Retrieves an `Injector` associated with an element, component or directive instance.\n *\n * @param elementOrDir DOM element, component or directive instance for which to\n *    retrieve the injector.\n * @returns Injector associated with the element, component or directive instance.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getInjector(elementOrDir) {\n    const context = getLContext(elementOrDir);\n    const lView = context ? context.lView : null;\n    if (lView === null)\n        return Injector.NULL;\n    const tNode = lView[TVIEW].data[context.nodeIndex];\n    return new NodeInjector(tNode, lView);\n}\n/**\n * Retrieve a set of injection tokens at a given DOM node.\n *\n * @param element Element for which the injection tokens should be retrieved.\n */\nfunction getInjectionTokens(element) {\n    const context = getLContext(element);\n    const lView = context ? context.lView : null;\n    if (lView === null)\n        return [];\n    const tView = lView[TVIEW];\n    const tNode = tView.data[context.nodeIndex];\n    const providerTokens = [];\n    const startIndex = tNode.providerIndexes & 1048575 /* TNodeProviderIndexes.ProvidersStartIndexMask */;\n    const endIndex = tNode.directiveEnd;\n    for (let i = startIndex; i < endIndex; i++) {\n        let value = tView.data[i];\n        if (isDirectiveDefHack(value)) {\n            // The fact that we sometimes store Type and sometimes DirectiveDef in this location is a\n            // design flaw.  We should always store same type so that we can be monomorphic. The issue\n            // is that for Components/Directives we store the def instead the type. The correct behavior\n            // is that we should always be storing injectable type in this location.\n            value = value.type;\n        }\n        providerTokens.push(value);\n    }\n    return providerTokens;\n}\n/**\n * Retrieves directive instances associated with a given DOM node. Does not include\n * component instances.\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <button my-button></button>\n *   <my-comp></my-comp>\n * </app-root>\n * ```\n *\n * Calling `getDirectives` on `<button>` will return an array with an instance of the `MyButton`\n * directive that is associated with the DOM node.\n *\n * Calling `getDirectives` on `<my-comp>` will return an empty array.\n *\n * @param node DOM node for which to get the directives.\n * @returns Array of directives associated with the node.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getDirectives(node) {\n    // Skip text nodes because we can't have directives associated with them.\n    if (node instanceof Text) {\n        return [];\n    }\n    const context = getLContext(node);\n    const lView = context ? context.lView : null;\n    if (lView === null) {\n        return [];\n    }\n    const tView = lView[TVIEW];\n    const nodeIndex = context.nodeIndex;\n    if (!tView?.data[nodeIndex]) {\n        return [];\n    }\n    if (context.directives === undefined) {\n        context.directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);\n    }\n    // The `directives` in this case are a named array called `LComponentView`. Clone the\n    // result so we don't expose an internal data structure in the user's console.\n    return context.directives === null ? [] : [...context.directives];\n}\n/**\n * Returns the debug (partial) metadata for a particular directive or component instance.\n * The function accepts an instance of a directive or component and returns the corresponding\n * metadata.\n *\n * @param directiveOrComponentInstance Instance of a directive or component\n * @returns metadata of the passed directive or component\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getDirectiveMetadata(directiveOrComponentInstance) {\n    const { constructor } = directiveOrComponentInstance;\n    if (!constructor) {\n        throw new Error('Unable to find the instance constructor');\n    }\n    // In case a component inherits from a directive, we may have component and directive metadata\n    // To ensure we don't get the metadata of the directive, we want to call `getComponentDef` first.\n    const componentDef = getComponentDef$1(constructor);\n    if (componentDef) {\n        return {\n            inputs: componentDef.inputs,\n            outputs: componentDef.outputs,\n            encapsulation: componentDef.encapsulation,\n            changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush :\n                ChangeDetectionStrategy.Default\n        };\n    }\n    const directiveDef = getDirectiveDef(constructor);\n    if (directiveDef) {\n        return { inputs: directiveDef.inputs, outputs: directiveDef.outputs };\n    }\n    return null;\n}\n/**\n * Retrieve map of local references.\n *\n * The references are retrieved as a map of local reference name to element or directive instance.\n *\n * @param target DOM element, component or directive instance for which to retrieve\n *    the local references.\n */\nfunction getLocalRefs(target) {\n    const context = getLContext(target);\n    if (context === null)\n        return {};\n    if (context.localRefs === undefined) {\n        const lView = context.lView;\n        if (lView === null) {\n            return {};\n        }\n        context.localRefs = discoverLocalRefs(lView, context.nodeIndex);\n    }\n    return context.localRefs || {};\n}\n/**\n * Retrieves the host element of a component or directive instance.\n * The host element is the DOM element that matched the selector of the directive.\n *\n * @param componentOrDirective Component or directive instance for which the host\n *     element should be retrieved.\n * @returns Host element of the target.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getHostElement(componentOrDirective) {\n    return getLContext(componentOrDirective).native;\n}\n/**\n * Retrieves the rendered text for a given component.\n *\n * This function retrieves the host element of a component and\n * and then returns the `textContent` for that element. This implies\n * that the text returned will include re-projected content of\n * the component as well.\n *\n * @param component The component to return the content text for.\n */\nfunction getRenderedText(component) {\n    const hostElement = getHostElement(component);\n    return hostElement.textContent || '';\n}\n/**\n * Retrieves a list of event listeners associated with a DOM element. The list does include host\n * listeners, but it does not include event listeners defined outside of the Angular context\n * (e.g. through `addEventListener`).\n *\n * @usageNotes\n * Given the following DOM structure:\n *\n * ```html\n * <app-root>\n *   <div (click)=\"doSomething()\"></div>\n * </app-root>\n * ```\n *\n * Calling `getListeners` on `<div>` will return an object that looks as follows:\n *\n * ```ts\n * {\n *   name: 'click',\n *   element: <div>,\n *   callback: () => doSomething(),\n *   useCapture: false\n * }\n * ```\n *\n * @param element Element for which the DOM listeners should be retrieved.\n * @returns Array of event listeners on the DOM element.\n *\n * @publicApi\n * @globalApi ng\n */\nfunction getListeners(element) {\n    ngDevMode && assertDomElement(element);\n    const lContext = getLContext(element);\n    const lView = lContext === null ? null : lContext.lView;\n    if (lView === null)\n        return [];\n    const tView = lView[TVIEW];\n    const lCleanup = lView[CLEANUP];\n    const tCleanup = tView.cleanup;\n    const listeners = [];\n    if (tCleanup && lCleanup) {\n        for (let i = 0; i < tCleanup.length;) {\n            const firstParam = tCleanup[i++];\n            const secondParam = tCleanup[i++];\n            if (typeof firstParam === 'string') {\n                const name = firstParam;\n                const listenerElement = unwrapRNode(lView[secondParam]);\n                const callback = lCleanup[tCleanup[i++]];\n                const useCaptureOrIndx = tCleanup[i++];\n                // if useCaptureOrIndx is boolean then report it as is.\n                // if useCaptureOrIndx is positive number then it in unsubscribe method\n                // if useCaptureOrIndx is negative number then it is a Subscription\n                const type = (typeof useCaptureOrIndx === 'boolean' || useCaptureOrIndx >= 0) ? 'dom' : 'output';\n                const useCapture = typeof useCaptureOrIndx === 'boolean' ? useCaptureOrIndx : false;\n                if (element == listenerElement) {\n                    listeners.push({ element, name, callback, useCapture, type });\n                }\n            }\n        }\n    }\n    listeners.sort(sortListeners);\n    return listeners;\n}\nfunction sortListeners(a, b) {\n    if (a.name == b.name)\n        return 0;\n    return a.name < b.name ? -1 : 1;\n}\n/**\n * This function should not exist because it is megamorphic and only mostly correct.\n *\n * See call site for more info.\n */\nfunction isDirectiveDefHack(obj) {\n    return obj.type !== undefined && obj.template !== undefined && obj.declaredInputs !== undefined;\n}\n/**\n * Returns the attached `DebugNode` instance for an element in the DOM.\n *\n * @param element DOM element which is owned by an existing component's view.\n */\nfunction getDebugNode(element) {\n    if (ngDevMode && !(element instanceof Node)) {\n        throw new Error('Expecting instance of DOM Element');\n    }\n    const lContext = getLContext(element);\n    const lView = lContext ? lContext.lView : null;\n    if (lView === null) {\n        return null;\n    }\n    const nodeIndex = lContext.nodeIndex;\n    if (nodeIndex !== -1) {\n        const valueInLView = lView[nodeIndex];\n        // this means that value in the lView is a component with its own\n        // data. In this situation the TNode is not accessed at the same spot.\n        const tNode = isLView(valueInLView) ? valueInLView[T_HOST] : getTNode(lView[TVIEW], nodeIndex);\n        ngDevMode &&\n            assertEqual(tNode.index, nodeIndex, 'Expecting that TNode at index is same as index');\n        return buildDebugNode(tNode, lView);\n    }\n    return null;\n}\n/**\n * Retrieve the component `LView` from component/element.\n *\n * NOTE: `LView` is a private and should not be leaked outside.\n *       Don't export this method to `ng.*` on window.\n *\n * @param target DOM element or component instance for which to retrieve the LView.\n */\nfunction getComponentLView(target) {\n    const lContext = getLContext(target);\n    const nodeIndx = lContext.nodeIndex;\n    const lView = lContext.lView;\n    ngDevMode && assertLView(lView);\n    const componentLView = lView[nodeIndx];\n    ngDevMode && assertLView(componentLView);\n    return componentLView;\n}\n/** Asserts that a value is a DOM Element. */\nfunction assertDomElement(value) {\n    if (typeof Element !== 'undefined' && !(value instanceof Element)) {\n        throw new Error('Expecting instance of DOM Element');\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Adds decorator, constructor, and property metadata to a given type via static metadata fields\n * on the type.\n *\n * These metadata fields can later be read with Angular's `ReflectionCapabilities` API.\n *\n * Calls to `setClassMetadata` can be guarded by ngDevMode, resulting in the metadata assignments\n * being tree-shaken away during production builds.\n */\nfunction setClassMetadata(type, decorators, ctorParameters, propDecorators) {\n    return noSideEffects(() => {\n        const clazz = type;\n        if (decorators !== null) {\n            if (clazz.hasOwnProperty('decorators') && clazz.decorators !== undefined) {\n                clazz.decorators.push(...decorators);\n            }\n            else {\n                clazz.decorators = decorators;\n            }\n        }\n        if (ctorParameters !== null) {\n            // Rather than merging, clobber the existing parameters. If other projects exist which\n            // use tsickle-style annotations and reflect over them in the same way, this could\n            // cause issues, but that is vanishingly unlikely.\n            clazz.ctorParameters = ctorParameters;\n        }\n        if (propDecorators !== null) {\n            // The property decorator objects are merged as it is possible different fields have\n            // different decorator types. Decorators on individual fields are not merged, as it's\n            // also incredibly unlikely that a field will be decorated both with an Angular\n            // decorator and a non-Angular decorator that's also been downleveled.\n            if (clazz.hasOwnProperty('propDecorators') && clazz.propDecorators !== undefined) {\n                clazz.propDecorators = { ...clazz.propDecorators, ...propDecorators };\n            }\n            else {\n                clazz.propDecorators = propDecorators;\n            }\n        }\n    });\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Bindings for pure functions are stored after regular bindings.\n *\n * |-------decls------|---------vars---------|                 |----- hostVars (dir1) ------|\n * ------------------------------------------------------------------------------------------\n * | nodes/refs/pipes | bindings | fn slots  | injector | dir1 | host bindings | host slots |\n * ------------------------------------------------------------------------------------------\n *                    ^                      ^\n *      TView.bindingStartIndex      TView.expandoStartIndex\n *\n * Pure function instructions are given an offset from the binding root. Adding the offset to the\n * binding root gives the first index where the bindings are stored. In component views, the binding\n * root is the bindingStartIndex. In host bindings, the binding root is the expandoStartIndex +\n * any directive instances + any hostVars in directives evaluated before it.\n *\n * See VIEW_DATA.md for more information about host binding resolution.\n */\n/**\n * If the value hasn't been saved, calls the pure function to store and return the\n * value. If it has been saved, returns the saved value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns a value\n * @param thisArg Optional calling context of pureFn\n * @returns value\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pureFunction0(slotOffset, pureFn, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    return lView[bindingIndex] === NO_CHANGE ?\n        updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) :\n        getBinding(lView, bindingIndex);\n}\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pureFunction1(slotOffset, pureFn, exp, thisArg) {\n    return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {\n    return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {\n    return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {\n    return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n    return bindingUpdated(lView, bindingIndex + 4, exp5) || different ?\n        updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) :\n            pureFn(exp1, exp2, exp3, exp4, exp5)) :\n        getBinding(lView, bindingIndex + 5);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n    return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ?\n        updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) :\n            pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) :\n        getBinding(lView, bindingIndex + 6);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n    return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ?\n        updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) :\n            pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) :\n        getBinding(lView, bindingIndex + 7);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param exp5\n * @param exp6\n * @param exp7\n * @param exp8\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {\n    const bindingIndex = getBindingRoot() + slotOffset;\n    const lView = getLView();\n    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n    return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ?\n        updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) :\n            pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) :\n        getBinding(lView, bindingIndex + 8);\n}\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pureFunctionV(slotOffset, pureFn, exps, thisArg) {\n    return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);\n}\n/**\n * Results of a pure function invocation are stored in LView in a dedicated slot that is initialized\n * to NO_CHANGE. In rare situations a pure pipe might throw an exception on the very first\n * invocation and not produce any valid results. In this case LView would keep holding the NO_CHANGE\n * value. The NO_CHANGE is not something that we can use in expressions / bindings thus we convert\n * it to `undefined`.\n */\nfunction getPureFunctionReturnValue(lView, returnValueIndex) {\n    ngDevMode && assertIndexInRange(lView, returnValueIndex);\n    const lastReturnValue = lView[returnValueIndex];\n    return lastReturnValue === NO_CHANGE ? undefined : lastReturnValue;\n}\n/**\n * If the value of the provided exp has changed, calls the pure function to return\n * an updated value. Or if the value has not changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn Function that returns an updated value\n * @param exp Updated expression value\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {\n    const bindingIndex = bindingRoot + slotOffset;\n    return bindingUpdated(lView, bindingIndex, exp) ?\n        updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) :\n        getPureFunctionReturnValue(lView, bindingIndex + 1);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {\n    const bindingIndex = bindingRoot + slotOffset;\n    return bindingUpdated2(lView, bindingIndex, exp1, exp2) ?\n        updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) :\n        getPureFunctionReturnValue(lView, bindingIndex + 2);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {\n    const bindingIndex = bindingRoot + slotOffset;\n    return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ?\n        updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) :\n        getPureFunctionReturnValue(lView, bindingIndex + 3);\n}\n/**\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn\n * @param exp1\n * @param exp2\n * @param exp3\n * @param exp4\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n *\n */\nfunction pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {\n    const bindingIndex = bindingRoot + slotOffset;\n    return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ?\n        updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) :\n        getPureFunctionReturnValue(lView, bindingIndex + 4);\n}\n/**\n * pureFunction instruction that can support any number of bindings.\n *\n * If the value of any provided exp has changed, calls the pure function to return\n * an updated value. Or if no values have changed, returns cached value.\n *\n * @param lView LView in which the function is being executed.\n * @param bindingRoot Binding root index.\n * @param slotOffset the offset from binding root to the reserved slot\n * @param pureFn A pure function that takes binding values and builds an object or array\n * containing those values.\n * @param exps An array of binding values\n * @param thisArg Optional calling context of pureFn\n * @returns Updated or cached value\n */\nfunction pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {\n    let bindingIndex = bindingRoot + slotOffset;\n    let different = false;\n    for (let i = 0; i < exps.length; i++) {\n        bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);\n    }\n    return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) :\n        getPureFunctionReturnValue(lView, bindingIndex);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create a pipe.\n *\n * @param index Pipe index where the pipe will be stored.\n * @param pipeName The name of the pipe\n * @returns T the instance of the pipe.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pipe(index, pipeName) {\n    const tView = getTView();\n    let pipeDef;\n    const adjustedIndex = index + HEADER_OFFSET;\n    if (tView.firstCreatePass) {\n        // The `getPipeDef` throws if a pipe with a given name is not found\n        // (so we use non-null assertion below).\n        pipeDef = getPipeDef(pipeName, tView.pipeRegistry);\n        tView.data[adjustedIndex] = pipeDef;\n        if (pipeDef.onDestroy) {\n            (tView.destroyHooks || (tView.destroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy);\n        }\n    }\n    else {\n        pipeDef = tView.data[adjustedIndex];\n    }\n    const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));\n    const previousInjectImplementation = setInjectImplementation(\u0275\u0275directiveInject);\n    try {\n        // DI for pipes is supposed to behave like directives when placed on a component\n        // host node, which means that we have to disable access to `viewProviders`.\n        const previousIncludeViewProviders = setIncludeViewProviders(false);\n        const pipeInstance = pipeFactory();\n        setIncludeViewProviders(previousIncludeViewProviders);\n        store(tView, getLView(), adjustedIndex, pipeInstance);\n        return pipeInstance;\n    }\n    finally {\n        // we have to restore the injector implementation in finally, just in case the creation of the\n        // pipe throws an error.\n        setInjectImplementation(previousInjectImplementation);\n    }\n}\n/**\n * Searches the pipe registry for a pipe with the given name. If one is found,\n * returns the pipe. Otherwise, an error is thrown because the pipe cannot be resolved.\n *\n * @param name Name of pipe to resolve\n * @param registry Full list of available pipes\n * @returns Matching PipeDef\n */\nfunction getPipeDef(name, registry) {\n    if (registry) {\n        for (let i = registry.length - 1; i >= 0; i--) {\n            const pipeDef = registry[i];\n            if (name === pipeDef.name) {\n                return pipeDef;\n            }\n        }\n    }\n    if (ngDevMode) {\n        throw new RuntimeError(-302 /* RuntimeErrorCode.PIPE_NOT_FOUND */, getPipeNotFoundErrorMessage(name));\n    }\n}\n/**\n * Generates a helpful error message for the user when a pipe is not found.\n *\n * @param name Name of the missing pipe\n * @returns The error message\n */\nfunction getPipeNotFoundErrorMessage(name) {\n    const lView = getLView();\n    const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n    const context = declarationLView[CONTEXT];\n    const hostIsStandalone = isHostComponentStandalone(lView);\n    const componentInfoMessage = context ? ` in the '${context.constructor.name}' component` : '';\n    const verifyMessage = `Verify that it is ${hostIsStandalone ? 'included in the \\'@Component.imports\\' of this component' :\n        'declared or imported in this module'}`;\n    const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;\n    return errorMessage;\n}\n/**\n * Invokes a pipe with 1 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pipeBind1(index, slotOffset, v1) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ?\n        pureFunction1Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, pipeInstance) :\n        pipeInstance.transform(v1);\n}\n/**\n * Invokes a pipe with 2 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pipeBind2(index, slotOffset, v1, v2) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ?\n        pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) :\n        pipeInstance.transform(v1, v2);\n}\n/**\n * Invokes a pipe with 3 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 4rd argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pipeBind3(index, slotOffset, v1, v2, v3) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ?\n        pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) :\n        pipeInstance.transform(v1, v2, v3);\n}\n/**\n * Invokes a pipe with 4 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 3rd argument to {@link PipeTransform#transform}.\n * @param v4 4th argument to {@link PipeTransform#transform}.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pipeBind4(index, slotOffset, v1, v2, v3, v4) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) :\n        pipeInstance.transform(v1, v2, v3, v4);\n}\n/**\n * Invokes a pipe with variable number of arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space\n * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275pipeBindV(index, slotOffset, values) {\n    const adjustedIndex = index + HEADER_OFFSET;\n    const lView = getLView();\n    const pipeInstance = load(lView, adjustedIndex);\n    return isPure(lView, adjustedIndex) ?\n        pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) :\n        pipeInstance.transform.apply(pipeInstance, values);\n}\nfunction isPure(lView, index) {\n    return lView[TVIEW].data[index].pure;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass EventEmitter_ extends Subject {\n    constructor(isAsync = false) {\n        super();\n        this.__isAsync = isAsync;\n    }\n    emit(value) {\n        super.next(value);\n    }\n    subscribe(observerOrNext, error, complete) {\n        let nextFn = observerOrNext;\n        let errorFn = error || (() => null);\n        let completeFn = complete;\n        if (observerOrNext && typeof observerOrNext === 'object') {\n            const observer = observerOrNext;\n            nextFn = observer.next?.bind(observer);\n            errorFn = observer.error?.bind(observer);\n            completeFn = observer.complete?.bind(observer);\n        }\n        if (this.__isAsync) {\n            errorFn = _wrapInTimeout(errorFn);\n            if (nextFn) {\n                nextFn = _wrapInTimeout(nextFn);\n            }\n            if (completeFn) {\n                completeFn = _wrapInTimeout(completeFn);\n            }\n        }\n        const sink = super.subscribe({ next: nextFn, error: errorFn, complete: completeFn });\n        if (observerOrNext instanceof Subscription) {\n            observerOrNext.add(sink);\n        }\n        return sink;\n    }\n}\nfunction _wrapInTimeout(fn) {\n    return (value) => {\n        setTimeout(fn, undefined, value);\n    };\n}\n/**\n * @publicApi\n */\nconst EventEmitter = EventEmitter_;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction symbolIterator() {\n    return this._results[getSymbolIterator()]();\n}\n/**\n * An unmodifiable list of items that Angular keeps up to date when the state\n * of the application changes.\n *\n * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}\n * provide.\n *\n * Implements an iterable interface, therefore it can be used in both ES6\n * javascript `for (var i of items)` loops as well as in Angular templates with\n * `*ngFor=\"let i of myList\"`.\n *\n * Changes can be observed by subscribing to the changes `Observable`.\n *\n * NOTE: In the future this class will implement an `Observable` interface.\n *\n * @usageNotes\n * ### Example\n * ```typescript\n * @Component({...})\n * class Container {\n *   @ViewChildren(Item) items:QueryList<Item>;\n * }\n * ```\n *\n * @publicApi\n */\nclass QueryList {\n    /**\n     * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change\n     *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in\n     *     the same result)\n     */\n    constructor(_emitDistinctChangesOnly = false) {\n        this._emitDistinctChangesOnly = _emitDistinctChangesOnly;\n        this.dirty = true;\n        this._results = [];\n        this._changesDetected = false;\n        this._changes = null;\n        this.length = 0;\n        this.first = undefined;\n        this.last = undefined;\n        // This function should be declared on the prototype, but doing so there will cause the class\n        // declaration to have side-effects and become not tree-shakable. For this reason we do it in\n        // the constructor.\n        // [getSymbolIterator()](): Iterator<T> { ... }\n        const symbol = getSymbolIterator();\n        const proto = QueryList.prototype;\n        if (!proto[symbol])\n            proto[symbol] = symbolIterator;\n    }\n    /**\n     * Returns `Observable` of `QueryList` notifying the subscriber of changes.\n     */\n    get changes() {\n        return this._changes || (this._changes = new EventEmitter());\n    }\n    /**\n     * Returns the QueryList entry at `index`.\n     */\n    get(index) {\n        return this._results[index];\n    }\n    /**\n     * See\n     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n     */\n    map(fn) {\n        return this._results.map(fn);\n    }\n    /**\n     * See\n     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n     */\n    filter(fn) {\n        return this._results.filter(fn);\n    }\n    /**\n     * See\n     * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n     */\n    find(fn) {\n        return this._results.find(fn);\n    }\n    /**\n     * See\n     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n     */\n    reduce(fn, init) {\n        return this._results.reduce(fn, init);\n    }\n    /**\n     * See\n     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n     */\n    forEach(fn) {\n        this._results.forEach(fn);\n    }\n    /**\n     * See\n     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n     */\n    some(fn) {\n        return this._results.some(fn);\n    }\n    /**\n     * Returns a copy of the internal results list as an Array.\n     */\n    toArray() {\n        return this._results.slice();\n    }\n    toString() {\n        return this._results.toString();\n    }\n    /**\n     * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that\n     * on change detection, it will not notify of changes to the queries, unless a new change\n     * occurs.\n     *\n     * @param resultsTree The query results to store\n     * @param identityAccessor Optional function for extracting stable object identity from a value\n     *    in the array. This function is executed for each element of the query result list while\n     *    comparing current query list with the new one (provided as a first argument of the `reset`\n     *    function) to detect if the lists are different. If the function is not provided, elements\n     *    are compared as is (without any pre-processing).\n     */\n    reset(resultsTree, identityAccessor) {\n        // Cast to `QueryListInternal` so that we can mutate fields which are readonly for the usage of\n        // QueryList (but not for QueryList itself.)\n        const self = this;\n        self.dirty = false;\n        const newResultFlat = flatten$1(resultsTree);\n        if (this._changesDetected = !arrayEquals(self._results, newResultFlat, identityAccessor)) {\n            self._results = newResultFlat;\n            self.length = newResultFlat.length;\n            self.last = newResultFlat[this.length - 1];\n            self.first = newResultFlat[0];\n        }\n    }\n    /**\n     * Triggers a change event by emitting on the `changes` {@link EventEmitter}.\n     */\n    notifyOnChanges() {\n        if (this._changes && (this._changesDetected || !this._emitDistinctChangesOnly))\n            this._changes.emit(this);\n    }\n    /** internal */\n    setDirty() {\n        this.dirty = true;\n    }\n    /** internal */\n    destroy() {\n        this.changes.complete();\n        this.changes.unsubscribe();\n    }\n}\nSymbol.iterator;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Represents an embedded template that can be used to instantiate embedded views.\n * To instantiate embedded views based on a template, use the `ViewContainerRef`\n * method `createEmbeddedView()`.\n *\n * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`\n * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view\n * is injected into the constructor of the directive,\n * using the `TemplateRef` token.\n *\n * You can also use a `Query` to find a `TemplateRef` associated with\n * a component or a directive.\n *\n * @see `ViewContainerRef`\n * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)\n *\n * @publicApi\n */\nclass TemplateRef {\n}\n/**\n * @internal\n * @nocollapse\n */\nTemplateRef.__NG_ELEMENT_ID__ = injectTemplateRef;\nconst ViewEngineTemplateRef = TemplateRef;\n// TODO(alxhub): combine interface and implementation. Currently this is challenging since something\n// in g3 depends on them being separate.\nconst R3TemplateRef = class TemplateRef extends ViewEngineTemplateRef {\n    constructor(_declarationLView, _declarationTContainer, elementRef) {\n        super();\n        this._declarationLView = _declarationLView;\n        this._declarationTContainer = _declarationTContainer;\n        this.elementRef = elementRef;\n    }\n    createEmbeddedView(context, injector) {\n        const embeddedTView = this._declarationTContainer.tViews;\n        const embeddedLView = createLView(this._declarationLView, embeddedTView, context, 16 /* LViewFlags.CheckAlways */, null, embeddedTView.declTNode, null, null, null, null, injector || null);\n        const declarationLContainer = this._declarationLView[this._declarationTContainer.index];\n        ngDevMode && assertLContainer(declarationLContainer);\n        embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;\n        const declarationViewLQueries = this._declarationLView[QUERIES];\n        if (declarationViewLQueries !== null) {\n            embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);\n        }\n        renderView(embeddedTView, embeddedLView, context);\n        return new ViewRef(embeddedLView);\n    }\n};\n/**\n * Creates a TemplateRef given a node.\n *\n * @returns The TemplateRef instance to use\n */\nfunction injectTemplateRef() {\n    return createTemplateRef(getCurrentTNode(), getLView());\n}\n/**\n * Creates a TemplateRef and stores it on the injector.\n *\n * @param hostTNode The node on which a TemplateRef is requested\n * @param hostLView The `LView` to which the node belongs\n * @returns The TemplateRef instance or null if we can't create a TemplateRef on a given node type\n */\nfunction createTemplateRef(hostTNode, hostLView) {\n    if (hostTNode.type & 4 /* TNodeType.Container */) {\n        ngDevMode && assertDefined(hostTNode.tViews, 'TView must be allocated');\n        return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Represents a container where one or more views can be attached to a component.\n *\n * Can contain *host views* (created by instantiating a\n * component with the `createComponent()` method), and *embedded views*\n * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).\n *\n * A view container instance can contain other view containers,\n * creating a [view hierarchy](guide/glossary#view-tree).\n *\n * @see `ComponentRef`\n * @see `EmbeddedViewRef`\n *\n * @publicApi\n */\nclass ViewContainerRef {\n}\n/**\n * @internal\n * @nocollapse\n */\nViewContainerRef.__NG_ELEMENT_ID__ = injectViewContainerRef;\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nfunction injectViewContainerRef() {\n    const previousTNode = getCurrentTNode();\n    return createContainerRef(previousTNode, getLView());\n}\nconst VE_ViewContainerRef = ViewContainerRef;\n// TODO(alxhub): cleaning up this indirection triggers a subtle bug in Closure in g3. Once the fix\n// for that lands, this can be cleaned up.\nconst R3ViewContainerRef = class ViewContainerRef extends VE_ViewContainerRef {\n    constructor(_lContainer, _hostTNode, _hostLView) {\n        super();\n        this._lContainer = _lContainer;\n        this._hostTNode = _hostTNode;\n        this._hostLView = _hostLView;\n    }\n    get element() {\n        return createElementRef(this._hostTNode, this._hostLView);\n    }\n    get injector() {\n        return new NodeInjector(this._hostTNode, this._hostLView);\n    }\n    /** @deprecated No replacement */\n    get parentInjector() {\n        const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);\n        if (hasParentInjector(parentLocation)) {\n            const parentView = getParentInjectorView(parentLocation, this._hostLView);\n            const injectorIndex = getParentInjectorIndex(parentLocation);\n            ngDevMode && assertNodeInjector(parentView, injectorIndex);\n            const parentTNode = parentView[TVIEW].data[injectorIndex + 8 /* NodeInjectorOffset.TNODE */];\n            return new NodeInjector(parentTNode, parentView);\n        }\n        else {\n            return new NodeInjector(null, this._hostLView);\n        }\n    }\n    clear() {\n        while (this.length > 0) {\n            this.remove(this.length - 1);\n        }\n    }\n    get(index) {\n        const viewRefs = getViewRefs(this._lContainer);\n        return viewRefs !== null && viewRefs[index] || null;\n    }\n    get length() {\n        return this._lContainer.length - CONTAINER_HEADER_OFFSET;\n    }\n    createEmbeddedView(templateRef, context, indexOrOptions) {\n        let index;\n        let injector;\n        if (typeof indexOrOptions === 'number') {\n            index = indexOrOptions;\n        }\n        else if (indexOrOptions != null) {\n            index = indexOrOptions.index;\n            injector = indexOrOptions.injector;\n        }\n        const viewRef = templateRef.createEmbeddedView(context || {}, injector);\n        this.insert(viewRef, index);\n        return viewRef;\n    }\n    createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector) {\n        const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);\n        let index;\n        // This function supports 2 signatures and we need to handle options correctly for both:\n        //   1. When first argument is a Component type. This signature also requires extra\n        //      options to be provided as as object (more ergonomic option).\n        //   2. First argument is a Component factory. In this case extra options are represented as\n        //      positional arguments. This signature is less ergonomic and will be deprecated.\n        if (isComponentFactory) {\n            if (ngDevMode) {\n                assertEqual(typeof indexOrOptions !== 'object', true, 'It looks like Component factory was provided as the first argument ' +\n                    'and an options object as the second argument. This combination of arguments ' +\n                    'is incompatible. You can either change the first argument to provide Component ' +\n                    'type or change the second argument to be a number (representing an index at ' +\n                    'which to insert the new component\\'s host view into this container)');\n            }\n            index = indexOrOptions;\n        }\n        else {\n            if (ngDevMode) {\n                assertDefined(getComponentDef$1(componentFactoryOrType), `Provided Component class doesn't contain Component definition. ` +\n                    `Please check whether provided class has @Component decorator.`);\n                assertEqual(typeof indexOrOptions !== 'number', true, 'It looks like Component type was provided as the first argument ' +\n                    'and a number (representing an index at which to insert the new component\\'s ' +\n                    'host view into this container as the second argument. This combination of arguments ' +\n                    'is incompatible. Please use an object as the second argument instead.');\n            }\n            const options = (indexOrOptions || {});\n            if (ngDevMode && options.environmentInjector && options.ngModuleRef) {\n                throwError(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);\n            }\n            index = options.index;\n            injector = options.injector;\n            projectableNodes = options.projectableNodes;\n            environmentInjector = options.environmentInjector || options.ngModuleRef;\n        }\n        const componentFactory = isComponentFactory ?\n            componentFactoryOrType :\n            new ComponentFactory(getComponentDef$1(componentFactoryOrType));\n        const contextInjector = injector || this.parentInjector;\n        // If an `NgModuleRef` is not provided explicitly, try retrieving it from the DI tree.\n        if (!environmentInjector && componentFactory.ngModule == null) {\n            // For the `ComponentFactory` case, entering this logic is very unlikely, since we expect that\n            // an instance of a `ComponentFactory`, resolved via `ComponentFactoryResolver` would have an\n            // `ngModule` field. This is possible in some test scenarios and potentially in some JIT-based\n            // use-cases. For the `ComponentFactory` case we preserve backwards-compatibility and try\n            // using a provided injector first, then fall back to the parent injector of this\n            // `ViewContainerRef` instance.\n            //\n            // For the factory-less case, it's critical to establish a connection with the module\n            // injector tree (by retrieving an instance of an `NgModuleRef` and accessing its injector),\n            // so that a component can use DI tokens provided in MgModules. For this reason, we can not\n            // rely on the provided injector, since it might be detached from the DI tree (for example, if\n            // it was created via `Injector.create` without specifying a parent injector, or if an\n            // injector is retrieved from an `NgModuleRef` created via `createNgModule` using an\n            // NgModule outside of a module tree). Instead, we always use `ViewContainerRef`'s parent\n            // injector, which is normally connected to the DI tree, which includes module injector\n            // subtree.\n            const _injector = isComponentFactory ? contextInjector : this.parentInjector;\n            // DO NOT REFACTOR. The code here used to have a `injector.get(NgModuleRef, null) ||\n            // undefined` expression which seems to cause internal google apps to fail. This is documented\n            // in the following internal bug issue: go/b/142967802\n            const result = _injector.get(EnvironmentInjector, null);\n            if (result) {\n                environmentInjector = result;\n            }\n        }\n        const componentRef = componentFactory.create(contextInjector, projectableNodes, undefined, environmentInjector);\n        this.insert(componentRef.hostView, index);\n        return componentRef;\n    }\n    insert(viewRef, index) {\n        const lView = viewRef._lView;\n        const tView = lView[TVIEW];\n        if (ngDevMode && viewRef.destroyed) {\n            throw new Error('Cannot insert a destroyed View in a ViewContainer!');\n        }\n        if (viewAttachedToContainer(lView)) {\n            // If view is already attached, detach it first so we clean up references appropriately.\n            const prevIdx = this.indexOf(viewRef);\n            // A view might be attached either to this or a different container. The `prevIdx` for\n            // those cases will be:\n            // equal to -1 for views attached to this ViewContainerRef\n            // >= 0 for views attached to a different ViewContainerRef\n            if (prevIdx !== -1) {\n                this.detach(prevIdx);\n            }\n            else {\n                const prevLContainer = lView[PARENT];\n                ngDevMode &&\n                    assertEqual(isLContainer(prevLContainer), true, 'An attached view should have its PARENT point to a container.');\n                // We need to re-create a R3ViewContainerRef instance since those are not stored on\n                // LView (nor anywhere else).\n                const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);\n                prevVCRef.detach(prevVCRef.indexOf(viewRef));\n            }\n        }\n        // Logical operation of adding `LView` to `LContainer`\n        const adjustedIdx = this._adjustIndex(index);\n        const lContainer = this._lContainer;\n        insertView(tView, lView, lContainer, adjustedIdx);\n        // Physical operation of adding the DOM nodes.\n        const beforeNode = getBeforeNodeForView(adjustedIdx, lContainer);\n        const renderer = lView[RENDERER];\n        const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);\n        if (parentRNode !== null) {\n            addViewToContainer(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);\n        }\n        viewRef.attachToViewContainerRef();\n        addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);\n        return viewRef;\n    }\n    move(viewRef, newIndex) {\n        if (ngDevMode && viewRef.destroyed) {\n            throw new Error('Cannot move a destroyed View in a ViewContainer!');\n        }\n        return this.insert(viewRef, newIndex);\n    }\n    indexOf(viewRef) {\n        const viewRefsArr = getViewRefs(this._lContainer);\n        return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;\n    }\n    remove(index) {\n        const adjustedIdx = this._adjustIndex(index, -1);\n        const detachedView = detachView(this._lContainer, adjustedIdx);\n        if (detachedView) {\n            // Before destroying the view, remove it from the container's array of `ViewRef`s.\n            // This ensures the view container length is updated before calling\n            // `destroyLView`, which could recursively call view container methods that\n            // rely on an accurate container length.\n            // (e.g. a method on this view container being called by a child directive's OnDestroy\n            // lifecycle hook)\n            removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);\n            destroyLView(detachedView[TVIEW], detachedView);\n        }\n    }\n    detach(index) {\n        const adjustedIdx = this._adjustIndex(index, -1);\n        const view = detachView(this._lContainer, adjustedIdx);\n        const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;\n        return wasDetached ? new ViewRef(view) : null;\n    }\n    _adjustIndex(index, shift = 0) {\n        if (index == null) {\n            return this.length + shift;\n        }\n        if (ngDevMode) {\n            assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);\n            // +1 because it's legal to insert at the end.\n            assertLessThan(index, this.length + 1 + shift, 'index');\n        }\n        return index;\n    }\n};\nfunction getViewRefs(lContainer) {\n    return lContainer[VIEW_REFS];\n}\nfunction getOrCreateViewRefs(lContainer) {\n    return (lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []));\n}\n/**\n * Creates a ViewContainerRef and stores it on the injector.\n *\n * @param ViewContainerRefToken The ViewContainerRef type\n * @param ElementRefToken The ElementRef type\n * @param hostTNode The node that is requesting a ViewContainerRef\n * @param hostLView The view to which the node belongs\n * @returns The ViewContainerRef instance to use\n */\nfunction createContainerRef(hostTNode, hostLView) {\n    ngDevMode && assertTNodeType(hostTNode, 12 /* TNodeType.AnyContainer */ | 3 /* TNodeType.AnyRNode */);\n    let lContainer;\n    const slotValue = hostLView[hostTNode.index];\n    if (isLContainer(slotValue)) {\n        // If the host is a container, we don't need to create a new LContainer\n        lContainer = slotValue;\n    }\n    else {\n        let commentNode;\n        // If the host is an element container, the native host element is guaranteed to be a\n        // comment and we can reuse that comment as anchor element for the new LContainer.\n        // The comment node in question is already part of the DOM structure so we don't need to append\n        // it again.\n        if (hostTNode.type & 8 /* TNodeType.ElementContainer */) {\n            commentNode = unwrapRNode(slotValue);\n        }\n        else {\n            // If the host is a regular element, we have to insert a comment node manually which will\n            // be used as an anchor when inserting elements. In this specific case we use low-level DOM\n            // manipulation to insert it.\n            const renderer = hostLView[RENDERER];\n            ngDevMode && ngDevMode.rendererCreateComment++;\n            commentNode = renderer.createComment(ngDevMode ? 'container' : '');\n            const hostNative = getNativeByTNode(hostTNode, hostLView);\n            const parentOfHostNative = nativeParentNode(renderer, hostNative);\n            nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);\n        }\n        hostLView[hostTNode.index] = lContainer =\n            createLContainer(slotValue, hostLView, commentNode, hostTNode);\n        addToViewTree(hostLView, lContainer);\n    }\n    return new R3ViewContainerRef(lContainer, hostTNode, hostLView);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd$1 = 1;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nconst unusedValueExportToPlacateAjd = 1;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst unusedValueToPlacateAjd = unusedValueExportToPlacateAjd$1 + unusedValueExportToPlacateAjd$6 + unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd;\nclass LQuery_ {\n    constructor(queryList) {\n        this.queryList = queryList;\n        this.matches = null;\n    }\n    clone() {\n        return new LQuery_(this.queryList);\n    }\n    setDirty() {\n        this.queryList.setDirty();\n    }\n}\nclass LQueries_ {\n    constructor(queries = []) {\n        this.queries = queries;\n    }\n    createEmbeddedView(tView) {\n        const tQueries = tView.queries;\n        if (tQueries !== null) {\n            const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;\n            const viewLQueries = [];\n            // An embedded view has queries propagated from a declaration view at the beginning of the\n            // TQueries collection and up until a first content query declared in the embedded view. Only\n            // propagated LQueries are created at this point (LQuery corresponding to declared content\n            // queries will be instantiated from the content query instructions for each directive).\n            for (let i = 0; i < noOfInheritedQueries; i++) {\n                const tQuery = tQueries.getByIndex(i);\n                const parentLQuery = this.queries[tQuery.indexInDeclarationView];\n                viewLQueries.push(parentLQuery.clone());\n            }\n            return new LQueries_(viewLQueries);\n        }\n        return null;\n    }\n    insertView(tView) {\n        this.dirtyQueriesWithMatches(tView);\n    }\n    detachView(tView) {\n        this.dirtyQueriesWithMatches(tView);\n    }\n    dirtyQueriesWithMatches(tView) {\n        for (let i = 0; i < this.queries.length; i++) {\n            if (getTQuery(tView, i).matches !== null) {\n                this.queries[i].setDirty();\n            }\n        }\n    }\n}\nclass TQueryMetadata_ {\n    constructor(predicate, flags, read = null) {\n        this.predicate = predicate;\n        this.flags = flags;\n        this.read = read;\n    }\n}\nclass TQueries_ {\n    constructor(queries = []) {\n        this.queries = queries;\n    }\n    elementStart(tView, tNode) {\n        ngDevMode &&\n            assertFirstCreatePass(tView, 'Queries should collect results on the first template pass only');\n        for (let i = 0; i < this.queries.length; i++) {\n            this.queries[i].elementStart(tView, tNode);\n        }\n    }\n    elementEnd(tNode) {\n        for (let i = 0; i < this.queries.length; i++) {\n            this.queries[i].elementEnd(tNode);\n        }\n    }\n    embeddedTView(tNode) {\n        let queriesForTemplateRef = null;\n        for (let i = 0; i < this.length; i++) {\n            const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;\n            const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);\n            if (tqueryClone) {\n                tqueryClone.indexInDeclarationView = i;\n                if (queriesForTemplateRef !== null) {\n                    queriesForTemplateRef.push(tqueryClone);\n                }\n                else {\n                    queriesForTemplateRef = [tqueryClone];\n                }\n            }\n        }\n        return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;\n    }\n    template(tView, tNode) {\n        ngDevMode &&\n            assertFirstCreatePass(tView, 'Queries should collect results on the first template pass only');\n        for (let i = 0; i < this.queries.length; i++) {\n            this.queries[i].template(tView, tNode);\n        }\n    }\n    getByIndex(index) {\n        ngDevMode && assertIndexInRange(this.queries, index);\n        return this.queries[index];\n    }\n    get length() {\n        return this.queries.length;\n    }\n    track(tquery) {\n        this.queries.push(tquery);\n    }\n}\nclass TQuery_ {\n    constructor(metadata, nodeIndex = -1) {\n        this.metadata = metadata;\n        this.matches = null;\n        this.indexInDeclarationView = -1;\n        this.crossesNgTemplate = false;\n        /**\n         * A flag indicating if a given query still applies to nodes it is crossing. We use this flag\n         * (alongside with _declarationNodeIndex) to know when to stop applying content queries to\n         * elements in a template.\n         */\n        this._appliesToNextNode = true;\n        this._declarationNodeIndex = nodeIndex;\n    }\n    elementStart(tView, tNode) {\n        if (this.isApplyingToNode(tNode)) {\n            this.matchTNode(tView, tNode);\n        }\n    }\n    elementEnd(tNode) {\n        if (this._declarationNodeIndex === tNode.index) {\n            this._appliesToNextNode = false;\n        }\n    }\n    template(tView, tNode) {\n        this.elementStart(tView, tNode);\n    }\n    embeddedTView(tNode, childQueryIndex) {\n        if (this.isApplyingToNode(tNode)) {\n            this.crossesNgTemplate = true;\n            // A marker indicating a `<ng-template>` element (a placeholder for query results from\n            // embedded views created based on this `<ng-template>`).\n            this.addMatch(-tNode.index, childQueryIndex);\n            return new TQuery_(this.metadata);\n        }\n        return null;\n    }\n    isApplyingToNode(tNode) {\n        if (this._appliesToNextNode &&\n            (this.metadata.flags & 1 /* QueryFlags.descendants */) !== 1 /* QueryFlags.descendants */) {\n            const declarationNodeIdx = this._declarationNodeIndex;\n            let parent = tNode.parent;\n            // Determine if a given TNode is a \"direct\" child of a node on which a content query was\n            // declared (only direct children of query's host node can match with the descendants: false\n            // option). There are 3 main use-case / conditions to consider here:\n            // - <needs-target><i #target></i></needs-target>: here <i #target> parent node is a query\n            // host node;\n            // - <needs-target><ng-template [ngIf]=\"true\"><i #target></i></ng-template></needs-target>:\n            // here <i #target> parent node is null;\n            // - <needs-target><ng-container><i #target></i></ng-container></needs-target>: here we need\n            // to go past `<ng-container>` to determine <i #target> parent node (but we shouldn't traverse\n            // up past the query's host node!).\n            while (parent !== null && (parent.type & 8 /* TNodeType.ElementContainer */) &&\n                parent.index !== declarationNodeIdx) {\n                parent = parent.parent;\n            }\n            return declarationNodeIdx === (parent !== null ? parent.index : -1);\n        }\n        return this._appliesToNextNode;\n    }\n    matchTNode(tView, tNode) {\n        const predicate = this.metadata.predicate;\n        if (Array.isArray(predicate)) {\n            for (let i = 0; i < predicate.length; i++) {\n                const name = predicate[i];\n                this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));\n                // Also try matching the name to a provider since strings can be used as DI tokens too.\n                this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));\n            }\n        }\n        else {\n            if (predicate === TemplateRef) {\n                if (tNode.type & 4 /* TNodeType.Container */) {\n                    this.matchTNodeWithReadOption(tView, tNode, -1);\n                }\n            }\n            else {\n                this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));\n            }\n        }\n    }\n    matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {\n        if (nodeMatchIdx !== null) {\n            const read = this.metadata.read;\n            if (read !== null) {\n                if (read === ElementRef || read === ViewContainerRef ||\n                    read === TemplateRef && (tNode.type & 4 /* TNodeType.Container */)) {\n                    this.addMatch(tNode.index, -2);\n                }\n                else {\n                    const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);\n                    if (directiveOrProviderIdx !== null) {\n                        this.addMatch(tNode.index, directiveOrProviderIdx);\n                    }\n                }\n            }\n            else {\n                this.addMatch(tNode.index, nodeMatchIdx);\n            }\n        }\n    }\n    addMatch(tNodeIdx, matchIdx) {\n        if (this.matches === null) {\n            this.matches = [tNodeIdx, matchIdx];\n        }\n        else {\n            this.matches.push(tNodeIdx, matchIdx);\n        }\n    }\n}\n/**\n * Iterates over local names for a given node and returns directive index\n * (or -1 if a local name points to an element).\n *\n * @param tNode static data of a node to check\n * @param selector selector to match\n * @returns directive index, -1 or null if a selector didn't match any of the local names\n */\nfunction getIdxOfMatchingSelector(tNode, selector) {\n    const localNames = tNode.localNames;\n    if (localNames !== null) {\n        for (let i = 0; i < localNames.length; i += 2) {\n            if (localNames[i] === selector) {\n                return localNames[i + 1];\n            }\n        }\n    }\n    return null;\n}\nfunction createResultByTNodeType(tNode, currentView) {\n    if (tNode.type & (3 /* TNodeType.AnyRNode */ | 8 /* TNodeType.ElementContainer */)) {\n        return createElementRef(tNode, currentView);\n    }\n    else if (tNode.type & 4 /* TNodeType.Container */) {\n        return createTemplateRef(tNode, currentView);\n    }\n    return null;\n}\nfunction createResultForNode(lView, tNode, matchingIdx, read) {\n    if (matchingIdx === -1) {\n        // if read token and / or strategy is not specified, detect it using appropriate tNode type\n        return createResultByTNodeType(tNode, lView);\n    }\n    else if (matchingIdx === -2) {\n        // read a special token from a node injector\n        return createSpecialToken(lView, tNode, read);\n    }\n    else {\n        // read a token\n        return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);\n    }\n}\nfunction createSpecialToken(lView, tNode, read) {\n    if (read === ElementRef) {\n        return createElementRef(tNode, lView);\n    }\n    else if (read === TemplateRef) {\n        return createTemplateRef(tNode, lView);\n    }\n    else if (read === ViewContainerRef) {\n        ngDevMode && assertTNodeType(tNode, 3 /* TNodeType.AnyRNode */ | 12 /* TNodeType.AnyContainer */);\n        return createContainerRef(tNode, lView);\n    }\n    else {\n        ngDevMode &&\n            throwError(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);\n    }\n}\n/**\n * A helper function that creates query results for a given view. This function is meant to do the\n * processing once and only once for a given view instance (a set of results for a given view\n * doesn't change).\n */\nfunction materializeViewResults(tView, lView, tQuery, queryIndex) {\n    const lQuery = lView[QUERIES].queries[queryIndex];\n    if (lQuery.matches === null) {\n        const tViewData = tView.data;\n        const tQueryMatches = tQuery.matches;\n        const result = [];\n        for (let i = 0; i < tQueryMatches.length; i += 2) {\n            const matchedNodeIdx = tQueryMatches[i];\n            if (matchedNodeIdx < 0) {\n                // we at the <ng-template> marker which might have results in views created based on this\n                // <ng-template> - those results will be in separate views though, so here we just leave\n                // null as a placeholder\n                result.push(null);\n            }\n            else {\n                ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);\n                const tNode = tViewData[matchedNodeIdx];\n                result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));\n            }\n        }\n        lQuery.matches = result;\n    }\n    return lQuery.matches;\n}\n/**\n * A helper function that collects (already materialized) query results from a tree of views,\n * starting with a provided LView.\n */\nfunction collectQueryResults(tView, lView, queryIndex, result) {\n    const tQuery = tView.queries.getByIndex(queryIndex);\n    const tQueryMatches = tQuery.matches;\n    if (tQueryMatches !== null) {\n        const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);\n        for (let i = 0; i < tQueryMatches.length; i += 2) {\n            const tNodeIdx = tQueryMatches[i];\n            if (tNodeIdx > 0) {\n                result.push(lViewResults[i / 2]);\n            }\n            else {\n                const childQueryIndex = tQueryMatches[i + 1];\n                const declarationLContainer = lView[-tNodeIdx];\n                ngDevMode && assertLContainer(declarationLContainer);\n                // collect matches for views inserted in this container\n                for (let i = CONTAINER_HEADER_OFFSET; i < declarationLContainer.length; i++) {\n                    const embeddedLView = declarationLContainer[i];\n                    if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {\n                        collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);\n                    }\n                }\n                // collect matches for views created from this declaration container and inserted into\n                // different containers\n                if (declarationLContainer[MOVED_VIEWS] !== null) {\n                    const embeddedLViews = declarationLContainer[MOVED_VIEWS];\n                    for (let i = 0; i < embeddedLViews.length; i++) {\n                        const embeddedLView = embeddedLViews[i];\n                        collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}\n/**\n * Refreshes a query by combining matches from all active views and removing matches from deleted\n * views.\n *\n * @returns `true` if a query got dirty during change detection or if this is a static query\n * resolving in creation mode, `false` otherwise.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275queryRefresh(queryList) {\n    const lView = getLView();\n    const tView = getTView();\n    const queryIndex = getCurrentQueryIndex();\n    setCurrentQueryIndex(queryIndex + 1);\n    const tQuery = getTQuery(tView, queryIndex);\n    if (queryList.dirty &&\n        (isCreationMode(lView) ===\n            ((tQuery.metadata.flags & 2 /* QueryFlags.isStatic */) === 2 /* QueryFlags.isStatic */))) {\n        if (tQuery.matches === null) {\n            queryList.reset([]);\n        }\n        else {\n            const result = tQuery.crossesNgTemplate ?\n                collectQueryResults(tView, lView, queryIndex, []) :\n                materializeViewResults(tView, lView, tQuery, queryIndex);\n            queryList.reset(result, unwrapElementRef);\n            queryList.notifyOnChanges();\n        }\n        return true;\n    }\n    return false;\n}\n/**\n * Creates new QueryList, stores the reference in LView and returns QueryList.\n *\n * @param predicate The type for which the query will search\n * @param flags Flags associated with the query\n * @param read What to save in the query\n *\n * @codeGenApi\n */\nfunction \u0275\u0275viewQuery(predicate, flags, read) {\n    ngDevMode && assertNumber(flags, 'Expecting flags');\n    const tView = getTView();\n    if (tView.firstCreatePass) {\n        createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);\n        if ((flags & 2 /* QueryFlags.isStatic */) === 2 /* QueryFlags.isStatic */) {\n            tView.staticViewQueries = true;\n        }\n    }\n    createLQuery(tView, getLView(), flags);\n}\n/**\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\n * refresh).\n *\n * @param directiveIndex Current directive index\n * @param predicate The type for which the query will search\n * @param flags Flags associated with the query\n * @param read What to save in the query\n * @returns QueryList<T>\n *\n * @codeGenApi\n */\nfunction \u0275\u0275contentQuery(directiveIndex, predicate, flags, read) {\n    ngDevMode && assertNumber(flags, 'Expecting flags');\n    const tView = getTView();\n    if (tView.firstCreatePass) {\n        const tNode = getCurrentTNode();\n        createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);\n        saveContentQueryAndDirectiveIndex(tView, directiveIndex);\n        if ((flags & 2 /* QueryFlags.isStatic */) === 2 /* QueryFlags.isStatic */) {\n            tView.staticContentQueries = true;\n        }\n    }\n    createLQuery(tView, getLView(), flags);\n}\n/**\n * Loads a QueryList corresponding to the current view or content query.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275loadQuery() {\n    return loadQueryInternal(getLView(), getCurrentQueryIndex());\n}\nfunction loadQueryInternal(lView, queryIndex) {\n    ngDevMode &&\n        assertDefined(lView[QUERIES], 'LQueries should be defined when trying to load a query');\n    ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);\n    return lView[QUERIES].queries[queryIndex].queryList;\n}\nfunction createLQuery(tView, lView, flags) {\n    const queryList = new QueryList((flags & 4 /* QueryFlags.emitDistinctChangesOnly */) === 4 /* QueryFlags.emitDistinctChangesOnly */);\n    storeCleanupWithContext(tView, lView, queryList, queryList.destroy);\n    if (lView[QUERIES] === null)\n        lView[QUERIES] = new LQueries_();\n    lView[QUERIES].queries.push(new LQuery_(queryList));\n}\nfunction createTQuery(tView, metadata, nodeIndex) {\n    if (tView.queries === null)\n        tView.queries = new TQueries_();\n    tView.queries.track(new TQuery_(metadata, nodeIndex));\n}\nfunction saveContentQueryAndDirectiveIndex(tView, directiveIndex) {\n    const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);\n    const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;\n    if (directiveIndex !== lastSavedDirectiveIndex) {\n        tViewContentQueries.push(tView.queries.length - 1, directiveIndex);\n    }\n}\nfunction getTQuery(tView, index) {\n    ngDevMode && assertDefined(tView.queries, 'TQueries must be defined to retrieve a TQuery');\n    return tView.queries.getByIndex(index);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Retrieves `TemplateRef` instance from `Injector` when a local reference is placed on the\n * `<ng-template>` element.\n *\n * @codeGenApi\n */\nfunction \u0275\u0275templateRefExtractor(tNode, lView) {\n    return createTemplateRef(tNode, lView);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nconst angularCoreEnv = (() => ({\n    '\u0275\u0275attribute': \u0275\u0275attribute,\n    '\u0275\u0275attributeInterpolate1': \u0275\u0275attributeInterpolate1,\n    '\u0275\u0275attributeInterpolate2': \u0275\u0275attributeInterpolate2,\n    '\u0275\u0275attributeInterpolate3': \u0275\u0275attributeInterpolate3,\n    '\u0275\u0275attributeInterpolate4': \u0275\u0275attributeInterpolate4,\n    '\u0275\u0275attributeInterpolate5': \u0275\u0275attributeInterpolate5,\n    '\u0275\u0275attributeInterpolate6': \u0275\u0275attributeInterpolate6,\n    '\u0275\u0275attributeInterpolate7': \u0275\u0275attributeInterpolate7,\n    '\u0275\u0275attributeInterpolate8': \u0275\u0275attributeInterpolate8,\n    '\u0275\u0275attributeInterpolateV': \u0275\u0275attributeInterpolateV,\n    '\u0275\u0275defineComponent': \u0275\u0275defineComponent,\n    '\u0275\u0275defineDirective': \u0275\u0275defineDirective,\n    '\u0275\u0275defineInjectable': \u0275\u0275defineInjectable,\n    '\u0275\u0275defineInjector': \u0275\u0275defineInjector,\n    '\u0275\u0275defineNgModule': \u0275\u0275defineNgModule,\n    '\u0275\u0275definePipe': \u0275\u0275definePipe,\n    '\u0275\u0275directiveInject': \u0275\u0275directiveInject,\n    '\u0275\u0275getInheritedFactory': \u0275\u0275getInheritedFactory,\n    '\u0275\u0275inject': \u0275\u0275inject,\n    '\u0275\u0275injectAttribute': \u0275\u0275injectAttribute,\n    '\u0275\u0275invalidFactory': \u0275\u0275invalidFactory,\n    '\u0275\u0275invalidFactoryDep': \u0275\u0275invalidFactoryDep,\n    '\u0275\u0275templateRefExtractor': \u0275\u0275templateRefExtractor,\n    '\u0275\u0275resetView': \u0275\u0275resetView,\n    '\u0275\u0275NgOnChangesFeature': \u0275\u0275NgOnChangesFeature,\n    '\u0275\u0275ProvidersFeature': \u0275\u0275ProvidersFeature,\n    '\u0275\u0275CopyDefinitionFeature': \u0275\u0275CopyDefinitionFeature,\n    '\u0275\u0275InheritDefinitionFeature': \u0275\u0275InheritDefinitionFeature,\n    '\u0275\u0275StandaloneFeature': \u0275\u0275StandaloneFeature,\n    '\u0275\u0275nextContext': \u0275\u0275nextContext,\n    '\u0275\u0275namespaceHTML': \u0275\u0275namespaceHTML,\n    '\u0275\u0275namespaceMathML': \u0275\u0275namespaceMathML,\n    '\u0275\u0275namespaceSVG': \u0275\u0275namespaceSVG,\n    '\u0275\u0275enableBindings': \u0275\u0275enableBindings,\n    '\u0275\u0275disableBindings': \u0275\u0275disableBindings,\n    '\u0275\u0275elementStart': \u0275\u0275elementStart,\n    '\u0275\u0275elementEnd': \u0275\u0275elementEnd,\n    '\u0275\u0275element': \u0275\u0275element,\n    '\u0275\u0275elementContainerStart': \u0275\u0275elementContainerStart,\n    '\u0275\u0275elementContainerEnd': \u0275\u0275elementContainerEnd,\n    '\u0275\u0275elementContainer': \u0275\u0275elementContainer,\n    '\u0275\u0275pureFunction0': \u0275\u0275pureFunction0,\n    '\u0275\u0275pureFunction1': \u0275\u0275pureFunction1,\n    '\u0275\u0275pureFunction2': \u0275\u0275pureFunction2,\n    '\u0275\u0275pureFunction3': \u0275\u0275pureFunction3,\n    '\u0275\u0275pureFunction4': \u0275\u0275pureFunction4,\n    '\u0275\u0275pureFunction5': \u0275\u0275pureFunction5,\n    '\u0275\u0275pureFunction6': \u0275\u0275pureFunction6,\n    '\u0275\u0275pureFunction7': \u0275\u0275pureFunction7,\n    '\u0275\u0275pureFunction8': \u0275\u0275pureFunction8,\n    '\u0275\u0275pureFunctionV': \u0275\u0275pureFunctionV,\n    '\u0275\u0275getCurrentView': \u0275\u0275getCurrentView,\n    '\u0275\u0275restoreView': \u0275\u0275restoreView,\n    '\u0275\u0275listener': \u0275\u0275listener,\n    '\u0275\u0275projection': \u0275\u0275projection,\n    '\u0275\u0275syntheticHostProperty': \u0275\u0275syntheticHostProperty,\n    '\u0275\u0275syntheticHostListener': \u0275\u0275syntheticHostListener,\n    '\u0275\u0275pipeBind1': \u0275\u0275pipeBind1,\n    '\u0275\u0275pipeBind2': \u0275\u0275pipeBind2,\n    '\u0275\u0275pipeBind3': \u0275\u0275pipeBind3,\n    '\u0275\u0275pipeBind4': \u0275\u0275pipeBind4,\n    '\u0275\u0275pipeBindV': \u0275\u0275pipeBindV,\n    '\u0275\u0275projectionDef': \u0275\u0275projectionDef,\n    '\u0275\u0275hostProperty': \u0275\u0275hostProperty,\n    '\u0275\u0275property': \u0275\u0275property,\n    '\u0275\u0275propertyInterpolate': \u0275\u0275propertyInterpolate,\n    '\u0275\u0275propertyInterpolate1': \u0275\u0275propertyInterpolate1,\n    '\u0275\u0275propertyInterpolate2': \u0275\u0275propertyInterpolate2,\n    '\u0275\u0275propertyInterpolate3': \u0275\u0275propertyInterpolate3,\n    '\u0275\u0275propertyInterpolate4': \u0275\u0275propertyInterpolate4,\n    '\u0275\u0275propertyInterpolate5': \u0275\u0275propertyInterpolate5,\n    '\u0275\u0275propertyInterpolate6': \u0275\u0275propertyInterpolate6,\n    '\u0275\u0275propertyInterpolate7': \u0275\u0275propertyInterpolate7,\n    '\u0275\u0275propertyInterpolate8': \u0275\u0275propertyInterpolate8,\n    '\u0275\u0275propertyInterpolateV': \u0275\u0275propertyInterpolateV,\n    '\u0275\u0275pipe': \u0275\u0275pipe,\n    '\u0275\u0275queryRefresh': \u0275\u0275queryRefresh,\n    '\u0275\u0275viewQuery': \u0275\u0275viewQuery,\n    '\u0275\u0275loadQuery': \u0275\u0275loadQuery,\n    '\u0275\u0275contentQuery': \u0275\u0275contentQuery,\n    '\u0275\u0275reference': \u0275\u0275reference,\n    '\u0275\u0275classMap': \u0275\u0275classMap,\n    '\u0275\u0275classMapInterpolate1': \u0275\u0275classMapInterpolate1,\n    '\u0275\u0275classMapInterpolate2': \u0275\u0275classMapInterpolate2,\n    '\u0275\u0275classMapInterpolate3': \u0275\u0275classMapInterpolate3,\n    '\u0275\u0275classMapInterpolate4': \u0275\u0275classMapInterpolate4,\n    '\u0275\u0275classMapInterpolate5': \u0275\u0275classMapInterpolate5,\n    '\u0275\u0275classMapInterpolate6': \u0275\u0275classMapInterpolate6,\n    '\u0275\u0275classMapInterpolate7': \u0275\u0275classMapInterpolate7,\n    '\u0275\u0275classMapInterpolate8': \u0275\u0275classMapInterpolate8,\n    '\u0275\u0275classMapInterpolateV': \u0275\u0275classMapInterpolateV,\n    '\u0275\u0275styleMap': \u0275\u0275styleMap,\n    '\u0275\u0275styleMapInterpolate1': \u0275\u0275styleMapInterpolate1,\n    '\u0275\u0275styleMapInterpolate2': \u0275\u0275styleMapInterpolate2,\n    '\u0275\u0275styleMapInterpolate3': \u0275\u0275styleMapInterpolate3,\n    '\u0275\u0275styleMapInterpolate4': \u0275\u0275styleMapInterpolate4,\n    '\u0275\u0275styleMapInterpolate5': \u0275\u0275styleMapInterpolate5,\n    '\u0275\u0275styleMapInterpolate6': \u0275\u0275styleMapInterpolate6,\n    '\u0275\u0275styleMapInterpolate7': \u0275\u0275styleMapInterpolate7,\n    '\u0275\u0275styleMapInterpolate8': \u0275\u0275styleMapInterpolate8,\n    '\u0275\u0275styleMapInterpolateV': \u0275\u0275styleMapInterpolateV,\n    '\u0275\u0275styleProp': \u0275\u0275styleProp,\n    '\u0275\u0275stylePropInterpolate1': \u0275\u0275stylePropInterpolate1,\n    '\u0275\u0275stylePropInterpolate2': \u0275\u0275stylePropInterpolate2,\n    '\u0275\u0275stylePropInterpolate3': \u0275\u0275stylePropInterpolate3,\n    '\u0275\u0275stylePropInterpolate4': \u0275\u0275stylePropInterpolate4,\n    '\u0275\u0275stylePropInterpolate5': \u0275\u0275stylePropInterpolate5,\n    '\u0275\u0275stylePropInterpolate6': \u0275\u0275stylePropInterpolate6,\n    '\u0275\u0275stylePropInterpolate7': \u0275\u0275stylePropInterpolate7,\n    '\u0275\u0275stylePropInterpolate8': \u0275\u0275stylePropInterpolate8,\n    '\u0275\u0275stylePropInterpolateV': \u0275\u0275stylePropInterpolateV,\n    '\u0275\u0275classProp': \u0275\u0275classProp,\n    '\u0275\u0275advance': \u0275\u0275advance,\n    '\u0275\u0275template': \u0275\u0275template,\n    '\u0275\u0275text': \u0275\u0275text,\n    '\u0275\u0275textInterpolate': \u0275\u0275textInterpolate,\n    '\u0275\u0275textInterpolate1': \u0275\u0275textInterpolate1,\n    '\u0275\u0275textInterpolate2': \u0275\u0275textInterpolate2,\n    '\u0275\u0275textInterpolate3': \u0275\u0275textInterpolate3,\n    '\u0275\u0275textInterpolate4': \u0275\u0275textInterpolate4,\n    '\u0275\u0275textInterpolate5': \u0275\u0275textInterpolate5,\n    '\u0275\u0275textInterpolate6': \u0275\u0275textInterpolate6,\n    '\u0275\u0275textInterpolate7': \u0275\u0275textInterpolate7,\n    '\u0275\u0275textInterpolate8': \u0275\u0275textInterpolate8,\n    '\u0275\u0275textInterpolateV': \u0275\u0275textInterpolateV,\n    '\u0275\u0275i18n': \u0275\u0275i18n,\n    '\u0275\u0275i18nAttributes': \u0275\u0275i18nAttributes,\n    '\u0275\u0275i18nExp': \u0275\u0275i18nExp,\n    '\u0275\u0275i18nStart': \u0275\u0275i18nStart,\n    '\u0275\u0275i18nEnd': \u0275\u0275i18nEnd,\n    '\u0275\u0275i18nApply': \u0275\u0275i18nApply,\n    '\u0275\u0275i18nPostprocess': \u0275\u0275i18nPostprocess,\n    '\u0275\u0275resolveWindow': \u0275\u0275resolveWindow,\n    '\u0275\u0275resolveDocument': \u0275\u0275resolveDocument,\n    '\u0275\u0275resolveBody': \u0275\u0275resolveBody,\n    '\u0275\u0275setComponentScope': \u0275\u0275setComponentScope,\n    '\u0275\u0275setNgModuleScope': \u0275\u0275setNgModuleScope,\n    '\u0275\u0275registerNgModuleType': registerNgModuleType,\n    '\u0275\u0275sanitizeHtml': \u0275\u0275sanitizeHtml,\n    '\u0275\u0275sanitizeStyle': \u0275\u0275sanitizeStyle,\n    '\u0275\u0275sanitizeResourceUrl': \u0275\u0275sanitizeResourceUrl,\n    '\u0275\u0275sanitizeScript': \u0275\u0275sanitizeScript,\n    '\u0275\u0275sanitizeUrl': \u0275\u0275sanitizeUrl,\n    '\u0275\u0275sanitizeUrlOrResourceUrl': \u0275\u0275sanitizeUrlOrResourceUrl,\n    '\u0275\u0275trustConstantHtml': \u0275\u0275trustConstantHtml,\n    '\u0275\u0275trustConstantResourceUrl': \u0275\u0275trustConstantResourceUrl,\n    '\u0275\u0275validateIframeAttribute': \u0275\u0275validateIframeAttribute,\n    'forwardRef': forwardRef,\n    'resolveForwardRef': resolveForwardRef,\n}))();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction patchModuleCompilation() {\n    // Does nothing, but exists as a target for patching.\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction isModuleWithProviders$1(value) {\n    return value.ngModule !== undefined;\n}\nfunction isNgModule$1(value) {\n    return !!getNgModuleDef(value);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst moduleQueue = [];\n/**\n * Enqueues moduleDef to be checked later to see if scope can be set on its\n * component declarations.\n */\nfunction enqueueModuleForDelayedScoping(moduleType, ngModule) {\n    moduleQueue.push({ moduleType, ngModule });\n}\nlet flushingModuleQueue = false;\n/**\n * Loops over queued module definitions, if a given module definition has all of its\n * declarations resolved, it dequeues that module definition and sets the scope on\n * its declarations.\n */\nfunction flushModuleScopingQueueAsMuchAsPossible() {\n    if (!flushingModuleQueue) {\n        flushingModuleQueue = true;\n        try {\n            for (let i = moduleQueue.length - 1; i >= 0; i--) {\n                const { moduleType, ngModule } = moduleQueue[i];\n                if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {\n                    // dequeue\n                    moduleQueue.splice(i, 1);\n                    setScopeOnDeclaredComponents(moduleType, ngModule);\n                }\n            }\n        }\n        finally {\n            flushingModuleQueue = false;\n        }\n    }\n}\n/**\n * Returns truthy if a declaration has resolved. If the declaration happens to be\n * an array of declarations, it will recurse to check each declaration in that array\n * (which may also be arrays).\n */\nfunction isResolvedDeclaration(declaration) {\n    if (Array.isArray(declaration)) {\n        return declaration.every(isResolvedDeclaration);\n    }\n    return !!resolveForwardRef(declaration);\n}\n/**\n * Compiles a module in JIT mode.\n *\n * This function automatically gets called when a class has a `@NgModule` decorator.\n */\nfunction compileNgModule(moduleType, ngModule = {}) {\n    patchModuleCompilation();\n    compileNgModuleDefs(moduleType, ngModule);\n    if (ngModule.id !== undefined) {\n        registerNgModuleType(moduleType, ngModule.id);\n    }\n    // Because we don't know if all declarations have resolved yet at the moment the\n    // NgModule decorator is executing, we're enqueueing the setting of module scope\n    // on its declarations to be run at a later time when all declarations for the module,\n    // including forward refs, have resolved.\n    enqueueModuleForDelayedScoping(moduleType, ngModule);\n}\n/**\n * Compiles and adds the `\u0275mod`, `\u0275fac` and `\u0275inj` properties to the module class.\n *\n * It's possible to compile a module via this API which will allow duplicate declarations in its\n * root.\n */\nfunction compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {\n    ngDevMode && assertDefined(moduleType, 'Required value moduleType');\n    ngDevMode && assertDefined(ngModule, 'Required value ngModule');\n    const declarations = flatten$1(ngModule.declarations || EMPTY_ARRAY);\n    let ngModuleDef = null;\n    Object.defineProperty(moduleType, NG_MOD_DEF, {\n        configurable: true,\n        get: () => {\n            if (ngModuleDef === null) {\n                if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {\n                    // We need to assert this immediately, because allowing it to continue will cause it to\n                    // go into an infinite loop before we've reached the point where we throw all the errors.\n                    throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);\n                }\n                const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'NgModule', type: moduleType });\n                ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/\u0275mod.js`, {\n                    type: moduleType,\n                    bootstrap: flatten$1(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),\n                    declarations: declarations.map(resolveForwardRef),\n                    imports: flatten$1(ngModule.imports || EMPTY_ARRAY)\n                        .map(resolveForwardRef)\n                        .map(expandModuleWithProviders),\n                    exports: flatten$1(ngModule.exports || EMPTY_ARRAY)\n                        .map(resolveForwardRef)\n                        .map(expandModuleWithProviders),\n                    schemas: ngModule.schemas ? flatten$1(ngModule.schemas) : null,\n                    id: ngModule.id || null,\n                });\n                // Set `schemas` on ngModuleDef to an empty array in JIT mode to indicate that runtime\n                // should verify that there are no unknown elements in a template. In AOT mode, that check\n                // happens at compile time and `schemas` information is not present on Component and Module\n                // defs after compilation (so the check doesn't happen the second time at runtime).\n                if (!ngModuleDef.schemas) {\n                    ngModuleDef.schemas = [];\n                }\n            }\n            return ngModuleDef;\n        }\n    });\n    let ngFactoryDef = null;\n    Object.defineProperty(moduleType, NG_FACTORY_DEF, {\n        get: () => {\n            if (ngFactoryDef === null) {\n                const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'NgModule', type: moduleType });\n                ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/\u0275fac.js`, {\n                    name: moduleType.name,\n                    type: moduleType,\n                    deps: reflectDependencies(moduleType),\n                    target: compiler.FactoryTarget.NgModule,\n                    typeArgumentCount: 0,\n                });\n            }\n            return ngFactoryDef;\n        },\n        // Make the property configurable in dev mode to allow overriding in tests\n        configurable: !!ngDevMode,\n    });\n    let ngInjectorDef = null;\n    Object.defineProperty(moduleType, NG_INJ_DEF, {\n        get: () => {\n            if (ngInjectorDef === null) {\n                ngDevMode &&\n                    verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);\n                const meta = {\n                    name: moduleType.name,\n                    type: moduleType,\n                    providers: ngModule.providers || EMPTY_ARRAY,\n                    imports: [\n                        (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),\n                        (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef),\n                    ],\n                };\n                const compiler = getCompilerFacade({ usage: 0 /* JitCompilerUsage.Decorator */, kind: 'NgModule', type: moduleType });\n                ngInjectorDef =\n                    compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/\u0275inj.js`, meta);\n            }\n            return ngInjectorDef;\n        },\n        // Make the property configurable in dev mode to allow overriding in tests\n        configurable: !!ngDevMode,\n    });\n}\nfunction generateStandaloneInDeclarationsError(type, location) {\n    const prefix = `Unexpected \"${stringifyForError(type)}\" found in the \"declarations\" array of the`;\n    const suffix = `\"${stringifyForError(type)}\" is marked as standalone and can't be declared ` +\n        'in any NgModule - did you intend to import it instead (by adding it to the \"imports\" array)?';\n    return `${prefix} ${location}, ${suffix}`;\n}\nfunction verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {\n    if (verifiedNgModule.get(moduleType))\n        return;\n    // skip verifications of standalone components, directives, and pipes\n    if (isStandalone(moduleType))\n        return;\n    verifiedNgModule.set(moduleType, true);\n    moduleType = resolveForwardRef(moduleType);\n    let ngModuleDef;\n    if (importingModule) {\n        ngModuleDef = getNgModuleDef(moduleType);\n        if (!ngModuleDef) {\n            throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n        }\n    }\n    else {\n        ngModuleDef = getNgModuleDef(moduleType, true);\n    }\n    const errors = [];\n    const declarations = maybeUnwrapFn$1(ngModuleDef.declarations);\n    const imports = maybeUnwrapFn$1(ngModuleDef.imports);\n    flatten$1(imports).map(unwrapModuleWithProvidersImports).forEach(modOrStandaloneCmpt => {\n        verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);\n        verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);\n    });\n    const exports = maybeUnwrapFn$1(ngModuleDef.exports);\n    declarations.forEach(verifyDeclarationsHaveDefinitions);\n    declarations.forEach(verifyDirectivesHaveSelector);\n    declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));\n    const combinedDeclarations = [\n        ...declarations.map(resolveForwardRef),\n        ...flatten$1(imports.map(computeCombinedExports)).map(resolveForwardRef),\n    ];\n    exports.forEach(verifyExportsAreDeclaredOrReExported);\n    declarations.forEach(decl => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));\n    declarations.forEach(verifyComponentEntryComponentsIsPartOfNgModule);\n    const ngModule = getAnnotation(moduleType, 'NgModule');\n    if (ngModule) {\n        ngModule.imports &&\n            flatten$1(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(mod => {\n                verifySemanticsOfNgModuleImport(mod, moduleType);\n                verifySemanticsOfNgModuleDef(mod, false, moduleType);\n            });\n        ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);\n        ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);\n        ngModule.entryComponents &&\n            deepForEach(ngModule.entryComponents, verifyComponentIsPartOfNgModule);\n    }\n    // Throw Error if any errors were detected.\n    if (errors.length) {\n        throw new Error(errors.join('\\n'));\n    }\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n    function verifyDeclarationsHaveDefinitions(type) {\n        type = resolveForwardRef(type);\n        const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n        if (!def) {\n            errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);\n        }\n    }\n    function verifyDirectivesHaveSelector(type) {\n        type = resolveForwardRef(type);\n        const def = getDirectiveDef(type);\n        if (!getComponentDef$1(type) && def && def.selectors.length == 0) {\n            errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);\n        }\n    }\n    function verifyNotStandalone(type, moduleType) {\n        type = resolveForwardRef(type);\n        const def = getComponentDef$1(type) || getDirectiveDef(type) || getPipeDef$1(type);\n        if (def?.standalone) {\n            const location = `\"${stringifyForError(moduleType)}\" NgModule`;\n            errors.push(generateStandaloneInDeclarationsError(type, location));\n        }\n    }\n    function verifyExportsAreDeclaredOrReExported(type) {\n        type = resolveForwardRef(type);\n        const kind = getComponentDef$1(type) && 'component' || getDirectiveDef(type) && 'directive' ||\n            getPipeDef$1(type) && 'pipe';\n        if (kind) {\n            // only checked if we are declared as Component, Directive, or Pipe\n            // Modules don't need to be declared or imported.\n            if (combinedDeclarations.lastIndexOf(type) === -1) {\n                // We are exporting something which we don't explicitly declare or import.\n                errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);\n            }\n        }\n    }\n    function verifyDeclarationIsUnique(type, suppressErrors) {\n        type = resolveForwardRef(type);\n        const existingModule = ownerNgModule.get(type);\n        if (existingModule && existingModule !== moduleType) {\n            if (!suppressErrors) {\n                const modules = [existingModule, moduleType].map(stringifyForError).sort();\n                errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules[0]} and ${modules[1]}! ` +\n                    `Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules[0]} and ${modules[1]}. ` +\n                    `You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules[0]} and ${modules[1]}.`);\n            }\n        }\n        else {\n            // Mark type as having owner.\n            ownerNgModule.set(type, moduleType);\n        }\n    }\n    function verifyComponentIsPartOfNgModule(type) {\n        type = resolveForwardRef(type);\n        const existingModule = ownerNgModule.get(type);\n        if (!existingModule && !isStandalone(type)) {\n            errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);\n        }\n    }\n    function verifyCorrectBootstrapType(type) {\n        type = resolveForwardRef(type);\n        if (!getComponentDef$1(type)) {\n            errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);\n        }\n        if (isStandalone(type)) {\n            // Note: this error should be the same as the\n            // `NGMODULE_BOOTSTRAP_IS_STANDALONE` one in AOT compiler.\n            errors.push(`The \\`${stringifyForError(type)}\\` class is a standalone component, which can ` +\n                `not be used in the \\`@NgModule.bootstrap\\` array. Use the \\`bootstrapApplication\\` ` +\n                `function for bootstrap instead.`);\n        }\n    }\n    function verifyComponentEntryComponentsIsPartOfNgModule(type) {\n        type = resolveForwardRef(type);\n        if (getComponentDef$1(type)) {\n            // We know we are component\n            const component = getAnnotation(type, 'Component');\n            if (component && component.entryComponents) {\n                deepForEach(component.entryComponents, verifyComponentIsPartOfNgModule);\n            }\n        }\n    }\n    function verifySemanticsOfNgModuleImport(type, importingModule) {\n        type = resolveForwardRef(type);\n        const directiveDef = getComponentDef$1(type) || getDirectiveDef(type);\n        if (directiveDef !== null && !directiveDef.standalone) {\n            throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n        }\n        const pipeDef = getPipeDef$1(type);\n        if (pipeDef !== null && !pipeDef.standalone) {\n            throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n        }\n    }\n}\nfunction unwrapModuleWithProvidersImports(typeOrWithProviders) {\n    typeOrWithProviders = resolveForwardRef(typeOrWithProviders);\n    return typeOrWithProviders.ngModule || typeOrWithProviders;\n}\nfunction getAnnotation(type, name) {\n    let annotation = null;\n    collect(type.__annotations__);\n    collect(type.decorators);\n    return annotation;\n    function collect(annotations) {\n        if (annotations) {\n            annotations.forEach(readAnnotation);\n        }\n    }\n    function readAnnotation(decorator) {\n        if (!annotation) {\n            const proto = Object.getPrototypeOf(decorator);\n            if (proto.ngMetadataName == name) {\n                annotation = decorator;\n            }\n            else if (decorator.type) {\n                const proto = Object.getPrototypeOf(decorator.type);\n                if (proto.ngMetadataName == name) {\n                    annotation = decorator.args[0];\n                }\n            }\n        }\n    }\n}\n/**\n * Keep track of compiled components. This is needed because in tests we often want to compile the\n * same component with more than one NgModule. This would cause an error unless we reset which\n * NgModule the component belongs to. We keep the list of compiled components here so that the\n * TestBed can reset it later.\n */\nlet ownerNgModule = new WeakMap();\nlet verifiedNgModule = new WeakMap();\nfunction resetCompiledComponents() {\n    ownerNgModule = new WeakMap();\n    verifiedNgModule = new WeakMap();\n    moduleQueue.length = 0;\n}\n/**\n * Computes the combined declarations of explicit declarations, as well as declarations inherited by\n * traversing the exports of imported modules.\n * @param type\n */\nfunction computeCombinedExports(type) {\n    type = resolveForwardRef(type);\n    const ngModuleDef = getNgModuleDef(type);\n    // a standalone component, directive or pipe\n    if (ngModuleDef === null) {\n        return [type];\n    }\n    return [...flatten$1(maybeUnwrapFn$1(ngModuleDef.exports).map((type) => {\n            const ngModuleDef = getNgModuleDef(type);\n            if (ngModuleDef) {\n                verifySemanticsOfNgModuleDef(type, false);\n                return computeCombinedExports(type);\n            }\n            else {\n                return type;\n            }\n        }))];\n}\n/**\n * Some declared components may be compiled asynchronously, and thus may not have their\n * \u0275cmp set yet. If this is the case, then a reference to the module is written into\n * the `ngSelectorScope` property of the declared type.\n */\nfunction setScopeOnDeclaredComponents(moduleType, ngModule) {\n    const declarations = flatten$1(ngModule.declarations || EMPTY_ARRAY);\n    const transitiveScopes = transitiveScopesFor(moduleType);\n    declarations.forEach(declaration => {\n        declaration = resolveForwardRef(declaration);\n        if (declaration.hasOwnProperty(NG_COMP_DEF)) {\n            // A `\u0275cmp` field exists - go ahead and patch the component directly.\n            const component = declaration;\n            const componentDef = getComponentDef$1(component);\n            patchComponentDefWithScope(componentDef, transitiveScopes);\n        }\n        else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {\n            // Set `ngSelectorScope` for future reference when the component compilation finishes.\n            declaration.ngSelectorScope = moduleType;\n        }\n    });\n}\n/**\n * Patch the definition of a component with directives and pipes from the compilation scope of\n * a given module.\n */\nfunction patchComponentDefWithScope(componentDef, transitiveScopes) {\n    componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives)\n        .map(dir => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef$1(dir) : getDirectiveDef(dir))\n        .filter(def => !!def);\n    componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map(pipe => getPipeDef$1(pipe));\n    componentDef.schemas = transitiveScopes.schemas;\n    // Since we avoid Components/Directives/Pipes recompiling in case there are no overrides, we\n    // may face a problem where previously compiled defs available to a given Component/Directive\n    // are cached in TView and may become stale (in case any of these defs gets recompiled). In\n    // order to avoid this problem, we force fresh TView to be created.\n    componentDef.tView = null;\n}\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given type\n * (either a NgModule or a standalone component / directive / pipe).\n */\nfunction transitiveScopesFor(type) {\n    if (isNgModule$1(type)) {\n        return transitiveScopesForNgModule(type);\n    }\n    else if (isStandalone(type)) {\n        const directiveDef = getComponentDef$1(type) || getDirectiveDef(type);\n        if (directiveDef !== null) {\n            return {\n                schemas: null,\n                compilation: {\n                    directives: new Set(),\n                    pipes: new Set(),\n                },\n                exported: {\n                    directives: new Set([type]),\n                    pipes: new Set(),\n                },\n            };\n        }\n        const pipeDef = getPipeDef$1(type);\n        if (pipeDef !== null) {\n            return {\n                schemas: null,\n                compilation: {\n                    directives: new Set(),\n                    pipes: new Set(),\n                },\n                exported: {\n                    directives: new Set(),\n                    pipes: new Set([type]),\n                },\n            };\n        }\n    }\n    // TODO: change the error message to be more user-facing and take standalone into account\n    throw new Error(`${type.name} does not have a module def (\u0275mod property)`);\n}\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\n *\n * This operation is memoized and the result is cached on the module's definition. This function can\n * be called on modules with components that have not fully compiled yet, but the result should not\n * be used until they have.\n *\n * @param moduleType module that transitive scope should be calculated for.\n */\nfunction transitiveScopesForNgModule(moduleType) {\n    const def = getNgModuleDef(moduleType, true);\n    if (def.transitiveCompileScopes !== null) {\n        return def.transitiveCompileScopes;\n    }\n    const scopes = {\n        schemas: def.schemas || null,\n        compilation: {\n            directives: new Set(),\n            pipes: new Set(),\n        },\n        exported: {\n            directives: new Set(),\n            pipes: new Set(),\n        },\n    };\n    maybeUnwrapFn$1(def.imports).forEach((imported) => {\n        // When this module imports another, the imported module's exported directives and pipes are\n        // added to the compilation scope of this module.\n        const importedScope = transitiveScopesFor(imported);\n        importedScope.exported.directives.forEach(entry => scopes.compilation.directives.add(entry));\n        importedScope.exported.pipes.forEach(entry => scopes.compilation.pipes.add(entry));\n    });\n    maybeUnwrapFn$1(def.declarations).forEach(declared => {\n        const declaredWithDefs = declared;\n        if (getPipeDef$1(declaredWithDefs)) {\n            scopes.compilation.pipes.add(declared);\n        }\n        else {\n            // Either declared has a \u0275cmp or \u0275dir, or it's a component which hasn't\n            // had its template compiled yet. In either case, it gets added to the compilation's\n            // directives.\n            scopes.compilation.directives.add(declared);\n        }\n    });\n    maybeUnwrapFn$1(def.exports).forEach((exported) => {\n        const exportedType = exported;\n        // Either the type is a module, a pipe, or a component/directive (which may not have a\n        // \u0275cmp as it might be compiled asynchronously).\n        if (isNgModule$1(exportedType)) {\n            // When this module exports another, the exported module's exported directives and pipes are\n            // added to both the compilation and exported scopes of this module.\n            const exportedScope = transitiveScopesFor(exportedType);\n            exportedScope.exported.directives.forEach(entry => {\n                scopes.compilation.directives.add(entry);\n                scopes.exported.directives.add(entry);\n            });\n            exportedScope.exported.pipes.forEach(entry => {\n                scopes.compilation.pipes.add(entry);\n                scopes.exported.pipes.add(entry);\n            });\n        }\n        else if (getPipeDef$1(exportedType)) {\n            scopes.exported.pipes.add(exportedType);\n        }\n        else {\n            scopes.exported.directives.add(exportedType);\n        }\n    });\n    def.transitiveCompileScopes = scopes;\n    return scopes;\n}\nfunction expandModuleWithProviders(value) {\n    if (isModuleWithProviders$1(value)) {\n        return value.ngModule;\n    }\n    return value;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n    constructor() {\n        this._references = new Map();\n    }\n    /**\n     * Creates a new instance for the given metadata class\n     * based on an old instance and overrides.\n     */\n    overrideMetadata(metadataClass, oldMetadata, override) {\n        const props = {};\n        if (oldMetadata) {\n            _valueProps(oldMetadata).forEach((prop) => props[prop] = oldMetadata[prop]);\n        }\n        if (override.set) {\n            if (override.remove || override.add) {\n                throw new Error(`Cannot set and add/remove ${\u0275stringify(metadataClass)} at the same time!`);\n            }\n            setMetadata(props, override.set);\n        }\n        if (override.remove) {\n            removeMetadata(props, override.remove, this._references);\n        }\n        if (override.add) {\n            addMetadata(props, override.add);\n        }\n        return new metadataClass(props);\n    }\n}\nfunction removeMetadata(metadata, remove, references) {\n    const removeObjects = new Set();\n    for (const prop in remove) {\n        const removeValue = remove[prop];\n        if (Array.isArray(removeValue)) {\n            removeValue.forEach((value) => {\n                removeObjects.add(_propHashKey(prop, value, references));\n            });\n        }\n        else {\n            removeObjects.add(_propHashKey(prop, removeValue, references));\n        }\n    }\n    for (const prop in metadata) {\n        const propValue = metadata[prop];\n        if (Array.isArray(propValue)) {\n            metadata[prop] = propValue.filter((value) => !removeObjects.has(_propHashKey(prop, value, references)));\n        }\n        else {\n            if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n                metadata[prop] = undefined;\n            }\n        }\n    }\n}\nfunction addMetadata(metadata, add) {\n    for (const prop in add) {\n        const addValue = add[prop];\n        const propValue = metadata[prop];\n        if (propValue != null && Array.isArray(propValue)) {\n            metadata[prop] = propValue.concat(addValue);\n        }\n        else {\n            metadata[prop] = addValue;\n        }\n    }\n}\nfunction setMetadata(metadata, set) {\n    for (const prop in set) {\n        metadata[prop] = set[prop];\n    }\n}\nfunction _propHashKey(propName, propValue, references) {\n    let nextObjectId = 0;\n    const objectIds = new Map();\n    const replacer = (key, value) => {\n        if (value !== null && typeof value === 'object') {\n            if (objectIds.has(value)) {\n                return objectIds.get(value);\n            }\n            // Record an id for this object such that any later references use the object's id instead\n            // of the object itself, in order to break cyclic pointers in objects.\n            objectIds.set(value, `\u0275obj#${nextObjectId++}`);\n            // The first time an object is seen the object itself is serialized.\n            return value;\n        }\n        else if (typeof value === 'function') {\n            value = _serializeReference(value, references);\n        }\n        return value;\n    };\n    return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\nfunction _serializeReference(ref, references) {\n    let id = references.get(ref);\n    if (!id) {\n        id = `${\u0275stringify(ref)}${_nextReferenceId++}`;\n        references.set(ref, id);\n    }\n    return id;\n}\nfunction _valueProps(obj) {\n    const props = [];\n    // regular public props\n    Object.keys(obj).forEach((prop) => {\n        if (!prop.startsWith('_')) {\n            props.push(prop);\n        }\n    });\n    // getters\n    let proto = obj;\n    while (proto = Object.getPrototypeOf(proto)) {\n        Object.keys(proto).forEach((protoProp) => {\n            const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n            if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n                props.push(protoProp);\n            }\n        });\n    }\n    return props;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst reflection = new \u0275ReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nclass OverrideResolver {\n    constructor() {\n        this.overrides = new Map();\n        this.resolved = new Map();\n    }\n    addOverride(type, override) {\n        const overrides = this.overrides.get(type) || [];\n        overrides.push(override);\n        this.overrides.set(type, overrides);\n        this.resolved.delete(type);\n    }\n    setOverrides(overrides) {\n        this.overrides.clear();\n        overrides.forEach(([type, override]) => {\n            this.addOverride(type, override);\n        });\n    }\n    getAnnotation(type) {\n        const annotations = reflection.annotations(type);\n        // Try to find the nearest known Type annotation and make sure that this annotation is an\n        // instance of the type we are looking for, so we can use it for resolution. Note: there might\n        // be multiple known annotations found due to the fact that Components can extend Directives (so\n        // both Directive and Component annotations would be present), so we always check if the known\n        // annotation has the right type.\n        for (let i = annotations.length - 1; i >= 0; i--) {\n            const annotation = annotations[i];\n            const isKnownType = annotation instanceof Directive || annotation instanceof Component ||\n                annotation instanceof Pipe || annotation instanceof NgModule;\n            if (isKnownType) {\n                return annotation instanceof this.type ? annotation : null;\n            }\n        }\n        return null;\n    }\n    resolve(type) {\n        let resolved = this.resolved.get(type) || null;\n        if (!resolved) {\n            resolved = this.getAnnotation(type);\n            if (resolved) {\n                const overrides = this.overrides.get(type);\n                if (overrides) {\n                    const overrider = new MetadataOverrider();\n                    overrides.forEach(override => {\n                        resolved = overrider.overrideMetadata(this.type, resolved, override);\n                    });\n                }\n            }\n            this.resolved.set(type, resolved);\n        }\n        return resolved;\n    }\n}\nclass DirectiveResolver extends OverrideResolver {\n    get type() {\n        return Directive;\n    }\n}\nclass ComponentResolver extends OverrideResolver {\n    get type() {\n        return Component;\n    }\n}\nclass PipeResolver extends OverrideResolver {\n    get type() {\n        return Pipe;\n    }\n}\nclass NgModuleResolver extends OverrideResolver {\n    get type() {\n        return NgModule;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TestingModuleOverride;\n(function (TestingModuleOverride) {\n    TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n    TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\nfunction isTestingModuleOverride(value) {\n    return value === TestingModuleOverride.DECLARATION ||\n        value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\nfunction assertNoStandaloneComponents(types, resolver, location) {\n    types.forEach(type => {\n        const component = resolver.resolve(type);\n        if (component && component.standalone) {\n            throw new Error(generateStandaloneInDeclarationsError(type, location));\n        }\n    });\n}\nclass TestBedCompiler {\n    constructor(platform, additionalModuleTypes) {\n        this.platform = platform;\n        this.additionalModuleTypes = additionalModuleTypes;\n        this.originalComponentResolutionQueue = null;\n        // Testing module configuration\n        this.declarations = [];\n        this.imports = [];\n        this.providers = [];\n        this.schemas = [];\n        // Queues of components/directives/pipes that should be recompiled.\n        this.pendingComponents = new Set();\n        this.pendingDirectives = new Set();\n        this.pendingPipes = new Set();\n        // Keep track of all components and directives, so we can patch Providers onto defs later.\n        this.seenComponents = new Set();\n        this.seenDirectives = new Set();\n        // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n        this.overriddenModules = new Set();\n        // Store resolved styles for Components that have template overrides present and `styleUrls`\n        // defined at the same time.\n        this.existingComponentStyles = new Map();\n        this.resolvers = initResolvers();\n        this.componentToModuleScope = new Map();\n        // Map that keeps initial version of component/directive/pipe defs in case\n        // we compile a Type again, thus overriding respective static fields. This is\n        // required to make sure we restore defs to their initial states between test runs.\n        // Note: one class may have multiple defs (for example: \u0275mod and \u0275inj in case of an\n        // NgModule), store all of them in a map.\n        this.initialNgDefs = new Map();\n        // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n        // defs in case TestBed makes changes to the originals.\n        this.defCleanupOps = [];\n        this._injector = null;\n        this.compilerProviders = null;\n        this.providerOverrides = [];\n        this.rootProviderOverrides = [];\n        // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n        // module's provider list.\n        this.providerOverridesByModule = new Map();\n        this.providerOverridesByToken = new Map();\n        this.scopesWithOverriddenProviders = new Set();\n        this.testModuleRef = null;\n        class DynamicTestModule {\n        }\n        this.testModuleType = DynamicTestModule;\n    }\n    setCompilerProviders(providers) {\n        this.compilerProviders = providers;\n        this._injector = null;\n    }\n    configureTestingModule(moduleDef) {\n        // Enqueue any compilation tasks for the directly declared component.\n        if (moduleDef.declarations !== undefined) {\n            // Verify that there are no standalone components\n            assertNoStandaloneComponents(moduleDef.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n            this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n            this.declarations.push(...moduleDef.declarations);\n        }\n        // Enqueue any compilation tasks for imported modules.\n        if (moduleDef.imports !== undefined) {\n            this.queueTypesFromModulesArray(moduleDef.imports);\n            this.imports.push(...moduleDef.imports);\n        }\n        if (moduleDef.providers !== undefined) {\n            this.providers.push(...moduleDef.providers);\n        }\n        if (moduleDef.schemas !== undefined) {\n            this.schemas.push(...moduleDef.schemas);\n        }\n    }\n    overrideModule(ngModule, override) {\n        this.overriddenModules.add(ngModule);\n        // Compile the module right away.\n        this.resolvers.module.addOverride(ngModule, override);\n        const metadata = this.resolvers.module.resolve(ngModule);\n        if (metadata === null) {\n            throw invalidTypeError(ngModule.name, 'NgModule');\n        }\n        this.recompileNgModule(ngModule, metadata);\n        // At this point, the module has a valid module def (\u0275mod), but the override may have introduced\n        // new declarations or imported modules. Ingest any possible new types and add them to the\n        // current queue.\n        this.queueTypesFromModulesArray([ngModule]);\n    }\n    overrideComponent(component, override) {\n        this.verifyNoStandaloneFlagOverrides(component, override);\n        this.resolvers.component.addOverride(component, override);\n        this.pendingComponents.add(component);\n    }\n    overrideDirective(directive, override) {\n        this.verifyNoStandaloneFlagOverrides(directive, override);\n        this.resolvers.directive.addOverride(directive, override);\n        this.pendingDirectives.add(directive);\n    }\n    overridePipe(pipe, override) {\n        this.verifyNoStandaloneFlagOverrides(pipe, override);\n        this.resolvers.pipe.addOverride(pipe, override);\n        this.pendingPipes.add(pipe);\n    }\n    verifyNoStandaloneFlagOverrides(type, override) {\n        if (override.add?.hasOwnProperty('standalone') || override.set?.hasOwnProperty('standalone') ||\n            override.remove?.hasOwnProperty('standalone')) {\n            throw new Error(`An override for the ${type.name} class has the \\`standalone\\` flag. ` +\n                `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`);\n        }\n    }\n    overrideProvider(token, provider) {\n        let providerDef;\n        if (provider.useFactory !== undefined) {\n            providerDef = {\n                provide: token,\n                useFactory: provider.useFactory,\n                deps: provider.deps || [],\n                multi: provider.multi\n            };\n        }\n        else if (provider.useValue !== undefined) {\n            providerDef = { provide: token, useValue: provider.useValue, multi: provider.multi };\n        }\n        else {\n            providerDef = { provide: token };\n        }\n        const injectableDef = typeof token !== 'string' ? \u0275getInjectableDef(token) : null;\n        const providedIn = injectableDef === null ? null : resolveForwardRef$1(injectableDef.providedIn);\n        const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n        overridesBucket.push(providerDef);\n        // Keep overrides grouped by token as well for fast lookups using token\n        this.providerOverridesByToken.set(token, providerDef);\n        if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n            const existingOverrides = this.providerOverridesByModule.get(providedIn);\n            if (existingOverrides !== undefined) {\n                existingOverrides.push(providerDef);\n            }\n            else {\n                this.providerOverridesByModule.set(providedIn, [providerDef]);\n            }\n        }\n    }\n    overrideTemplateUsingTestingModule(type, template) {\n        const def = type[\u0275NG_COMP_DEF];\n        const hasStyleUrls = () => {\n            const metadata = this.resolvers.component.resolve(type);\n            return !!metadata.styleUrls && metadata.styleUrls.length > 0;\n        };\n        const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();\n        // In Ivy, compiling a component does not require knowing the module providing the\n        // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n        // overrideComponent. Important: overriding template requires full Component re-compilation,\n        // which may fail in case styleUrls are also present (thus Component is considered as required\n        // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n        // preserve current styles available on Component def and restore styles back once compilation\n        // is complete.\n        const override = overrideStyleUrls ? { template, styles: [], styleUrls: [] } : { template };\n        this.overrideComponent(type, { set: override });\n        if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n            this.existingComponentStyles.set(type, def.styles);\n        }\n        // Set the component's scope to be the testing module.\n        this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n    }\n    async compileComponents() {\n        this.clearComponentResolutionQueue();\n        // Run compilers for all queued types.\n        let needsAsyncResources = this.compileTypesSync();\n        // compileComponents() should not be async unless it needs to be.\n        if (needsAsyncResources) {\n            let resourceLoader;\n            let resolver = (url) => {\n                if (!resourceLoader) {\n                    resourceLoader = this.injector.get(ResourceLoader);\n                }\n                return Promise.resolve(resourceLoader.get(url));\n            };\n            await resolveComponentResources(resolver);\n        }\n    }\n    finalize() {\n        // One last compile\n        this.compileTypesSync();\n        // Create the testing module itself.\n        this.compileTestModule();\n        this.applyTransitiveScopes();\n        this.applyProviderOverrides();\n        // Patch previously stored `styles` Component values (taken from \u0275cmp), in case these\n        // Components have `styleUrls` fields defined and template override was requested.\n        this.patchComponentsWithExistingStyles();\n        // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n        // every component.\n        this.componentToModuleScope.clear();\n        const parentInjector = this.platform.injector;\n        this.testModuleRef = new \u0275Render3NgModuleRef(this.testModuleType, parentInjector);\n        // ApplicationInitStatus.runInitializers() is marked @internal to core.\n        // Cast it to any before accessing it.\n        this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\n        // Set locale ID after running app initializers, since locale information might be updated while\n        // running initializers. This is also consistent with the execution order while bootstrapping an\n        // app (see `packages/core/src/application_ref.ts` file).\n        const localeId = this.testModuleRef.injector.get(LOCALE_ID$1, \u0275DEFAULT_LOCALE_ID);\n        \u0275setLocaleId(localeId);\n        return this.testModuleRef;\n    }\n    /**\n     * @internal\n     */\n    _compileNgModuleSync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        this.compileTypesSync();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesInScope(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n    async _compileNgModuleAsync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        await this.compileComponents();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesInScope(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n    _getModuleResolver() {\n        return this.resolvers.module;\n    }\n    /**\n     * @internal\n     */\n    _getComponentFactories(moduleType) {\n        return maybeUnwrapFn(moduleType.\u0275mod.declarations).reduce((factories, declaration) => {\n            const componentDef = declaration.\u0275cmp;\n            componentDef && factories.push(new \u0275Render3ComponentFactory(componentDef, this.testModuleRef));\n            return factories;\n        }, []);\n    }\n    compileTypesSync() {\n        // Compile all queued components, directives, pipes.\n        let needsAsyncResources = false;\n        this.pendingComponents.forEach(declaration => {\n            needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n            const metadata = this.resolvers.component.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Component');\n            }\n            this.maybeStoreNgDef(\u0275NG_COMP_DEF, declaration);\n            \u0275compileComponent(declaration, metadata);\n        });\n        this.pendingComponents.clear();\n        this.pendingDirectives.forEach(declaration => {\n            const metadata = this.resolvers.directive.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Directive');\n            }\n            this.maybeStoreNgDef(\u0275NG_DIR_DEF, declaration);\n            \u0275compileDirective(declaration, metadata);\n        });\n        this.pendingDirectives.clear();\n        this.pendingPipes.forEach(declaration => {\n            const metadata = this.resolvers.pipe.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Pipe');\n            }\n            this.maybeStoreNgDef(\u0275NG_PIPE_DEF, declaration);\n            \u0275compilePipe(declaration, metadata);\n        });\n        this.pendingPipes.clear();\n        return needsAsyncResources;\n    }\n    applyTransitiveScopes() {\n        if (this.overriddenModules.size > 0) {\n            // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n            // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n            // collect all affected modules and reset scopes to force their re-calculation.\n            const testingModuleDef = this.testModuleType[\u0275NG_MOD_DEF];\n            const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n            if (affectedModules.size > 0) {\n                affectedModules.forEach(moduleType => {\n                    this.storeFieldOfDefOnType(moduleType, \u0275NG_MOD_DEF, 'transitiveCompileScopes');\n                    moduleType[\u0275NG_MOD_DEF].transitiveCompileScopes = null;\n                });\n            }\n        }\n        const moduleToScope = new Map();\n        const getScopeOfModule = (moduleType) => {\n            if (!moduleToScope.has(moduleType)) {\n                const isTestingModule = isTestingModuleOverride(moduleType);\n                const realType = isTestingModule ? this.testModuleType : moduleType;\n                moduleToScope.set(moduleType, \u0275transitiveScopesFor(realType));\n            }\n            return moduleToScope.get(moduleType);\n        };\n        this.componentToModuleScope.forEach((moduleType, componentType) => {\n            const moduleScope = getScopeOfModule(moduleType);\n            this.storeFieldOfDefOnType(componentType, \u0275NG_COMP_DEF, 'directiveDefs');\n            this.storeFieldOfDefOnType(componentType, \u0275NG_COMP_DEF, 'pipeDefs');\n            // `tView` that is stored on component def contains information about directives and pipes\n            // that are in the scope of this component. Patching component scope will cause `tView` to be\n            // changed. Store original `tView` before patching scope, so the `tView` (including scope\n            // information) is restored back to its previous/original state before running next test.\n            this.storeFieldOfDefOnType(componentType, \u0275NG_COMP_DEF, 'tView');\n            \u0275patchComponentDefWithScope(componentType.\u0275cmp, moduleScope);\n        });\n        this.componentToModuleScope.clear();\n    }\n    applyProviderOverrides() {\n        const maybeApplyOverrides = (field) => (type) => {\n            const resolver = field === \u0275NG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n            const metadata = resolver.resolve(type);\n            if (this.hasProviderOverrides(metadata.providers)) {\n                this.patchDefWithProviderOverrides(type, field);\n            }\n        };\n        this.seenComponents.forEach(maybeApplyOverrides(\u0275NG_COMP_DEF));\n        this.seenDirectives.forEach(maybeApplyOverrides(\u0275NG_DIR_DEF));\n        this.seenComponents.clear();\n        this.seenDirectives.clear();\n    }\n    /**\n     * Applies provider overrides to a given type (either an NgModule or a standalone component)\n     * and all imported NgModules and standalone components recursively.\n     */\n    applyProviderOverridesInScope(type) {\n        const hasScope = isStandaloneComponent(type) || isNgModule(type);\n        // The function can be re-entered recursively while inspecting dependencies\n        // of an NgModule or a standalone component. Exit early if we come across a\n        // type that can not have a scope (directive or pipe) or the type is already\n        // processed earlier.\n        if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n            return;\n        }\n        this.scopesWithOverriddenProviders.add(type);\n        // NOTE: the line below triggers JIT compilation of the module injector,\n        // which also invokes verification of the NgModule semantics, which produces\n        // detailed error messages. The fact that the code relies on this line being\n        // present here is suspicious and should be refactored in a way that the line\n        // below can be moved (for ex. after an early exit check below).\n        const injectorDef = type[\u0275NG_INJ_DEF];\n        // No provider overrides, exit early.\n        if (this.providerOverridesByToken.size === 0)\n            return;\n        if (isStandaloneComponent(type)) {\n            // Visit all component dependencies and override providers there.\n            const def = getComponentDef(type);\n            const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n            for (const dependency of dependencies) {\n                this.applyProviderOverridesInScope(dependency);\n            }\n        }\n        else {\n            const providers = [\n                ...injectorDef.providers,\n                ...(this.providerOverridesByModule.get(type) || [])\n            ];\n            if (this.hasProviderOverrides(providers)) {\n                this.maybeStoreNgDef(\u0275NG_INJ_DEF, type);\n                this.storeFieldOfDefOnType(type, \u0275NG_INJ_DEF, 'providers');\n                injectorDef.providers = this.getOverriddenProviders(providers);\n            }\n            // Apply provider overrides to imported modules recursively\n            const moduleDef = type[\u0275NG_MOD_DEF];\n            const imports = maybeUnwrapFn(moduleDef.imports);\n            for (const importedModule of imports) {\n                this.applyProviderOverridesInScope(importedModule);\n            }\n            // Also override the providers on any ModuleWithProviders imports since those don't appear in\n            // the moduleDef.\n            for (const importedModule of flatten(injectorDef.imports)) {\n                if (isModuleWithProviders(importedModule)) {\n                    this.defCleanupOps.push({\n                        object: importedModule,\n                        fieldName: 'providers',\n                        originalValue: importedModule.providers\n                    });\n                    importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n                }\n            }\n        }\n    }\n    patchComponentsWithExistingStyles() {\n        this.existingComponentStyles.forEach((styles, type) => type[\u0275NG_COMP_DEF].styles = styles);\n        this.existingComponentStyles.clear();\n    }\n    queueTypeArray(arr, moduleType) {\n        for (const value of arr) {\n            if (Array.isArray(value)) {\n                this.queueTypeArray(value, moduleType);\n            }\n            else {\n                this.queueType(value, moduleType);\n            }\n        }\n    }\n    recompileNgModule(ngModule, metadata) {\n        // Cache the initial ngModuleDef as it will be overwritten.\n        this.maybeStoreNgDef(\u0275NG_MOD_DEF, ngModule);\n        this.maybeStoreNgDef(\u0275NG_INJ_DEF, ngModule);\n        \u0275compileNgModuleDefs(ngModule, metadata);\n    }\n    queueType(type, moduleType) {\n        const component = this.resolvers.component.resolve(type);\n        if (component) {\n            // Check whether a give Type has respective NG def (\u0275cmp) and compile if def is\n            // missing. That might happen in case a class without any Angular decorators extends another\n            // class where Component/Directive/Pipe decorator is defined.\n            if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(\u0275NG_COMP_DEF)) {\n                this.pendingComponents.add(type);\n            }\n            this.seenComponents.add(type);\n            // Keep track of the module which declares this component, so later the component's scope\n            // can be set correctly. If the component has already been recorded here, then one of several\n            // cases is true:\n            // * the module containing the component was imported multiple times (common).\n            // * the component is declared in multiple modules (which is an error).\n            // * the component was in 'declarations' of the testing module, and also in an imported module\n            //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n            // * overrideTemplateUsingTestingModule was called for the component in which case the module\n            //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n            //\n            // If the component was previously in the testing module's 'declarations' (meaning the\n            // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n            // real module, which was imported. This pattern is understood to mean that the component\n            // should use its original scope, but that the testing module should also contain the\n            // component in its scope.\n            //\n            // Note: standalone components have no associated NgModule, so the `moduleType` can be `null`.\n            if (moduleType !== null &&\n                (!this.componentToModuleScope.has(type) ||\n                    this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION)) {\n                this.componentToModuleScope.set(type, moduleType);\n            }\n            return;\n        }\n        const directive = this.resolvers.directive.resolve(type);\n        if (directive) {\n            if (!type.hasOwnProperty(\u0275NG_DIR_DEF)) {\n                this.pendingDirectives.add(type);\n            }\n            this.seenDirectives.add(type);\n            return;\n        }\n        const pipe = this.resolvers.pipe.resolve(type);\n        if (pipe && !type.hasOwnProperty(\u0275NG_PIPE_DEF)) {\n            this.pendingPipes.add(type);\n            return;\n        }\n    }\n    queueTypesFromModulesArray(arr) {\n        // Because we may encounter the same NgModule while processing the imports and exports of an\n        // NgModule tree, we cache them in this set so we can skip ones that have already been seen\n        // encountered. In some test setups, this caching resulted in 10X runtime improvement.\n        const processedNgModuleDefs = new Set();\n        const queueTypesFromModulesArrayRecur = (arr) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    queueTypesFromModulesArrayRecur(value);\n                }\n                else if (hasNgModuleDef(value)) {\n                    const def = value.\u0275mod;\n                    if (processedNgModuleDefs.has(def)) {\n                        continue;\n                    }\n                    processedNgModuleDefs.add(def);\n                    // Look through declarations, imports, and exports, and queue\n                    // everything found there.\n                    this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n                }\n                else if (isModuleWithProviders(value)) {\n                    queueTypesFromModulesArrayRecur([value.ngModule]);\n                }\n                else if (isStandaloneComponent(value)) {\n                    this.queueType(value, null);\n                    const def = getComponentDef(value);\n                    const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n                    dependencies.forEach((dependency) => {\n                        // Note: in AOT, the `dependencies` might also contain regular\n                        // (NgModule-based) Component, Directive and Pipes, so we handle\n                        // them separately and proceed with recursive process for standalone\n                        // Components and NgModules only.\n                        if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n                            queueTypesFromModulesArrayRecur([dependency]);\n                        }\n                        else {\n                            this.queueType(dependency, null);\n                        }\n                    });\n                }\n            }\n        };\n        queueTypesFromModulesArrayRecur(arr);\n    }\n    // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n    // that import (even transitively) an overridden one. For all affected modules we need to\n    // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n    // of this function is to collect all affected modules in a set for further processing. Example:\n    // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n    // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n    // invalidated with the override.\n    collectModulesAffectedByOverrides(arr) {\n        const seenModules = new Set();\n        const affectedModules = new Set();\n        const calcAffectedModulesRecur = (arr, path) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    // If the value is an array, just flatten it (by invoking this function recursively),\n                    // keeping \"path\" the same.\n                    calcAffectedModulesRecur(value, path);\n                }\n                else if (hasNgModuleDef(value)) {\n                    if (seenModules.has(value)) {\n                        // If we've seen this module before and it's included into \"affected modules\" list, mark\n                        // the whole path that leads to that module as affected, but do not descend into its\n                        // imports, since we already examined them before.\n                        if (affectedModules.has(value)) {\n                            path.forEach(item => affectedModules.add(item));\n                        }\n                        continue;\n                    }\n                    seenModules.add(value);\n                    if (this.overriddenModules.has(value)) {\n                        path.forEach(item => affectedModules.add(item));\n                    }\n                    // Examine module imports recursively to look for overridden modules.\n                    const moduleDef = value[\u0275NG_MOD_DEF];\n                    calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n                }\n            }\n        };\n        calcAffectedModulesRecur(arr, []);\n        return affectedModules;\n    }\n    /**\n     * Preserve an original def (such as \u0275mod, \u0275inj, etc) before applying an override.\n     * Note: one class may have multiple defs (for example: \u0275mod and \u0275inj in case of\n     * an NgModule). If there is a def in a set already, don't override it, since\n     * an original one should be restored at the end of a test.\n     */\n    maybeStoreNgDef(prop, type) {\n        if (!this.initialNgDefs.has(type)) {\n            this.initialNgDefs.set(type, new Map());\n        }\n        const currentDefs = this.initialNgDefs.get(type);\n        if (!currentDefs.has(prop)) {\n            const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n            currentDefs.set(prop, currentDef);\n        }\n    }\n    storeFieldOfDefOnType(type, defField, fieldName) {\n        const def = type[defField];\n        const originalValue = def[fieldName];\n        this.defCleanupOps.push({ object: def, fieldName, originalValue });\n    }\n    /**\n     * Clears current components resolution queue, but stores the state of the queue, so we can\n     * restore it later. Clearing the queue is required before we try to compile components (via\n     * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n     */\n    clearComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue === null) {\n            this.originalComponentResolutionQueue = new Map();\n        }\n        clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n    }\n    /*\n     * Restores component resolution queue to the previously saved state. This operation is performed\n     * as a part of restoring the state after completion of the current set of tests (that might\n     * potentially mutate the state).\n     */\n    restoreComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue !== null) {\n            restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n            this.originalComponentResolutionQueue = null;\n        }\n    }\n    restoreOriginalState() {\n        // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n        // case there were multiple overrides for the same field).\n        forEachRight(this.defCleanupOps, (op) => {\n            op.object[op.fieldName] = op.originalValue;\n        });\n        // Restore initial component/directive/pipe defs\n        this.initialNgDefs.forEach((defs, type) => {\n            defs.forEach((descriptor, prop) => {\n                if (!descriptor) {\n                    // Delete operations are generally undesirable since they have performance\n                    // implications on objects they were applied to. In this particular case, situations\n                    // where this code is invoked should be quite rare to cause any noticeable impact,\n                    // since it's applied only to some test cases (for example when class with no\n                    // annotations extends some @Component) when we need to clear '\u0275cmp' field on a given\n                    // class to restore its original state (before applying overrides and running tests).\n                    delete type[prop];\n                }\n                else {\n                    Object.defineProperty(type, prop, descriptor);\n                }\n            });\n        });\n        this.initialNgDefs.clear();\n        this.scopesWithOverriddenProviders.clear();\n        this.restoreComponentResolutionQueue();\n        // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n        \u0275setLocaleId(\u0275DEFAULT_LOCALE_ID);\n    }\n    compileTestModule() {\n        class RootScopeModule {\n        }\n        \u0275compileNgModuleDefs(RootScopeModule, {\n            providers: [...this.rootProviderOverrides],\n        });\n        const ngZone = new NgZone({ enableLongStackTrace: true });\n        const providers = [\n            { provide: NgZone, useValue: ngZone },\n            { provide: Compiler, useFactory: () => new R3TestCompiler(this) },\n            ...this.providers,\n            ...this.providerOverrides,\n        ];\n        const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n        // clang-format off\n        \u0275compileNgModuleDefs(this.testModuleType, {\n            declarations: this.declarations,\n            imports,\n            schemas: this.schemas,\n            providers,\n        }, /* allowDuplicateDeclarationsInRoot */ true);\n        // clang-format on\n        this.applyProviderOverridesInScope(this.testModuleType);\n    }\n    get injector() {\n        if (this._injector !== null) {\n            return this._injector;\n        }\n        const providers = [];\n        const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n        compilerOptions.forEach(opts => {\n            if (opts.providers) {\n                providers.push(opts.providers);\n            }\n        });\n        if (this.compilerProviders !== null) {\n            providers.push(...this.compilerProviders);\n        }\n        // TODO(ocombe): make this work with an Injector directly instead of creating a module for it\n        class CompilerModule {\n        }\n        \u0275compileNgModuleDefs(CompilerModule, { providers });\n        const CompilerModuleFactory = new \u0275NgModuleFactory(CompilerModule);\n        this._injector = CompilerModuleFactory.create(this.platform.injector).injector;\n        return this._injector;\n    }\n    // get overrides for a specific provider (if any)\n    getSingleProviderOverrides(provider) {\n        const token = getProviderToken(provider);\n        return this.providerOverridesByToken.get(token) || null;\n    }\n    getProviderOverrides(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        // There are two flattening operations here. The inner flatten() operates on the metadata's\n        // providers and applies a mapping function which retrieves overrides for each incoming\n        // provider. The outer flatten() then flattens the produced overrides array. If this is not\n        // done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n        // providers array and contaminate any error messages that might be generated.\n        return flatten(flatten(providers, (provider) => this.getSingleProviderOverrides(provider) || []));\n    }\n    getOverriddenProviders(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        const flattenedProviders = flatten(providers);\n        const overrides = this.getProviderOverrides(flattenedProviders);\n        const overriddenProviders = [...flattenedProviders, ...overrides];\n        const final = [];\n        const seenOverriddenProviders = new Set();\n        // We iterate through the list of providers in reverse order to make sure provider overrides\n        // take precedence over the values defined in provider list. We also filter out all providers\n        // that have overrides, keeping overridden values only. This is needed, since presence of a\n        // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n        forEachRight(overriddenProviders, (provider) => {\n            const token = getProviderToken(provider);\n            if (this.providerOverridesByToken.has(token)) {\n                if (!seenOverriddenProviders.has(token)) {\n                    seenOverriddenProviders.add(token);\n                    // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n                    // make sure that provided override takes highest precedence and is not combined with\n                    // other instances of the same multi provider.\n                    final.unshift({ ...provider, multi: false });\n                }\n            }\n            else {\n                final.unshift(provider);\n            }\n        });\n        return final;\n    }\n    hasProviderOverrides(providers) {\n        return this.getProviderOverrides(providers).length > 0;\n    }\n    patchDefWithProviderOverrides(declaration, field) {\n        const def = declaration[field];\n        if (def && def.providersResolver) {\n            this.maybeStoreNgDef(field, declaration);\n            const resolver = def.providersResolver;\n            const processProvidersFn = (providers) => this.getOverriddenProviders(providers);\n            this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n            def.providersResolver = (ngDef) => resolver(ngDef, processProvidersFn);\n        }\n    }\n}\nfunction initResolvers() {\n    return {\n        module: new NgModuleResolver(),\n        component: new ComponentResolver(),\n        directive: new DirectiveResolver(),\n        pipe: new PipeResolver()\n    };\n}\nfunction isStandaloneComponent(value) {\n    const def = getComponentDef(value);\n    return !!def?.standalone;\n}\nfunction getComponentDef(value) {\n    return value.\u0275cmp ?? null;\n}\nfunction hasNgModuleDef(value) {\n    return value.hasOwnProperty('\u0275mod');\n}\nfunction isNgModule(value) {\n    return hasNgModuleDef(value);\n}\nfunction maybeUnwrapFn(maybeFn) {\n    return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\nfunction flatten(values, mapFn) {\n    const out = [];\n    values.forEach(value => {\n        if (Array.isArray(value)) {\n            out.push(...flatten(value, mapFn));\n        }\n        else {\n            out.push(mapFn ? mapFn(value) : value);\n        }\n    });\n    return out;\n}\nfunction getProviderField(provider, field) {\n    return provider && typeof provider === 'object' && provider[field];\n}\nfunction getProviderToken(provider) {\n    return getProviderField(provider, 'provide') || provider;\n}\nfunction isModuleWithProviders(value) {\n    return value.hasOwnProperty('ngModule');\n}\nfunction forEachRight(values, fn) {\n    for (let idx = values.length - 1; idx >= 0; idx--) {\n        fn(values[idx], idx);\n    }\n}\nfunction invalidTypeError(name, expectedType) {\n    return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n    constructor(testBed) {\n        this.testBed = testBed;\n    }\n    compileModuleSync(moduleType) {\n        this.testBed._compileNgModuleSync(moduleType);\n        return new \u0275NgModuleFactory(moduleType);\n    }\n    async compileModuleAsync(moduleType) {\n        await this.testBed._compileNgModuleAsync(moduleType);\n        return new \u0275NgModuleFactory(moduleType);\n    }\n    compileModuleAndAllComponentsSync(moduleType) {\n        const ngModuleFactory = this.compileModuleSync(moduleType);\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    async compileModuleAndAllComponentsAsync(moduleType) {\n        const ngModuleFactory = await this.compileModuleAsync(moduleType);\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    clearCache() { }\n    clearCacheFor(type) { }\n    getModuleId(moduleType) {\n        const meta = this.testBed._getModuleResolver().resolve(moduleType);\n        return meta && meta.id || undefined;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _nextRootElementId = 0;\n/**\n * Returns a singleton of the `TestBed` class.\n *\n * @publicApi\n */\nfunction getTestBed() {\n    return TestBedImpl.INSTANCE;\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n */\nclass TestBedImpl {\n    constructor() {\n        // Properties\n        this.platform = null;\n        this.ngModule = null;\n        this._compiler = null;\n        this._testModuleRef = null;\n        this._activeFixtures = [];\n        /**\n         * Internal-only flag to indicate whether a module\n         * scoping queue has been checked and flushed already.\n         * @nodoc\n         */\n        this.globalCompilationChecked = false;\n    }\n    static get INSTANCE() {\n        return TestBedImpl._INSTANCE = TestBedImpl._INSTANCE || new TestBedImpl();\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    static initTestEnvironment(ngModule, platform, options) {\n        const testBed = TestBedImpl.INSTANCE;\n        testBed.initTestEnvironment(ngModule, platform, options);\n        return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    static resetTestEnvironment() {\n        TestBedImpl.INSTANCE.resetTestEnvironment();\n    }\n    static configureCompiler(config) {\n        return TestBedImpl.INSTANCE.configureCompiler(config);\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef) {\n        return TestBedImpl.INSTANCE.configureTestingModule(moduleDef);\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents() {\n        return TestBedImpl.INSTANCE.compileComponents();\n    }\n    static overrideModule(ngModule, override) {\n        return TestBedImpl.INSTANCE.overrideModule(ngModule, override);\n    }\n    static overrideComponent(component, override) {\n        return TestBedImpl.INSTANCE.overrideComponent(component, override);\n    }\n    static overrideDirective(directive, override) {\n        return TestBedImpl.INSTANCE.overrideDirective(directive, override);\n    }\n    static overridePipe(pipe, override) {\n        return TestBedImpl.INSTANCE.overridePipe(pipe, override);\n    }\n    static overrideTemplate(component, template) {\n        return TestBedImpl.INSTANCE.overrideTemplate(component, template);\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component, template) {\n        return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component, template);\n    }\n    static overrideProvider(token, provider) {\n        return TestBedImpl.INSTANCE.overrideProvider(token, provider);\n    }\n    static inject(token, notFoundValue, flags) {\n        return TestBedImpl.INSTANCE.inject(token, notFoundValue, flags);\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    static get(token, notFoundValue = Injector$1.THROW_IF_NOT_FOUND, flags = InjectFlags$1.Default) {\n        return TestBedImpl.INSTANCE.inject(token, notFoundValue, flags);\n    }\n    static createComponent(component) {\n        return TestBedImpl.INSTANCE.createComponent(component);\n    }\n    static resetTestingModule() {\n        return TestBedImpl.INSTANCE.resetTestingModule();\n    }\n    static execute(tokens, fn, context) {\n        return TestBedImpl.INSTANCE.execute(tokens, fn, context);\n    }\n    static get platform() {\n        return TestBedImpl.INSTANCE.platform;\n    }\n    static get ngModule() {\n        return TestBedImpl.INSTANCE.ngModule;\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    initTestEnvironment(ngModule, platform, options) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        TestBedImpl._environmentTeardownOptions = options?.teardown;\n        TestBedImpl._environmentErrorOnUnknownElementsOption = options?.errorOnUnknownElements;\n        TestBedImpl._environmentErrorOnUnknownPropertiesOption = options?.errorOnUnknownProperties;\n        this.platform = platform;\n        this.ngModule = ngModule;\n        this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n        // TestBed does not have an API which can reliably detect the start of a test, and thus could be\n        // used to track the state of the NgModule registry and reset it correctly. Instead, when we\n        // know we're in a testing scenario, we disable the check for duplicate NgModule registration\n        // completely.\n        \u0275setAllowDuplicateNgModuleIdsForTest(true);\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    resetTestEnvironment() {\n        this.resetTestingModule();\n        this._compiler = null;\n        this.platform = null;\n        this.ngModule = null;\n        TestBedImpl._environmentTeardownOptions = undefined;\n        \u0275setAllowDuplicateNgModuleIdsForTest(false);\n    }\n    resetTestingModule() {\n        this.checkGlobalCompilationFinished();\n        \u0275resetCompiledComponents();\n        if (this._compiler !== null) {\n            this.compiler.restoreOriginalState();\n        }\n        this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n        // Restore the previous value of the \"error on unknown elements\" option\n        \u0275setUnknownElementStrictMode$1(this._previousErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n        // Restore the previous value of the \"error on unknown properties\" option\n        \u0275setUnknownPropertyStrictMode$1(this._previousErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n        // We have to chain a couple of try/finally blocks, because each step can\n        // throw errors and we don't want it to interrupt the next step and we also\n        // want an error to be thrown at the end.\n        try {\n            this.destroyActiveFixtures();\n        }\n        finally {\n            try {\n                if (this.shouldTearDownTestingModule()) {\n                    this.tearDownTestingModule();\n                }\n            }\n            finally {\n                this._testModuleRef = null;\n                this._instanceTeardownOptions = undefined;\n                this._instanceErrorOnUnknownElementsOption = undefined;\n                this._instanceErrorOnUnknownPropertiesOption = undefined;\n            }\n        }\n        return this;\n    }\n    configureCompiler(config) {\n        if (config.useJit != null) {\n            throw new Error('the Render3 compiler JiT mode is not configurable !');\n        }\n        if (config.providers !== undefined) {\n            this.compiler.setCompilerProviders(config.providers);\n        }\n        return this;\n    }\n    configureTestingModule(moduleDef) {\n        this.assertNotInstantiated('R3TestBed.configureTestingModule', 'configure the test module');\n        // Trigger module scoping queue flush before executing other TestBed operations in a test.\n        // This is needed for the first test invocation to ensure that globally declared modules have\n        // their components scoped properly. See the `checkGlobalCompilationFinished` function\n        // description for additional info.\n        this.checkGlobalCompilationFinished();\n        // Always re-assign the options, even if they're undefined.\n        // This ensures that we don't carry them between tests.\n        this._instanceTeardownOptions = moduleDef.teardown;\n        this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\n        this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties;\n        // Store the current value of the strict mode option,\n        // so we can restore it later\n        this._previousErrorOnUnknownElementsOption = \u0275getUnknownElementStrictMode$1();\n        \u0275setUnknownElementStrictMode$1(this.shouldThrowErrorOnUnknownElements());\n        this._previousErrorOnUnknownPropertiesOption = \u0275getUnknownPropertyStrictMode$1();\n        \u0275setUnknownPropertyStrictMode$1(this.shouldThrowErrorOnUnknownProperties());\n        this.compiler.configureTestingModule(moduleDef);\n        return this;\n    }\n    compileComponents() {\n        return this.compiler.compileComponents();\n    }\n    inject(token, notFoundValue, flags) {\n        if (token === TestBed) {\n            return this;\n        }\n        const UNDEFINED = {};\n        const result = this.testModuleRef.injector.get(token, UNDEFINED, flags);\n        return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) :\n            result;\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get(token, notFoundValue = Injector$1.THROW_IF_NOT_FOUND, flags = InjectFlags$1.Default) {\n        return this.inject(token, notFoundValue, flags);\n    }\n    execute(tokens, fn, context) {\n        const params = tokens.map(t => this.inject(t));\n        return fn.apply(context, params);\n    }\n    overrideModule(ngModule, override) {\n        this.assertNotInstantiated('overrideModule', 'override module metadata');\n        this.compiler.overrideModule(ngModule, override);\n        return this;\n    }\n    overrideComponent(component, override) {\n        this.assertNotInstantiated('overrideComponent', 'override component metadata');\n        this.compiler.overrideComponent(component, override);\n        return this;\n    }\n    overrideTemplateUsingTestingModule(component, template) {\n        this.assertNotInstantiated('R3TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n        this.compiler.overrideTemplateUsingTestingModule(component, template);\n        return this;\n    }\n    overrideDirective(directive, override) {\n        this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this.compiler.overrideDirective(directive, override);\n        return this;\n    }\n    overridePipe(pipe, override) {\n        this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this.compiler.overridePipe(pipe, override);\n        return this;\n    }\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token, provider) {\n        this.assertNotInstantiated('overrideProvider', 'override provider');\n        this.compiler.overrideProvider(token, provider);\n        return this;\n    }\n    overrideTemplate(component, template) {\n        return this.overrideComponent(component, { set: { template, templateUrl: null } });\n    }\n    createComponent(type) {\n        const testComponentRenderer = this.inject(TestComponentRenderer);\n        const rootElId = `root${_nextRootElementId++}`;\n        testComponentRenderer.insertRootElement(rootElId);\n        const componentDef = type.\u0275cmp;\n        if (!componentDef) {\n            throw new Error(`It looks like '${\u0275stringify(type)}' has not been compiled.`);\n        }\n        // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n        const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n        // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n        const autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n        const ngZone = noNgZone ? null : this.inject(NgZone, null);\n        const componentFactory = new \u0275Render3ComponentFactory(componentDef);\n        const initComponent = () => {\n            const componentRef = componentFactory.create(Injector$1.NULL, [], `#${rootElId}`, this.testModuleRef);\n            return new ComponentFixture(componentRef, ngZone, autoDetect);\n        };\n        const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n        this._activeFixtures.push(fixture);\n        return fixture;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get compiler() {\n        if (this._compiler === null) {\n            throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n        }\n        return this._compiler;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get testModuleRef() {\n        if (this._testModuleRef === null) {\n            this._testModuleRef = this.compiler.finalize();\n        }\n        return this._testModuleRef;\n    }\n    assertNotInstantiated(methodName, methodDescription) {\n        if (this._testModuleRef !== null) {\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n        }\n    }\n    /**\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\n     *\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n     * in-progress module compilation. This creates a potential hazard - the very first time the\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\n     * compilations of modules declared in global scope. These compilations should be finished.\n     *\n     * To ensure that globally declared modules have their components scoped properly, this function\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n     * to any other operations, the scoping queue is flushed.\n     */\n    checkGlobalCompilationFinished() {\n        // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n        // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n        if (!this.globalCompilationChecked && this._testModuleRef === null) {\n            \u0275flushModuleScopingQueueAsMuchAsPossible();\n        }\n        this.globalCompilationChecked = true;\n    }\n    destroyActiveFixtures() {\n        let errorCount = 0;\n        this._activeFixtures.forEach((fixture) => {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                errorCount++;\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        });\n        this._activeFixtures = [];\n        if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n            throw Error(`${errorCount} ${(errorCount === 1 ? 'component' : 'components')} ` +\n                `threw errors during cleanup`);\n        }\n    }\n    shouldRethrowTeardownErrors() {\n        const instanceOptions = this._instanceTeardownOptions;\n        const environmentOptions = TestBedImpl._environmentTeardownOptions;\n        // If the new teardown behavior hasn't been configured, preserve the old behavior.\n        if (!instanceOptions && !environmentOptions) {\n            return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n        }\n        // Otherwise use the configured behavior or default to rethrowing.\n        return instanceOptions?.rethrowErrors ?? environmentOptions?.rethrowErrors ??\n            this.shouldTearDownTestingModule();\n    }\n    shouldThrowErrorOnUnknownElements() {\n        // Check if a configuration has been provided to throw when an unknown element is found\n        return this._instanceErrorOnUnknownElementsOption ??\n            TestBedImpl._environmentErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT;\n    }\n    shouldThrowErrorOnUnknownProperties() {\n        // Check if a configuration has been provided to throw when an unknown property is found\n        return this._instanceErrorOnUnknownPropertiesOption ??\n            TestBedImpl._environmentErrorOnUnknownPropertiesOption ??\n            THROW_ON_UNKNOWN_PROPERTIES_DEFAULT;\n    }\n    shouldTearDownTestingModule() {\n        return this._instanceTeardownOptions?.destroyAfterEach ??\n            TestBedImpl._environmentTeardownOptions?.destroyAfterEach ??\n            TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n    tearDownTestingModule() {\n        // If the module ref has already been destroyed, we won't be able to get a test renderer.\n        if (this._testModuleRef === null) {\n            return;\n        }\n        // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n        // last step, but the injector will be destroyed as a part of the module ref destruction.\n        const testRenderer = this.inject(TestComponentRenderer);\n        try {\n            this._testModuleRef.destroy();\n        }\n        catch (e) {\n            if (this.shouldRethrowTeardownErrors()) {\n                throw e;\n            }\n            else {\n                console.error('Error during cleanup of a testing module', {\n                    component: this._testModuleRef.instance,\n                    stacktrace: e,\n                });\n            }\n        }\n        finally {\n            testRenderer.removeAllRootElements?.();\n        }\n    }\n}\nTestBedImpl._INSTANCE = null;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * @publicApi\n */\nconst TestBed = TestBedImpl;\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`. Note: this function\n * (imported from the `@angular/core/testing` package) can **only** be used to inject dependencies\n * in tests. To inject dependencies in your application code, use the [`inject`](api/core/inject)\n * function from the `@angular/core` package instead.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\nfunction inject(tokens, fn) {\n    const testBed = TestBedImpl.INSTANCE;\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n        return testBed.execute(tokens, fn, this);\n    };\n}\n/**\n * @publicApi\n */\nclass InjectSetupWrapper {\n    constructor(_moduleDef) {\n        this._moduleDef = _moduleDef;\n    }\n    _addModule() {\n        const moduleDef = this._moduleDef();\n        if (moduleDef) {\n            TestBedImpl.configureTestingModule(moduleDef);\n        }\n    }\n    inject(tokens, fn) {\n        const self = this;\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            self._addModule();\n            return inject(tokens, fn).call(this);\n        };\n    }\n}\nfunction withModule(moduleDef, fn) {\n    if (fn) {\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            const testBed = TestBedImpl.INSTANCE;\n            if (moduleDef) {\n                testBed.configureTestingModule(moduleDef);\n            }\n            return fn.apply(this);\n        };\n    }\n    return new InjectSetupWrapper(() => moduleDef);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _global = (typeof window === 'undefined' ? global : window);\n// Reset the test providers and the fake async zone before each test.\nif (_global.beforeEach) {\n    _global.beforeEach(getCleanupHook(false));\n}\n// We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\nif (_global.afterEach) {\n    _global.afterEach(getCleanupHook(true));\n}\nfunction getCleanupHook(expectedTeardownValue) {\n    return () => {\n        const testBed = TestBedImpl.INSTANCE;\n        if (testBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n            testBed.resetTestingModule();\n            resetFakeAsyncZone();\n        }\n    };\n}\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\nconst __core_private_testing_placeholder__ = '';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, async, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, MetadataOverrider as \u0275MetadataOverrider };\n//# sourceMappingURL=testing.mjs.map\n"],
  "mappings": "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",
  "names": ["_Zone", "getDebugNode$1", "RendererFactory2$1", "InjectionToken$1", "FactoryTarget", "R3TemplateDependencyKind", "ViewEncapsulation", "name", "paramTypes", "paramAnnotations", "InjectFlags", "ChangeDetectionStrategy", "ChangeDetectorStatus", "store", "profiler", "isInI18nBlock", "location", "schemas", "RendererStyleFlags2", "getInsertInFrontOfRNodeWithI18n", "processI18nInsertBefore", "document", "SecurityContext", "isInlineTemplate", "ResolvedReflectiveFactory", "Symbol", "keyValueArraySet", "LocaleDataIndex", "plural", "I18nCreateOpCode", "changeMask", "value", "index", "substring", "inertBodyHelper", "hasBinding", "placeholder", "templateId", "isCloseTemplateTag", "multiFactory", "self", "TemplateRef", "ViewContainerRef", "i", "moduleType", "modules", "importingModule", "proto", "type", "ngModuleDef", "TestingModuleOverride", "resolveForwardRef$1", "LOCALE_ID$1", "arr", "Injector$1", "InjectFlags$1", "\u0275setUnknownElementStrictMode$1", "\u0275setUnknownPropertyStrictMode$1", "\u0275getUnknownElementStrictMode$1", "\u0275getUnknownPropertyStrictMode$1", "UNDEFINED"]
}
