3749706298babef7a0cafa7d29ba306b
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var router_exports = {};
__export(router_exports, {
  ActivatedRoute: () => ActivatedRoute,
  ActivatedRouteSnapshot: () => ActivatedRouteSnapshot,
  ActivationEnd: () => ActivationEnd,
  ActivationStart: () => ActivationStart,
  BaseRouteReuseStrategy: () => BaseRouteReuseStrategy,
  ChildActivationEnd: () => ChildActivationEnd,
  ChildActivationStart: () => ChildActivationStart,
  ChildrenOutletContexts: () => ChildrenOutletContexts,
  DefaultTitleStrategy: () => DefaultTitleStrategy,
  DefaultUrlSerializer: () => DefaultUrlSerializer,
  GuardsCheckEnd: () => GuardsCheckEnd,
  GuardsCheckStart: () => GuardsCheckStart,
  NavigationCancel: () => NavigationCancel,
  NavigationEnd: () => NavigationEnd,
  NavigationError: () => NavigationError,
  NavigationStart: () => NavigationStart,
  NoPreloading: () => NoPreloading,
  OutletContext: () => OutletContext,
  PRIMARY_OUTLET: () => PRIMARY_OUTLET,
  PreloadAllModules: () => PreloadAllModules,
  PreloadingStrategy: () => PreloadingStrategy,
  ROUTER_CONFIGURATION: () => ROUTER_CONFIGURATION,
  ROUTER_INITIALIZER: () => ROUTER_INITIALIZER,
  ROUTES: () => ROUTES,
  ResolveEnd: () => ResolveEnd,
  ResolveStart: () => ResolveStart,
  RouteConfigLoadEnd: () => RouteConfigLoadEnd,
  RouteConfigLoadStart: () => RouteConfigLoadStart,
  RouteReuseStrategy: () => RouteReuseStrategy,
  Router: () => Router,
  RouterEvent: () => RouterEvent,
  RouterLink: () => RouterLink,
  RouterLinkActive: () => RouterLinkActive,
  RouterLinkWithHref: () => RouterLinkWithHref,
  RouterModule: () => RouterModule,
  RouterOutlet: () => RouterOutlet,
  RouterPreloader: () => RouterPreloader,
  RouterState: () => RouterState,
  RouterStateSnapshot: () => RouterStateSnapshot,
  RoutesRecognized: () => RoutesRecognized,
  Scroll: () => Scroll,
  TitleStrategy: () => TitleStrategy,
  UrlHandlingStrategy: () => UrlHandlingStrategy,
  UrlSegment: () => UrlSegment,
  UrlSegmentGroup: () => UrlSegmentGroup,
  UrlSerializer: () => UrlSerializer,
  UrlTree: () => UrlTree,
  VERSION: () => VERSION,
  convertToParamMap: () => convertToParamMap,
  createUrlTreeFromSnapshot: () => createUrlTreeFromSnapshot,
  defaultUrlMatcher: () => defaultUrlMatcher,
  provideRouter: () => provideRouter,
  provideRoutes: () => provideRoutes,
  withDebugTracing: () => withDebugTracing,
  withDisabledInitialNavigation: () => withDisabledInitialNavigation,
  withEnabledBlockingInitialNavigation: () => withEnabledBlockingInitialNavigation,
  withInMemoryScrolling: () => withInMemoryScrolling,
  withPreloading: () => withPreloading,
  withRouterConfig: () => withRouterConfig,
  \u0275EmptyOutletComponent: () => \u0275EmptyOutletComponent,
  \u0275ROUTER_PROVIDERS: () => ROUTER_PROVIDERS,
  \u0275assignExtraOptionsToRouter: () => assignExtraOptionsToRouter,
  \u0275flatten: () => flatten,
  \u0275withPreloading: () => withPreloading
});
module.exports = __toCommonJS(router_exports);
var i0 = __toESM(require("@angular/core"), 1);
var import_core = require("@angular/core");
var import_rxjs = require("rxjs");
var i3 = __toESM(require("@angular/common"), 1);
var import_common = require("@angular/common");
var import_operators = require("rxjs/operators");
var i1 = __toESM(require("@angular/platform-browser"), 1);
/**
 * @license Angular v14.3.0
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const PRIMARY_OUTLET = "primary";
const RouteTitleKey = Symbol("RouteTitle");
class ParamsAsMap {
  constructor(params) {
    this.params = params || {};
  }
  has(name) {
    return Object.prototype.hasOwnProperty.call(this.params, name);
  }
  get(name) {
    if (this.has(name)) {
      const v = this.params[name];
      return Array.isArray(v) ? v[0] : v;
    }
    return null;
  }
  getAll(name) {
    if (this.has(name)) {
      const v = this.params[name];
      return Array.isArray(v) ? v : [v];
    }
    return [];
  }
  get keys() {
    return Object.keys(this.params);
  }
}
function convertToParamMap(params) {
  return new ParamsAsMap(params);
}
function defaultUrlMatcher(segments, segmentGroup, route) {
  const parts = route.path.split("/");
  if (parts.length > segments.length) {
    return null;
  }
  if (route.pathMatch === "full" && (segmentGroup.hasChildren() || parts.length < segments.length)) {
    return null;
  }
  const posParams = {};
  for (let index = 0; index < parts.length; index++) {
    const part = parts[index];
    const segment = segments[index];
    const isParameter = part.startsWith(":");
    if (isParameter) {
      posParams[part.substring(1)] = segment;
    } else if (part !== segment.path) {
      return null;
    }
  }
  return { consumed: segments.slice(0, parts.length), posParams };
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function shallowEqualArrays(a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; ++i) {
    if (!shallowEqual(a[i], b[i]))
      return false;
  }
  return true;
}
function shallowEqual(a, b) {
  const k1 = a ? Object.keys(a) : void 0;
  const k2 = b ? Object.keys(b) : void 0;
  if (!k1 || !k2 || k1.length != k2.length) {
    return false;
  }
  let key;
  for (let i = 0; i < k1.length; i++) {
    key = k1[i];
    if (!equalArraysOrString(a[key], b[key])) {
      return false;
    }
  }
  return true;
}
function equalArraysOrString(a, b) {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length)
      return false;
    const aSorted = [...a].sort();
    const bSorted = [...b].sort();
    return aSorted.every((val, index) => bSorted[index] === val);
  } else {
    return a === b;
  }
}
function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}
function last(a) {
  return a.length > 0 ? a[a.length - 1] : null;
}
function and(bools) {
  return !bools.some((v) => !v);
}
function forEach(map2, callback) {
  for (const prop in map2) {
    if (map2.hasOwnProperty(prop)) {
      callback(map2[prop], prop);
    }
  }
}
function wrapIntoObservable(value) {
  if ((0, import_core.\u0275isObservable)(value)) {
    return value;
  }
  if ((0, import_core.\u0275isPromise)(value)) {
    return (0, import_rxjs.from)(Promise.resolve(value));
  }
  return (0, import_rxjs.of)(value);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NG_DEV_MODE$9 = typeof ngDevMode === "undefined" || ngDevMode;
function createEmptyUrlTree() {
  return new UrlTree(new UrlSegmentGroup([], {}), {}, null);
}
const pathCompareMap = {
  "exact": equalSegmentGroups,
  "subset": containsSegmentGroup
};
const paramCompareMap = {
  "exact": equalParams,
  "subset": containsParams,
  "ignored": () => true
};
function containsTree(container, containee, options) {
  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === "exact" && container.fragment !== containee.fragment);
}
function equalParams(container, containee) {
  return shallowEqual(container, containee);
}
function equalSegmentGroups(container, containee, matrixParams) {
  if (!equalPath(container.segments, containee.segments))
    return false;
  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {
    return false;
  }
  if (container.numberOfChildren !== containee.numberOfChildren)
    return false;
  for (const c in containee.children) {
    if (!container.children[c])
      return false;
    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams))
      return false;
  }
  return true;
}
function containsParams(container, containee) {
  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key]));
}
function containsSegmentGroup(container, containee, matrixParams) {
  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);
}
function containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {
  if (container.segments.length > containeePaths.length) {
    const current = container.segments.slice(0, containeePaths.length);
    if (!equalPath(current, containeePaths))
      return false;
    if (containee.hasChildren())
      return false;
    if (!matrixParamsMatch(current, containeePaths, matrixParams))
      return false;
    return true;
  } else if (container.segments.length === containeePaths.length) {
    if (!equalPath(container.segments, containeePaths))
      return false;
    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams))
      return false;
    for (const c in containee.children) {
      if (!container.children[c])
        return false;
      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {
        return false;
      }
    }
    return true;
  } else {
    const current = containeePaths.slice(0, container.segments.length);
    const next = containeePaths.slice(container.segments.length);
    if (!equalPath(container.segments, current))
      return false;
    if (!matrixParamsMatch(container.segments, current, matrixParams))
      return false;
    if (!container.children[PRIMARY_OUTLET])
      return false;
    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);
  }
}
function matrixParamsMatch(containerPaths, containeePaths, options) {
  return containeePaths.every((containeeSegment, i) => {
    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);
  });
}
class UrlTree {
  constructor(root, queryParams, fragment) {
    this.root = root;
    this.queryParams = queryParams;
    this.fragment = fragment;
  }
  get queryParamMap() {
    if (!this._queryParamMap) {
      this._queryParamMap = convertToParamMap(this.queryParams);
    }
    return this._queryParamMap;
  }
  toString() {
    return DEFAULT_SERIALIZER.serialize(this);
  }
}
class UrlSegmentGroup {
  constructor(segments, children) {
    this.segments = segments;
    this.children = children;
    this.parent = null;
    forEach(children, (v, k) => v.parent = this);
  }
  hasChildren() {
    return this.numberOfChildren > 0;
  }
  get numberOfChildren() {
    return Object.keys(this.children).length;
  }
  toString() {
    return serializePaths(this);
  }
}
class UrlSegment {
  constructor(path, parameters) {
    this.path = path;
    this.parameters = parameters;
  }
  get parameterMap() {
    if (!this._parameterMap) {
      this._parameterMap = convertToParamMap(this.parameters);
    }
    return this._parameterMap;
  }
  toString() {
    return serializePath(this);
  }
}
function equalSegments(as, bs) {
  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));
}
function equalPath(as, bs) {
  if (as.length !== bs.length)
    return false;
  return as.every((a, i) => a.path === bs[i].path);
}
function mapChildrenIntoArray(segment, fn) {
  let res = [];
  forEach(segment.children, (child, childOutlet) => {
    if (childOutlet === PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  forEach(segment.children, (child, childOutlet) => {
    if (childOutlet !== PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  return res;
}
class UrlSerializer {
}
UrlSerializer.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: UrlSerializer, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable });
UrlSerializer.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: UrlSerializer, providedIn: "root", useFactory: () => new DefaultUrlSerializer() });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: UrlSerializer, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root", useFactory: () => new DefaultUrlSerializer() }]
}] });
class DefaultUrlSerializer {
  parse(url) {
    const p = new UrlParser(url);
    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
  }
  serialize(tree2) {
    const segment = `/${serializeSegment(tree2.root, true)}`;
    const query = serializeQueryParams(tree2.queryParams);
    const fragment = typeof tree2.fragment === `string` ? `#${encodeUriFragment(tree2.fragment)}` : "";
    return `${segment}${query}${fragment}`;
  }
}
const DEFAULT_SERIALIZER = new DefaultUrlSerializer();
function serializePaths(segment) {
  return segment.segments.map((p) => serializePath(p)).join("/");
}
function serializeSegment(segment, root) {
  if (!segment.hasChildren()) {
    return serializePaths(segment);
  }
  if (root) {
    const primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : "";
    const children = [];
    forEach(segment.children, (v, k) => {
      if (k !== PRIMARY_OUTLET) {
        children.push(`${k}:${serializeSegment(v, false)}`);
      }
    });
    return children.length > 0 ? `${primary}(${children.join("//")})` : primary;
  } else {
    const children = mapChildrenIntoArray(segment, (v, k) => {
      if (k === PRIMARY_OUTLET) {
        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
      }
      return [`${k}:${serializeSegment(v, false)}`];
    });
    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {
      return `${serializePaths(segment)}/${children[0]}`;
    }
    return `${serializePaths(segment)}/(${children.join("//")})`;
  }
}
function encodeUriString(s) {
  return encodeURIComponent(s).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",");
}
function encodeUriQuery(s) {
  return encodeUriString(s).replace(/%3B/gi, ";");
}
function encodeUriFragment(s) {
  return encodeURI(s);
}
function encodeUriSegment(s) {
  return encodeUriString(s).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&");
}
function decode(s) {
  return decodeURIComponent(s);
}
function decodeQuery(s) {
  return decode(s.replace(/\+/g, "%20"));
}
function serializePath(path) {
  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;
}
function serializeMatrixParams(params) {
  return Object.keys(params).map((key) => `;${encodeUriSegment(key)}=${encodeUriSegment(params[key])}`).join("");
}
function serializeQueryParams(params) {
  const strParams = Object.keys(params).map((name) => {
    const value = params[name];
    return Array.isArray(value) ? value.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join("&") : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;
  }).filter((s) => !!s);
  return strParams.length ? `?${strParams.join("&")}` : "";
}
const SEGMENT_RE = /^[^\/()?;=#]+/;
function matchSegments(str) {
  const match2 = str.match(SEGMENT_RE);
  return match2 ? match2[0] : "";
}
const QUERY_PARAM_RE = /^[^=?&#]+/;
function matchQueryParams(str) {
  const match2 = str.match(QUERY_PARAM_RE);
  return match2 ? match2[0] : "";
}
const QUERY_PARAM_VALUE_RE = /^[^&#]+/;
function matchUrlQueryParamValue(str) {
  const match2 = str.match(QUERY_PARAM_VALUE_RE);
  return match2 ? match2[0] : "";
}
class UrlParser {
  constructor(url) {
    this.url = url;
    this.remaining = url;
  }
  parseRootSegment() {
    this.consumeOptional("/");
    if (this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#")) {
      return new UrlSegmentGroup([], {});
    }
    return new UrlSegmentGroup([], this.parseChildren());
  }
  parseQueryParams() {
    const params = {};
    if (this.consumeOptional("?")) {
      do {
        this.parseQueryParam(params);
      } while (this.consumeOptional("&"));
    }
    return params;
  }
  parseFragment() {
    return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null;
  }
  parseChildren() {
    if (this.remaining === "") {
      return {};
    }
    this.consumeOptional("/");
    const segments = [];
    if (!this.peekStartsWith("(")) {
      segments.push(this.parseSegment());
    }
    while (this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(")) {
      this.capture("/");
      segments.push(this.parseSegment());
    }
    let children = {};
    if (this.peekStartsWith("/(")) {
      this.capture("/");
      children = this.parseParens(true);
    }
    let res = {};
    if (this.peekStartsWith("(")) {
      res = this.parseParens(false);
    }
    if (segments.length > 0 || Object.keys(children).length > 0) {
      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
    }
    return res;
  }
  parseSegment() {
    const path = matchSegments(this.remaining);
    if (path === "" && this.peekStartsWith(";")) {
      throw new import_core.\u0275RuntimeError(4009, NG_DEV_MODE$9 && `Empty path url segment cannot have parameters: '${this.remaining}'.`);
    }
    this.capture(path);
    return new UrlSegment(decode(path), this.parseMatrixParams());
  }
  parseMatrixParams() {
    const params = {};
    while (this.consumeOptional(";")) {
      this.parseParam(params);
    }
    return params;
  }
  parseParam(params) {
    const key = matchSegments(this.remaining);
    if (!key) {
      return;
    }
    this.capture(key);
    let value = "";
    if (this.consumeOptional("=")) {
      const valueMatch = matchSegments(this.remaining);
      if (valueMatch) {
        value = valueMatch;
        this.capture(value);
      }
    }
    params[decode(key)] = decode(value);
  }
  parseQueryParam(params) {
    const key = matchQueryParams(this.remaining);
    if (!key) {
      return;
    }
    this.capture(key);
    let value = "";
    if (this.consumeOptional("=")) {
      const valueMatch = matchUrlQueryParamValue(this.remaining);
      if (valueMatch) {
        value = valueMatch;
        this.capture(value);
      }
    }
    const decodedKey = decodeQuery(key);
    const decodedVal = decodeQuery(value);
    if (params.hasOwnProperty(decodedKey)) {
      let currentVal = params[decodedKey];
      if (!Array.isArray(currentVal)) {
        currentVal = [currentVal];
        params[decodedKey] = currentVal;
      }
      currentVal.push(decodedVal);
    } else {
      params[decodedKey] = decodedVal;
    }
  }
  parseParens(allowPrimary) {
    const segments = {};
    this.capture("(");
    while (!this.consumeOptional(")") && this.remaining.length > 0) {
      const path = matchSegments(this.remaining);
      const next = this.remaining[path.length];
      if (next !== "/" && next !== ")" && next !== ";") {
        throw new import_core.\u0275RuntimeError(4010, NG_DEV_MODE$9 && `Cannot parse url '${this.url}'`);
      }
      let outletName = void 0;
      if (path.indexOf(":") > -1) {
        outletName = path.slice(0, path.indexOf(":"));
        this.capture(outletName);
        this.capture(":");
      } else if (allowPrimary) {
        outletName = PRIMARY_OUTLET;
      }
      const children = this.parseChildren();
      segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);
      this.consumeOptional("//");
    }
    return segments;
  }
  peekStartsWith(str) {
    return this.remaining.startsWith(str);
  }
  consumeOptional(str) {
    if (this.peekStartsWith(str)) {
      this.remaining = this.remaining.substring(str.length);
      return true;
    }
    return false;
  }
  capture(str) {
    if (!this.consumeOptional(str)) {
      throw new import_core.\u0275RuntimeError(4011, NG_DEV_MODE$9 && `Expected "${str}".`);
    }
  }
}
function createRoot(rootCandidate) {
  return rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], { [PRIMARY_OUTLET]: rootCandidate }) : rootCandidate;
}
function squashSegmentGroup(segmentGroup) {
  const newChildren = {};
  for (const childOutlet of Object.keys(segmentGroup.children)) {
    const child = segmentGroup.children[childOutlet];
    const childCandidate = squashSegmentGroup(child);
    if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {
      newChildren[childOutlet] = childCandidate;
    }
  }
  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);
  return mergeTrivialChildren(s);
}
function mergeTrivialChildren(s) {
  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
    const c = s.children[PRIMARY_OUTLET];
    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
  }
  return s;
}
function isUrlTree(v) {
  return v instanceof UrlTree;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NG_DEV_MODE$8 = typeof ngDevMode === "undefined" || ngDevMode;
function createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null) {
  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);
  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);
}
function createSegmentGroupFromRoute(route) {
  let targetGroup;
  function createSegmentGroupFromRouteRecursive(currentRoute) {
    const childOutlets = {};
    for (const childSnapshot of currentRoute.children) {
      const root = createSegmentGroupFromRouteRecursive(childSnapshot);
      childOutlets[childSnapshot.outlet] = root;
    }
    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);
    if (currentRoute === route) {
      targetGroup = segmentGroup;
    }
    return segmentGroup;
  }
  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);
  const rootSegmentGroup = createRoot(rootCandidate);
  return targetGroup != null ? targetGroup : rootSegmentGroup;
}
function createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment) {
  let root = relativeTo;
  while (root.parent) {
    root = root.parent;
  }
  if (commands.length === 0) {
    return tree(root, root, root, queryParams, fragment);
  }
  const nav = computeNavigation(commands);
  if (nav.toRoot()) {
    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);
  }
  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);
  const newSegmentGroup = position.processChildren ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);
  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);
}
function createUrlTree(route, urlTree, commands, queryParams, fragment) {
  var _a, _b;
  if (commands.length === 0) {
    return tree(urlTree.root, urlTree.root, urlTree.root, queryParams, fragment);
  }
  const nav = computeNavigation(commands);
  if (nav.toRoot()) {
    return tree(urlTree.root, urlTree.root, new UrlSegmentGroup([], {}), queryParams, fragment);
  }
  function createTreeUsingPathIndex(lastPathIndex) {
    var _a2;
    const startingPosition = findStartingPosition(nav, urlTree, (_a2 = route.snapshot) == null ? void 0 : _a2._urlSegment, lastPathIndex);
    const segmentGroup = startingPosition.processChildren ? updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) : updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);
    return tree(urlTree.root, startingPosition.segmentGroup, segmentGroup, queryParams, fragment);
  }
  const result = createTreeUsingPathIndex((_a = route.snapshot) == null ? void 0 : _a._lastPathIndex);
  if (typeof ngDevMode === "undefined" || !!ngDevMode) {
    const correctedResult = createTreeUsingPathIndex((_b = route.snapshot) == null ? void 0 : _b._correctedLastPathIndex);
    if (correctedResult.toString() !== result.toString()) {
      console.warn(`relativeLinkResolution: 'legacy' is deprecated and will be removed in a future version of Angular. The link to ${result.toString()} will change to ${correctedResult.toString()} if the code is not updated before then.`);
    }
  }
  return result;
}
function isMatrixParams(command) {
  return typeof command === "object" && command != null && !command.outlets && !command.segmentPath;
}
function isCommandWithOutlets(command) {
  return typeof command === "object" && command != null && command.outlets;
}
function tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment) {
  let qp = {};
  if (queryParams) {
    forEach(queryParams, (value, name) => {
      qp[name] = Array.isArray(value) ? value.map((v) => `${v}`) : `${value}`;
    });
  }
  let rootCandidate;
  if (oldRoot === oldSegmentGroup) {
    rootCandidate = newSegmentGroup;
  } else {
    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);
  }
  const newRoot = createRoot(squashSegmentGroup(rootCandidate));
  return new UrlTree(newRoot, qp, fragment);
}
function replaceSegment(current, oldSegment, newSegment) {
  const children = {};
  forEach(current.children, (c, outletName) => {
    if (c === oldSegment) {
      children[outletName] = newSegment;
    } else {
      children[outletName] = replaceSegment(c, oldSegment, newSegment);
    }
  });
  return new UrlSegmentGroup(current.segments, children);
}
class Navigation {
  constructor(isAbsolute, numberOfDoubleDots, commands) {
    this.isAbsolute = isAbsolute;
    this.numberOfDoubleDots = numberOfDoubleDots;
    this.commands = commands;
    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
      throw new import_core.\u0275RuntimeError(4003, NG_DEV_MODE$8 && "Root segment cannot have matrix parameters");
    }
    const cmdWithOutlet = commands.find(isCommandWithOutlets);
    if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {
      throw new import_core.\u0275RuntimeError(4004, NG_DEV_MODE$8 && "{outlets:{}} has to be the last command");
    }
  }
  toRoot() {
    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/";
  }
}
function computeNavigation(commands) {
  if (typeof commands[0] === "string" && commands.length === 1 && commands[0] === "/") {
    return new Navigation(true, 0, commands);
  }
  let numberOfDoubleDots = 0;
  let isAbsolute = false;
  const res = commands.reduce((res2, cmd, cmdIdx) => {
    if (typeof cmd === "object" && cmd != null) {
      if (cmd.outlets) {
        const outlets = {};
        forEach(cmd.outlets, (commands2, name) => {
          outlets[name] = typeof commands2 === "string" ? commands2.split("/") : commands2;
        });
        return [...res2, { outlets }];
      }
      if (cmd.segmentPath) {
        return [...res2, cmd.segmentPath];
      }
    }
    if (!(typeof cmd === "string")) {
      return [...res2, cmd];
    }
    if (cmdIdx === 0) {
      cmd.split("/").forEach((urlPart, partIndex) => {
        if (partIndex == 0 && urlPart === ".") {
        } else if (partIndex == 0 && urlPart === "") {
          isAbsolute = true;
        } else if (urlPart === "..") {
          numberOfDoubleDots++;
        } else if (urlPart != "") {
          res2.push(urlPart);
        }
      });
      return res2;
    }
    return [...res2, cmd];
  }, []);
  return new Navigation(isAbsolute, numberOfDoubleDots, res);
}
class Position {
  constructor(segmentGroup, processChildren, index) {
    this.segmentGroup = segmentGroup;
    this.processChildren = processChildren;
    this.index = index;
  }
}
function findStartingPositionForTargetGroup(nav, root, target) {
  if (nav.isAbsolute) {
    return new Position(root, true, 0);
  }
  if (!target) {
    return new Position(root, false, NaN);
  }
  if (target.parent === null) {
    return new Position(target, true, 0);
  }
  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
  const index = target.segments.length - 1 + modifier;
  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);
}
function findStartingPosition(nav, tree2, segmentGroup, lastPathIndex) {
  if (nav.isAbsolute) {
    return new Position(tree2.root, true, 0);
  }
  if (lastPathIndex === -1) {
    const processChildren = segmentGroup === tree2.root;
    return new Position(segmentGroup, processChildren, 0);
  }
  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
  const index = lastPathIndex + modifier;
  return createPositionApplyingDoubleDots(segmentGroup, index, nav.numberOfDoubleDots);
}
function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
  let g = group;
  let ci = index;
  let dd = numberOfDoubleDots;
  while (dd > ci) {
    dd -= ci;
    g = g.parent;
    if (!g) {
      throw new import_core.\u0275RuntimeError(4005, NG_DEV_MODE$8 && "Invalid number of '../'");
    }
    ci = g.segments.length;
  }
  return new Position(g, false, ci - dd);
}
function getOutlets(commands) {
  if (isCommandWithOutlets(commands[0])) {
    return commands[0].outlets;
  }
  return { [PRIMARY_OUTLET]: commands };
}
function updateSegmentGroup(segmentGroup, startIndex, commands) {
  if (!segmentGroup) {
    segmentGroup = new UrlSegmentGroup([], {});
  }
  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
  }
  const m = prefixedWith(segmentGroup, startIndex, commands);
  const slicedCommands = commands.slice(m.commandIndex);
  if (m.match && m.pathIndex < segmentGroup.segments.length) {
    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
    return updateSegmentGroupChildren(g, 0, slicedCommands);
  } else if (m.match && slicedCommands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else if (m.match && !segmentGroup.hasChildren()) {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  } else if (m.match) {
    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
  } else {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  }
}
function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
  if (commands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else {
    const outlets = getOutlets(commands);
    const children = {};
    forEach(outlets, (commands2, outlet) => {
      if (typeof commands2 === "string") {
        commands2 = [commands2];
      }
      if (commands2 !== null) {
        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands2);
      }
    });
    forEach(segmentGroup.children, (child, childOutlet) => {
      if (outlets[childOutlet] === void 0) {
        children[childOutlet] = child;
      }
    });
    return new UrlSegmentGroup(segmentGroup.segments, children);
  }
}
function prefixedWith(segmentGroup, startIndex, commands) {
  let currentCommandIndex = 0;
  let currentPathIndex = startIndex;
  const noMatch2 = { match: false, pathIndex: 0, commandIndex: 0 };
  while (currentPathIndex < segmentGroup.segments.length) {
    if (currentCommandIndex >= commands.length)
      return noMatch2;
    const path = segmentGroup.segments[currentPathIndex];
    const command = commands[currentCommandIndex];
    if (isCommandWithOutlets(command)) {
      break;
    }
    const curr = `${command}`;
    const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
    if (currentPathIndex > 0 && curr === void 0)
      break;
    if (curr && next && typeof next === "object" && next.outlets === void 0) {
      if (!compare(curr, next, path))
        return noMatch2;
      currentCommandIndex += 2;
    } else {
      if (!compare(curr, {}, path))
        return noMatch2;
      currentCommandIndex++;
    }
    currentPathIndex++;
  }
  return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };
}
function createNewSegmentGroup(segmentGroup, startIndex, commands) {
  const paths = segmentGroup.segments.slice(0, startIndex);
  let i = 0;
  while (i < commands.length) {
    const command = commands[i];
    if (isCommandWithOutlets(command)) {
      const children = createNewSegmentChildren(command.outlets);
      return new UrlSegmentGroup(paths, children);
    }
    if (i === 0 && isMatrixParams(commands[0])) {
      const p = segmentGroup.segments[startIndex];
      paths.push(new UrlSegment(p.path, stringify(commands[0])));
      i++;
      continue;
    }
    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;
    const next = i < commands.length - 1 ? commands[i + 1] : null;
    if (curr && next && isMatrixParams(next)) {
      paths.push(new UrlSegment(curr, stringify(next)));
      i += 2;
    } else {
      paths.push(new UrlSegment(curr, {}));
      i++;
    }
  }
  return new UrlSegmentGroup(paths, {});
}
function createNewSegmentChildren(outlets) {
  const children = {};
  forEach(outlets, (commands, outlet) => {
    if (typeof commands === "string") {
      commands = [commands];
    }
    if (commands !== null) {
      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
    }
  });
  return children;
}
function stringify(params) {
  const res = {};
  forEach(params, (v, k) => res[k] = `${v}`);
  return res;
}
function compare(path, params, segment) {
  return path == segment.path && shallowEqual(params, segment.parameters);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class RouterEvent {
  constructor(id, url) {
    this.id = id;
    this.url = url;
  }
}
class NavigationStart extends RouterEvent {
  constructor(id, url, navigationTrigger = "imperative", restoredState = null) {
    super(id, url);
    this.type = 0;
    this.navigationTrigger = navigationTrigger;
    this.restoredState = restoredState;
  }
  toString() {
    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
  }
}
class NavigationEnd extends RouterEvent {
  constructor(id, url, urlAfterRedirects) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.type = 1;
  }
  toString() {
    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
  }
}
class NavigationCancel extends RouterEvent {
  constructor(id, url, reason, code) {
    super(id, url);
    this.reason = reason;
    this.code = code;
    this.type = 2;
  }
  toString() {
    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
  }
}
class NavigationError extends RouterEvent {
  constructor(id, url, error, target) {
    super(id, url);
    this.error = error;
    this.target = target;
    this.type = 3;
  }
  toString() {
    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
  }
}
class RoutesRecognized extends RouterEvent {
  constructor(id, url, urlAfterRedirects, state) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
    this.type = 4;
  }
  toString() {
    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
}
class GuardsCheckStart extends RouterEvent {
  constructor(id, url, urlAfterRedirects, state) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
    this.type = 7;
  }
  toString() {
    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
}
class GuardsCheckEnd extends RouterEvent {
  constructor(id, url, urlAfterRedirects, state, shouldActivate) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
    this.shouldActivate = shouldActivate;
    this.type = 8;
  }
  toString() {
    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
  }
}
class ResolveStart extends RouterEvent {
  constructor(id, url, urlAfterRedirects, state) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
    this.type = 5;
  }
  toString() {
    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
}
class ResolveEnd extends RouterEvent {
  constructor(id, url, urlAfterRedirects, state) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state;
    this.type = 6;
  }
  toString() {
    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
}
class RouteConfigLoadStart {
  constructor(route) {
    this.route = route;
    this.type = 9;
  }
  toString() {
    return `RouteConfigLoadStart(path: ${this.route.path})`;
  }
}
class RouteConfigLoadEnd {
  constructor(route) {
    this.route = route;
    this.type = 10;
  }
  toString() {
    return `RouteConfigLoadEnd(path: ${this.route.path})`;
  }
}
class ChildActivationStart {
  constructor(snapshot) {
    this.snapshot = snapshot;
    this.type = 11;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ChildActivationStart(path: '${path}')`;
  }
}
class ChildActivationEnd {
  constructor(snapshot) {
    this.snapshot = snapshot;
    this.type = 12;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ChildActivationEnd(path: '${path}')`;
  }
}
class ActivationStart {
  constructor(snapshot) {
    this.snapshot = snapshot;
    this.type = 13;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ActivationStart(path: '${path}')`;
  }
}
class ActivationEnd {
  constructor(snapshot) {
    this.snapshot = snapshot;
    this.type = 14;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ActivationEnd(path: '${path}')`;
  }
}
class Scroll {
  constructor(routerEvent, position, anchor) {
    this.routerEvent = routerEvent;
    this.position = position;
    this.anchor = anchor;
    this.type = 15;
  }
  toString() {
    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;
  }
}
function stringifyEvent(routerEvent) {
  var _a, _b, _c, _d;
  if (!("type" in routerEvent)) {
    return `Unknown Router Event: ${routerEvent.constructor.name}`;
  }
  switch (routerEvent.type) {
    case 14:
      return `ActivationEnd(path: '${((_a = routerEvent.snapshot.routeConfig) == null ? void 0 : _a.path) || ""}')`;
    case 13:
      return `ActivationStart(path: '${((_b = routerEvent.snapshot.routeConfig) == null ? void 0 : _b.path) || ""}')`;
    case 12:
      return `ChildActivationEnd(path: '${((_c = routerEvent.snapshot.routeConfig) == null ? void 0 : _c.path) || ""}')`;
    case 11:
      return `ChildActivationStart(path: '${((_d = routerEvent.snapshot.routeConfig) == null ? void 0 : _d.path) || ""}')`;
    case 8:
      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;
    case 7:
      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case 2:
      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case 1:
      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;
    case 3:
      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;
    case 0:
      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case 6:
      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case 5:
      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case 10:
      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;
    case 9:
      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;
    case 4:
      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case 15:
      const pos = routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;
      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class Tree {
  constructor(root) {
    this._root = root;
  }
  get root() {
    return this._root.value;
  }
  parent(t) {
    const p = this.pathFromRoot(t);
    return p.length > 1 ? p[p.length - 2] : null;
  }
  children(t) {
    const n = findNode(t, this._root);
    return n ? n.children.map((t2) => t2.value) : [];
  }
  firstChild(t) {
    const n = findNode(t, this._root);
    return n && n.children.length > 0 ? n.children[0].value : null;
  }
  siblings(t) {
    const p = findPath(t, this._root);
    if (p.length < 2)
      return [];
    const c = p[p.length - 2].children.map((c2) => c2.value);
    return c.filter((cc) => cc !== t);
  }
  pathFromRoot(t) {
    return findPath(t, this._root).map((s) => s.value);
  }
}
function findNode(value, node) {
  if (value === node.value)
    return node;
  for (const child of node.children) {
    const node2 = findNode(value, child);
    if (node2)
      return node2;
  }
  return null;
}
function findPath(value, node) {
  if (value === node.value)
    return [node];
  for (const child of node.children) {
    const path = findPath(value, child);
    if (path.length) {
      path.unshift(node);
      return path;
    }
  }
  return [];
}
class TreeNode {
  constructor(value, children) {
    this.value = value;
    this.children = children;
  }
  toString() {
    return `TreeNode(${this.value})`;
  }
}
function nodeChildrenAsMap(node) {
  const map2 = {};
  if (node) {
    node.children.forEach((child) => map2[child.value.outlet] = child);
  }
  return map2;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class RouterState extends Tree {
  constructor(root, snapshot) {
    super(root);
    this.snapshot = snapshot;
    setRouterState(this, root);
  }
  toString() {
    return this.snapshot.toString();
  }
}
function createEmptyState(urlTree, rootComponent) {
  const snapshot = createEmptyStateSnapshot(urlTree, rootComponent);
  const emptyUrl = new import_rxjs.BehaviorSubject([new UrlSegment("", {})]);
  const emptyParams = new import_rxjs.BehaviorSubject({});
  const emptyData = new import_rxjs.BehaviorSubject({});
  const emptyQueryParams = new import_rxjs.BehaviorSubject({});
  const fragment = new import_rxjs.BehaviorSubject("");
  const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
  activated.snapshot = snapshot.root;
  return new RouterState(new TreeNode(activated, []), snapshot);
}
function createEmptyStateSnapshot(urlTree, rootComponent) {
  const emptyParams = {};
  const emptyData = {};
  const emptyQueryParams = {};
  const fragment = "";
  const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});
  return new RouterStateSnapshot("", new TreeNode(activated, []));
}
class ActivatedRoute {
  constructor(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {
    var _a, _b;
    this.url = url;
    this.params = params;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.data = data;
    this.outlet = outlet;
    this.component = component;
    this.title = (_b = (_a = this.data) == null ? void 0 : _a.pipe((0, import_operators.map)((d) => d[RouteTitleKey]))) != null ? _b : (0, import_rxjs.of)(void 0);
    this._futureSnapshot = futureSnapshot;
  }
  get routeConfig() {
    return this._futureSnapshot.routeConfig;
  }
  get root() {
    return this._routerState.root;
  }
  get parent() {
    return this._routerState.parent(this);
  }
  get firstChild() {
    return this._routerState.firstChild(this);
  }
  get children() {
    return this._routerState.children(this);
  }
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this);
  }
  get paramMap() {
    if (!this._paramMap) {
      this._paramMap = this.params.pipe((0, import_operators.map)((p) => convertToParamMap(p)));
    }
    return this._paramMap;
  }
  get queryParamMap() {
    if (!this._queryParamMap) {
      this._queryParamMap = this.queryParams.pipe((0, import_operators.map)((p) => convertToParamMap(p)));
    }
    return this._queryParamMap;
  }
  toString() {
    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;
  }
}
function inheritedParamsDataResolve(route, paramsInheritanceStrategy = "emptyOnly") {
  const pathFromRoot = route.pathFromRoot;
  let inheritingStartingFrom = 0;
  if (paramsInheritanceStrategy !== "always") {
    inheritingStartingFrom = pathFromRoot.length - 1;
    while (inheritingStartingFrom >= 1) {
      const current = pathFromRoot[inheritingStartingFrom];
      const parent = pathFromRoot[inheritingStartingFrom - 1];
      if (current.routeConfig && current.routeConfig.path === "") {
        inheritingStartingFrom--;
      } else if (!parent.component) {
        inheritingStartingFrom--;
      } else {
        break;
      }
    }
  }
  return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));
}
function flattenInherited(pathFromRoot) {
  return pathFromRoot.reduce((res, curr) => {
    var _a;
    const params = __spreadValues(__spreadValues({}, res.params), curr.params);
    const data = __spreadValues(__spreadValues({}, res.data), curr.data);
    const resolve = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, curr.data), res.resolve), (_a = curr.routeConfig) == null ? void 0 : _a.data), curr._resolvedData);
    return { params, data, resolve };
  }, { params: {}, data: {}, resolve: {} });
}
class ActivatedRouteSnapshot {
  constructor(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve, correctedLastPathIndex) {
    var _a;
    this.url = url;
    this.params = params;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.data = data;
    this.outlet = outlet;
    this.component = component;
    this.title = (_a = this.data) == null ? void 0 : _a[RouteTitleKey];
    this.routeConfig = routeConfig;
    this._urlSegment = urlSegment;
    this._lastPathIndex = lastPathIndex;
    this._correctedLastPathIndex = correctedLastPathIndex != null ? correctedLastPathIndex : lastPathIndex;
    this._resolve = resolve;
  }
  get root() {
    return this._routerState.root;
  }
  get parent() {
    return this._routerState.parent(this);
  }
  get firstChild() {
    return this._routerState.firstChild(this);
  }
  get children() {
    return this._routerState.children(this);
  }
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this);
  }
  get paramMap() {
    if (!this._paramMap) {
      this._paramMap = convertToParamMap(this.params);
    }
    return this._paramMap;
  }
  get queryParamMap() {
    if (!this._queryParamMap) {
      this._queryParamMap = convertToParamMap(this.queryParams);
    }
    return this._queryParamMap;
  }
  toString() {
    const url = this.url.map((segment) => segment.toString()).join("/");
    const matched = this.routeConfig ? this.routeConfig.path : "";
    return `Route(url:'${url}', path:'${matched}')`;
  }
}
class RouterStateSnapshot extends Tree {
  constructor(url, root) {
    super(root);
    this.url = url;
    setRouterState(this, root);
  }
  toString() {
    return serializeNode(this._root);
  }
}
function setRouterState(state, node) {
  node.value._routerState = state;
  node.children.forEach((c) => setRouterState(state, c));
}
function serializeNode(node) {
  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(", ")} } ` : "";
  return `${node.value}${c}`;
}
function advanceActivatedRoute(route) {
  if (route.snapshot) {
    const currentSnapshot = route.snapshot;
    const nextSnapshot = route._futureSnapshot;
    route.snapshot = nextSnapshot;
    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
      route.queryParams.next(nextSnapshot.queryParams);
    }
    if (currentSnapshot.fragment !== nextSnapshot.fragment) {
      route.fragment.next(nextSnapshot.fragment);
    }
    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
      route.params.next(nextSnapshot.params);
    }
    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
      route.url.next(nextSnapshot.url);
    }
    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
      route.data.next(nextSnapshot.data);
    }
  } else {
    route.snapshot = route._futureSnapshot;
    route.data.next(route._futureSnapshot.data);
  }
}
function equalParamsAndUrlSegments(a, b) {
  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
  const parentsMismatch = !a.parent !== !b.parent;
  return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function createRouterState(routeReuseStrategy, curr, prevState) {
  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : void 0);
  return new RouterState(root, curr);
}
function createNode(routeReuseStrategy, curr, prevState) {
  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
    const value = prevState.value;
    value._futureSnapshot = curr.value;
    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
    return new TreeNode(value, children);
  } else {
    if (routeReuseStrategy.shouldAttach(curr.value)) {
      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);
      if (detachedRouteHandle !== null) {
        const tree2 = detachedRouteHandle.route;
        tree2.value._futureSnapshot = curr.value;
        tree2.children = curr.children.map((c) => createNode(routeReuseStrategy, c));
        return tree2;
      }
    }
    const value = createActivatedRoute(curr.value);
    const children = curr.children.map((c) => createNode(routeReuseStrategy, c));
    return new TreeNode(value, children);
  }
}
function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
  return curr.children.map((child) => {
    for (const p of prevState.children) {
      if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {
        return createNode(routeReuseStrategy, child, p);
      }
    }
    return createNode(routeReuseStrategy, child);
  });
}
function createActivatedRoute(c) {
  return new ActivatedRoute(new import_rxjs.BehaviorSubject(c.url), new import_rxjs.BehaviorSubject(c.params), new import_rxjs.BehaviorSubject(c.queryParams), new import_rxjs.BehaviorSubject(c.fragment), new import_rxjs.BehaviorSubject(c.data), c.outlet, c.component, c);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NAVIGATION_CANCELING_ERROR = "ngNavigationCancelingError";
function redirectingNavigationError(urlSerializer, redirect) {
  const { redirectTo, navigationBehaviorOptions } = isUrlTree(redirect) ? { redirectTo: redirect, navigationBehaviorOptions: void 0 } : redirect;
  const error = navigationCancelingError(ngDevMode && `Redirecting to "${urlSerializer.serialize(redirectTo)}"`, 0, redirect);
  error.url = redirectTo;
  error.navigationBehaviorOptions = navigationBehaviorOptions;
  return error;
}
function navigationCancelingError(message, code, redirectUrl) {
  const error = new Error("NavigationCancelingError: " + (message || ""));
  error[NAVIGATION_CANCELING_ERROR] = true;
  error.cancellationCode = code;
  if (redirectUrl) {
    error.url = redirectUrl;
  }
  return error;
}
function isRedirectingNavigationCancelingError$1(error) {
  return isNavigationCancelingError$1(error) && isUrlTree(error.url);
}
function isNavigationCancelingError$1(error) {
  return error && error[NAVIGATION_CANCELING_ERROR];
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class OutletContext {
  constructor() {
    this.outlet = null;
    this.route = null;
    this.resolver = null;
    this.injector = null;
    this.children = new ChildrenOutletContexts();
    this.attachRef = null;
  }
}
class ChildrenOutletContexts {
  constructor() {
    this.contexts = /* @__PURE__ */ new Map();
  }
  onChildOutletCreated(childName, outlet) {
    const context = this.getOrCreateContext(childName);
    context.outlet = outlet;
    this.contexts.set(childName, context);
  }
  onChildOutletDestroyed(childName) {
    const context = this.getContext(childName);
    if (context) {
      context.outlet = null;
      context.attachRef = null;
    }
  }
  onOutletDeactivated() {
    const contexts = this.contexts;
    this.contexts = /* @__PURE__ */ new Map();
    return contexts;
  }
  onOutletReAttached(contexts) {
    this.contexts = contexts;
  }
  getOrCreateContext(childName) {
    let context = this.getContext(childName);
    if (!context) {
      context = new OutletContext();
      this.contexts.set(childName, context);
    }
    return context;
  }
  getContext(childName) {
    return this.contexts.get(childName) || null;
  }
}
ChildrenOutletContexts.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ChildrenOutletContexts, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable });
ChildrenOutletContexts.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ChildrenOutletContexts, providedIn: "root" });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: ChildrenOutletContexts, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root" }]
}] });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NG_DEV_MODE$7 = typeof ngDevMode === "undefined" || ngDevMode;
class RouterOutlet {
  constructor(parentContexts, location, name, changeDetector, environmentInjector) {
    this.parentContexts = parentContexts;
    this.location = location;
    this.changeDetector = changeDetector;
    this.environmentInjector = environmentInjector;
    this.activated = null;
    this._activatedRoute = null;
    this.activateEvents = new import_core.EventEmitter();
    this.deactivateEvents = new import_core.EventEmitter();
    this.attachEvents = new import_core.EventEmitter();
    this.detachEvents = new import_core.EventEmitter();
    this.name = name || PRIMARY_OUTLET;
    parentContexts.onChildOutletCreated(this.name, this);
  }
  ngOnDestroy() {
    var _a;
    if (((_a = this.parentContexts.getContext(this.name)) == null ? void 0 : _a.outlet) === this) {
      this.parentContexts.onChildOutletDestroyed(this.name);
    }
  }
  ngOnInit() {
    if (!this.activated) {
      const context = this.parentContexts.getContext(this.name);
      if (context && context.route) {
        if (context.attachRef) {
          this.attach(context.attachRef, context.route);
        } else {
          this.activateWith(context.route, context.injector);
        }
      }
    }
  }
  get isActivated() {
    return !!this.activated;
  }
  get component() {
    if (!this.activated)
      throw new import_core.\u0275RuntimeError(4012, NG_DEV_MODE$7 && "Outlet is not activated");
    return this.activated.instance;
  }
  get activatedRoute() {
    if (!this.activated)
      throw new import_core.\u0275RuntimeError(4012, NG_DEV_MODE$7 && "Outlet is not activated");
    return this._activatedRoute;
  }
  get activatedRouteData() {
    if (this._activatedRoute) {
      return this._activatedRoute.snapshot.data;
    }
    return {};
  }
  detach() {
    if (!this.activated)
      throw new import_core.\u0275RuntimeError(4012, NG_DEV_MODE$7 && "Outlet is not activated");
    this.location.detach();
    const cmp = this.activated;
    this.activated = null;
    this._activatedRoute = null;
    this.detachEvents.emit(cmp.instance);
    return cmp;
  }
  attach(ref, activatedRoute) {
    this.activated = ref;
    this._activatedRoute = activatedRoute;
    this.location.insert(ref.hostView);
    this.attachEvents.emit(ref.instance);
  }
  deactivate() {
    if (this.activated) {
      const c = this.component;
      this.activated.destroy();
      this.activated = null;
      this._activatedRoute = null;
      this.deactivateEvents.emit(c);
    }
  }
  activateWith(activatedRoute, resolverOrInjector) {
    if (this.isActivated) {
      throw new import_core.\u0275RuntimeError(4013, NG_DEV_MODE$7 && "Cannot activate an already activated outlet");
    }
    this._activatedRoute = activatedRoute;
    const location = this.location;
    const snapshot = activatedRoute._futureSnapshot;
    const component = snapshot.component;
    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;
    const injector = new OutletInjector(activatedRoute, childContexts, location.injector);
    if (resolverOrInjector && isComponentFactoryResolver(resolverOrInjector)) {
      const factory = resolverOrInjector.resolveComponentFactory(component);
      this.activated = location.createComponent(factory, location.length, injector);
    } else {
      const environmentInjector = resolverOrInjector != null ? resolverOrInjector : this.environmentInjector;
      this.activated = location.createComponent(component, { index: location.length, injector, environmentInjector });
    }
    this.changeDetector.markForCheck();
    this.activateEvents.emit(this.activated.instance);
  }
}
RouterOutlet.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterOutlet, deps: [{ token: ChildrenOutletContexts }, { token: i0.ViewContainerRef }, { token: "name", attribute: true }, { token: i0.ChangeDetectorRef }, { token: i0.EnvironmentInjector }], target: i0.\u0275\u0275FactoryTarget.Directive });
RouterOutlet.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "14.3.0", type: RouterOutlet, isStandalone: true, selector: "router-outlet", outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], ngImport: i0 });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterOutlet, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "router-outlet",
    exportAs: "outlet",
    standalone: true
  }]
}], ctorParameters: function() {
  return [{ type: ChildrenOutletContexts }, { type: i0.ViewContainerRef }, { type: void 0, decorators: [{
    type: import_core.Attribute,
    args: ["name"]
  }] }, { type: i0.ChangeDetectorRef }, { type: i0.EnvironmentInjector }];
}, propDecorators: { activateEvents: [{
  type: import_core.Output,
  args: ["activate"]
}], deactivateEvents: [{
  type: import_core.Output,
  args: ["deactivate"]
}], attachEvents: [{
  type: import_core.Output,
  args: ["attach"]
}], detachEvents: [{
  type: import_core.Output,
  args: ["detach"]
}] } });
class OutletInjector {
  constructor(route, childContexts, parent) {
    this.route = route;
    this.childContexts = childContexts;
    this.parent = parent;
  }
  get(token, notFoundValue) {
    if (token === ActivatedRoute) {
      return this.route;
    }
    if (token === ChildrenOutletContexts) {
      return this.childContexts;
    }
    return this.parent.get(token, notFoundValue);
  }
}
function isComponentFactoryResolver(item) {
  return !!item.resolveComponentFactory;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class \u0275EmptyOutletComponent {
}
\u0275EmptyOutletComponent.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: \u0275EmptyOutletComponent, deps: [], target: i0.\u0275\u0275FactoryTarget.Component });
\u0275EmptyOutletComponent.\u0275cmp = i0.\u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "14.3.0", type: \u0275EmptyOutletComponent, isStandalone: true, selector: "ng-component", ngImport: i0, template: `<router-outlet></router-outlet>`, isInline: true, dependencies: [{ kind: "directive", type: RouterOutlet, selector: "router-outlet", outputs: ["activate", "deactivate", "attach", "detach"], exportAs: ["outlet"] }] });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: \u0275EmptyOutletComponent, decorators: [{
  type: import_core.Component,
  args: [{
    template: `<router-outlet></router-outlet>`,
    imports: [RouterOutlet],
    standalone: true
  }]
}] });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function getOrCreateRouteInjectorIfNeeded(route, currentInjector) {
  var _a;
  if (route.providers && !route._injector) {
    route._injector = (0, import_core.createEnvironmentInjector)(route.providers, currentInjector, `Route: ${route.path}`);
  }
  return (_a = route._injector) != null ? _a : currentInjector;
}
function getLoadedRoutes(route) {
  return route._loadedRoutes;
}
function getLoadedInjector(route) {
  return route._loadedInjector;
}
function getLoadedComponent(route) {
  return route._loadedComponent;
}
function getProvidersInjector(route) {
  return route._injector;
}
function validateConfig(config, parentPath = "", requireStandaloneComponents = false) {
  for (let i = 0; i < config.length; i++) {
    const route = config[i];
    const fullPath = getFullPath(parentPath, route);
    validateNode(route, fullPath, requireStandaloneComponents);
  }
}
function assertStandalone(fullPath, component) {
  if (component && !(0, import_core.\u0275isStandalone)(component)) {
    throw new import_core.\u0275RuntimeError(4014, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);
  }
}
function validateNode(route, fullPath, requireStandaloneComponents) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!route) {
      throw new import_core.\u0275RuntimeError(4014, `
      Invalid configuration of route '${fullPath}': Encountered undefined route.
      The reason might be an extra comma.

      Example:
      const routes: Routes = [
        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
        { path: 'dashboard',  component: DashboardComponent },, << two commas
        { path: 'detail/:id', component: HeroDetailComponent }
      ];
    `);
    }
    if (Array.isArray(route)) {
      throw new import_core.\u0275RuntimeError(4014, `Invalid configuration of route '${fullPath}': Array cannot be specified`);
    }
    if (!route.redirectTo && !route.component && !route.loadComponent && !route.children && !route.loadChildren && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {
      throw new import_core.\u0275RuntimeError(4014, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);
    }
    if (route.redirectTo && route.children) {
      throw new import_core.\u0275RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);
    }
    if (route.redirectTo && route.loadChildren) {
      throw new import_core.\u0275RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);
    }
    if (route.children && route.loadChildren) {
      throw new import_core.\u0275RuntimeError(4014, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);
    }
    if (route.redirectTo && (route.component || route.loadComponent)) {
      throw new import_core.\u0275RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);
    }
    if (route.component && route.loadComponent) {
      throw new import_core.\u0275RuntimeError(4014, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);
    }
    if (route.redirectTo && route.canActivate) {
      throw new import_core.\u0275RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and canActivate cannot be used together. Redirects happen before activation so canActivate will never be executed.`);
    }
    if (route.path && route.matcher) {
      throw new import_core.\u0275RuntimeError(4014, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);
    }
    if (route.redirectTo === void 0 && !route.component && !route.loadComponent && !route.children && !route.loadChildren) {
      throw new import_core.\u0275RuntimeError(4014, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);
    }
    if (route.path === void 0 && route.matcher === void 0) {
      throw new import_core.\u0275RuntimeError(4014, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);
    }
    if (typeof route.path === "string" && route.path.charAt(0) === "/") {
      throw new import_core.\u0275RuntimeError(4014, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);
    }
    if (route.path === "" && route.redirectTo !== void 0 && route.pathMatch === void 0) {
      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;
      throw new import_core.\u0275RuntimeError(4014, `Invalid configuration of route '{path: "${fullPath}", redirectTo: "${route.redirectTo}"}': please provide 'pathMatch'. ${exp}`);
    }
    if (requireStandaloneComponents) {
      assertStandalone(fullPath, route.component);
    }
  }
  if (route.children) {
    validateConfig(route.children, fullPath, requireStandaloneComponents);
  }
}
function getFullPath(parentPath, currentRoute) {
  if (!currentRoute) {
    return parentPath;
  }
  if (!parentPath && !currentRoute.path) {
    return "";
  } else if (parentPath && !currentRoute.path) {
    return `${parentPath}/`;
  } else if (!parentPath && currentRoute.path) {
    return currentRoute.path;
  } else {
    return `${parentPath}/${currentRoute.path}`;
  }
}
function standardizeConfig(r) {
  const children = r.children && r.children.map(standardizeConfig);
  const c = children ? __spreadProps(__spreadValues({}, r), { children }) : __spreadValues({}, r);
  if (!c.component && !c.loadComponent && (children || c.loadChildren) && (c.outlet && c.outlet !== PRIMARY_OUTLET)) {
    c.component = \u0275EmptyOutletComponent;
  }
  return c;
}
function getOutlet(route) {
  return route.outlet || PRIMARY_OUTLET;
}
function sortByMatchingOutlets(routes, outletName) {
  const sortedConfig = routes.filter((r) => getOutlet(r) === outletName);
  sortedConfig.push(...routes.filter((r) => getOutlet(r) !== outletName));
  return sortedConfig;
}
function getClosestRouteInjector(snapshot) {
  var _a;
  if (!snapshot)
    return null;
  if ((_a = snapshot.routeConfig) == null ? void 0 : _a._injector) {
    return snapshot.routeConfig._injector;
  }
  for (let s = snapshot.parent; s; s = s.parent) {
    const route = s.routeConfig;
    if (route == null ? void 0 : route._loadedInjector)
      return route._loadedInjector;
    if (route == null ? void 0 : route._injector)
      return route._injector;
  }
  return null;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent) => (0, import_operators.map)((t) => {
  new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent).activate(rootContexts);
  return t;
});
class ActivateRoutes {
  constructor(routeReuseStrategy, futureState, currState, forwardEvent) {
    this.routeReuseStrategy = routeReuseStrategy;
    this.futureState = futureState;
    this.currState = currState;
    this.forwardEvent = forwardEvent;
  }
  activate(parentContexts) {
    const futureRoot = this.futureState._root;
    const currRoot = this.currState ? this.currState._root : null;
    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
    advanceActivatedRoute(this.futureState.root);
    this.activateChildRoutes(futureRoot, currRoot, parentContexts);
  }
  deactivateChildRoutes(futureNode, currNode, contexts) {
    const children = nodeChildrenAsMap(currNode);
    futureNode.children.forEach((futureChild) => {
      const childOutletName = futureChild.value.outlet;
      this.deactivateRoutes(futureChild, children[childOutletName], contexts);
      delete children[childOutletName];
    });
    forEach(children, (v, childName) => {
      this.deactivateRouteAndItsChildren(v, contexts);
    });
  }
  deactivateRoutes(futureNode, currNode, parentContext) {
    const future = futureNode.value;
    const curr = currNode ? currNode.value : null;
    if (future === curr) {
      if (future.component) {
        const context = parentContext.getContext(future.outlet);
        if (context) {
          this.deactivateChildRoutes(futureNode, currNode, context.children);
        }
      } else {
        this.deactivateChildRoutes(futureNode, currNode, parentContext);
      }
    } else {
      if (curr) {
        this.deactivateRouteAndItsChildren(currNode, parentContext);
      }
    }
  }
  deactivateRouteAndItsChildren(route, parentContexts) {
    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
      this.detachAndStoreRouteSubtree(route, parentContexts);
    } else {
      this.deactivateRouteAndOutlet(route, parentContexts);
    }
  }
  detachAndStoreRouteSubtree(route, parentContexts) {
    const context = parentContexts.getContext(route.value.outlet);
    const contexts = context && route.value.component ? context.children : parentContexts;
    const children = nodeChildrenAsMap(route);
    for (const childOutlet of Object.keys(children)) {
      this.deactivateRouteAndItsChildren(children[childOutlet], contexts);
    }
    if (context && context.outlet) {
      const componentRef = context.outlet.detach();
      const contexts2 = context.children.onOutletDeactivated();
      this.routeReuseStrategy.store(route.value.snapshot, { componentRef, route, contexts: contexts2 });
    }
  }
  deactivateRouteAndOutlet(route, parentContexts) {
    const context = parentContexts.getContext(route.value.outlet);
    const contexts = context && route.value.component ? context.children : parentContexts;
    const children = nodeChildrenAsMap(route);
    for (const childOutlet of Object.keys(children)) {
      this.deactivateRouteAndItsChildren(children[childOutlet], contexts);
    }
    if (context && context.outlet) {
      context.outlet.deactivate();
      context.children.onOutletDeactivated();
      context.attachRef = null;
      context.resolver = null;
      context.route = null;
    }
  }
  activateChildRoutes(futureNode, currNode, contexts) {
    const children = nodeChildrenAsMap(currNode);
    futureNode.children.forEach((c) => {
      this.activateRoutes(c, children[c.value.outlet], contexts);
      this.forwardEvent(new ActivationEnd(c.value.snapshot));
    });
    if (futureNode.children.length) {
      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
    }
  }
  activateRoutes(futureNode, currNode, parentContexts) {
    var _a;
    const future = futureNode.value;
    const curr = currNode ? currNode.value : null;
    advanceActivatedRoute(future);
    if (future === curr) {
      if (future.component) {
        const context = parentContexts.getOrCreateContext(future.outlet);
        this.activateChildRoutes(futureNode, currNode, context.children);
      } else {
        this.activateChildRoutes(futureNode, currNode, parentContexts);
      }
    } else {
      if (future.component) {
        const context = parentContexts.getOrCreateContext(future.outlet);
        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
          const stored = this.routeReuseStrategy.retrieve(future.snapshot);
          this.routeReuseStrategy.store(future.snapshot, null);
          context.children.onOutletReAttached(stored.contexts);
          context.attachRef = stored.componentRef;
          context.route = stored.route.value;
          if (context.outlet) {
            context.outlet.attach(stored.componentRef, stored.route.value);
          }
          advanceActivatedRoute(stored.route.value);
          this.activateChildRoutes(futureNode, null, context.children);
        } else {
          const injector = getClosestRouteInjector(future.snapshot);
          const cmpFactoryResolver = (_a = injector == null ? void 0 : injector.get(import_core.ComponentFactoryResolver)) != null ? _a : null;
          context.attachRef = null;
          context.route = future;
          context.resolver = cmpFactoryResolver;
          context.injector = injector;
          if (context.outlet) {
            context.outlet.activateWith(future, context.injector);
          }
          this.activateChildRoutes(futureNode, null, context.children);
        }
      } else {
        this.activateChildRoutes(futureNode, null, parentContexts);
      }
    }
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class CanActivate {
  constructor(path) {
    this.path = path;
    this.route = this.path[this.path.length - 1];
  }
}
class CanDeactivate {
  constructor(component, route) {
    this.component = component;
    this.route = route;
  }
}
function getAllRouteGuards(future, curr, parentContexts) {
  const futureRoot = future._root;
  const currRoot = curr ? curr._root : null;
  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
}
function getCanActivateChild(p) {
  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;
  if (!canActivateChild || canActivateChild.length === 0)
    return null;
  return { node: p, guards: canActivateChild };
}
function getTokenOrFunctionIdentity(tokenOrFunction, injector) {
  const NOT_FOUND = Symbol();
  const result = injector.get(tokenOrFunction, NOT_FOUND);
  if (result === NOT_FOUND) {
    if (typeof tokenOrFunction === "function" && !(0, import_core.\u0275isInjectable)(tokenOrFunction)) {
      return tokenOrFunction;
    } else {
      return injector.get(tokenOrFunction);
    }
  }
  return result;
}
function getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const prevChildren = nodeChildrenAsMap(currNode);
  futureNode.children.forEach((c) => {
    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);
    delete prevChildren[c.value.outlet];
  });
  forEach(prevChildren, (v, k) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));
  return checks;
}
function getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const future = futureNode.value;
  const curr = currNode ? currNode.value : null;
  const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
  if (curr && future.routeConfig === curr.routeConfig) {
    const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
    if (shouldRun) {
      checks.canActivateChecks.push(new CanActivate(futurePath));
    } else {
      future.data = curr.data;
      future._resolvedData = curr._resolvedData;
    }
    if (future.component) {
      getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
    }
    if (shouldRun && context && context.outlet && context.outlet.isActivated) {
      checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));
    }
  } else {
    if (curr) {
      deactivateRouteAndItsChildren(currNode, context, checks);
    }
    checks.canActivateChecks.push(new CanActivate(futurePath));
    if (future.component) {
      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
    }
  }
  return checks;
}
function shouldRunGuardsAndResolvers(curr, future, mode) {
  if (typeof mode === "function") {
    return mode(curr, future);
  }
  switch (mode) {
    case "pathParamsChange":
      return !equalPath(curr.url, future.url);
    case "pathParamsOrQueryParamsChange":
      return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);
    case "always":
      return true;
    case "paramsOrQueryParamsChange":
      return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);
    case "paramsChange":
    default:
      return !equalParamsAndUrlSegments(curr, future);
  }
}
function deactivateRouteAndItsChildren(route, context, checks) {
  const children = nodeChildrenAsMap(route);
  const r = route.value;
  forEach(children, (node, childName) => {
    if (!r.component) {
      deactivateRouteAndItsChildren(node, context, checks);
    } else if (context) {
      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);
    } else {
      deactivateRouteAndItsChildren(node, null, checks);
    }
  });
  if (!r.component) {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r));
  } else if (context && context.outlet && context.outlet.isActivated) {
    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));
  } else {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r));
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function isFunction(v) {
  return typeof v === "function";
}
function isBoolean(v) {
  return typeof v === "boolean";
}
function isCanLoad(guard) {
  return guard && isFunction(guard.canLoad);
}
function isCanActivate(guard) {
  return guard && isFunction(guard.canActivate);
}
function isCanActivateChild(guard) {
  return guard && isFunction(guard.canActivateChild);
}
function isCanDeactivate(guard) {
  return guard && isFunction(guard.canDeactivate);
}
function isCanMatch(guard) {
  return guard && isFunction(guard.canMatch);
}
function isRedirectingNavigationCancelingError(error) {
  return isNavigationCancelingError(error) && isUrlTree(error.url);
}
function isNavigationCancelingError(error) {
  return error && error[NAVIGATION_CANCELING_ERROR];
}
function isEmptyError(e) {
  return e instanceof import_rxjs.EmptyError || (e == null ? void 0 : e.name) === "EmptyError";
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const INITIAL_VALUE = Symbol("INITIAL_VALUE");
function prioritizedGuardValue() {
  return (0, import_operators.switchMap)((obs) => {
    return (0, import_rxjs.combineLatest)(obs.map((o) => o.pipe((0, import_operators.take)(1), (0, import_operators.startWith)(INITIAL_VALUE)))).pipe((0, import_operators.map)((results) => {
      for (const result of results) {
        if (result === true) {
          continue;
        } else if (result === INITIAL_VALUE) {
          return INITIAL_VALUE;
        } else if (result === false || result instanceof UrlTree) {
          return result;
        }
      }
      return true;
    }), (0, import_operators.filter)((item) => item !== INITIAL_VALUE), (0, import_operators.take)(1));
  });
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function checkGuards(injector, forwardEvent) {
  return (0, import_operators.mergeMap)((t) => {
    const { targetSnapshot, currentSnapshot, guards: { canActivateChecks, canDeactivateChecks } } = t;
    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
      return (0, import_rxjs.of)(__spreadProps(__spreadValues({}, t), { guardsResult: true }));
    }
    return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe((0, import_operators.mergeMap)((canDeactivate) => {
      return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent) : (0, import_rxjs.of)(canDeactivate);
    }), (0, import_operators.map)((guardsResult) => __spreadProps(__spreadValues({}, t), { guardsResult })));
  });
}
function runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {
  return (0, import_rxjs.from)(checks).pipe((0, import_operators.mergeMap)((check) => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)), (0, import_operators.first)((result) => {
    return result !== true;
  }, true));
}
function runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {
  return (0, import_rxjs.from)(checks).pipe((0, import_operators.concatMap)((check) => {
    return (0, import_rxjs.concat)(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector));
  }), (0, import_operators.first)((result) => {
    return result !== true;
  }, true));
}
function fireActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ActivationStart(snapshot));
  }
  return (0, import_rxjs.of)(true);
}
function fireChildActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ChildActivationStart(snapshot));
  }
  return (0, import_rxjs.of)(true);
}
function runCanActivate(futureRSS, futureARS, injector) {
  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
  if (!canActivate || canActivate.length === 0)
    return (0, import_rxjs.of)(true);
  const canActivateObservables = canActivate.map((canActivate2) => {
    return (0, import_rxjs.defer)(() => {
      var _a;
      const closestInjector = (_a = getClosestRouteInjector(futureARS)) != null ? _a : injector;
      const guard = getTokenOrFunctionIdentity(canActivate2, closestInjector);
      const guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) : closestInjector.runInContext(() => guard(futureARS, futureRSS));
      return wrapIntoObservable(guardVal).pipe((0, import_operators.first)());
    });
  });
  return (0, import_rxjs.of)(canActivateObservables).pipe(prioritizedGuardValue());
}
function runCanActivateChild(futureRSS, path, injector) {
  const futureARS = path[path.length - 1];
  const canActivateChildGuards = path.slice(0, path.length - 1).reverse().map((p) => getCanActivateChild(p)).filter((_) => _ !== null);
  const canActivateChildGuardsMapped = canActivateChildGuards.map((d) => {
    return (0, import_rxjs.defer)(() => {
      const guardsMapped = d.guards.map((canActivateChild) => {
        var _a;
        const closestInjector = (_a = getClosestRouteInjector(d.node)) != null ? _a : injector;
        const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);
        const guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) : closestInjector.runInContext(() => guard(futureARS, futureRSS));
        return wrapIntoObservable(guardVal).pipe((0, import_operators.first)());
      });
      return (0, import_rxjs.of)(guardsMapped).pipe(prioritizedGuardValue());
    });
  });
  return (0, import_rxjs.of)(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
}
function runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {
  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
  if (!canDeactivate || canDeactivate.length === 0)
    return (0, import_rxjs.of)(true);
  const canDeactivateObservables = canDeactivate.map((c) => {
    var _a;
    const closestInjector = (_a = getClosestRouteInjector(currARS)) != null ? _a : injector;
    const guard = getTokenOrFunctionIdentity(c, closestInjector);
    const guardVal = isCanDeactivate(guard) ? guard.canDeactivate(component, currARS, currRSS, futureRSS) : closestInjector.runInContext(() => guard(component, currARS, currRSS, futureRSS));
    return wrapIntoObservable(guardVal).pipe((0, import_operators.first)());
  });
  return (0, import_rxjs.of)(canDeactivateObservables).pipe(prioritizedGuardValue());
}
function runCanLoadGuards(injector, route, segments, urlSerializer) {
  const canLoad = route.canLoad;
  if (canLoad === void 0 || canLoad.length === 0) {
    return (0, import_rxjs.of)(true);
  }
  const canLoadObservables = canLoad.map((injectionToken) => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : injector.runInContext(() => guard(route, segments));
    return wrapIntoObservable(guardVal);
  });
  return (0, import_rxjs.of)(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
function redirectIfUrlTree(urlSerializer) {
  return (0, import_rxjs.pipe)((0, import_operators.tap)((result) => {
    if (!isUrlTree(result))
      return;
    throw redirectingNavigationError(urlSerializer, result);
  }), (0, import_operators.map)((result) => result === true));
}
function runCanMatchGuards(injector, route, segments, urlSerializer) {
  const canMatch = route.canMatch;
  if (!canMatch || canMatch.length === 0)
    return (0, import_rxjs.of)(true);
  const canMatchObservables = canMatch.map((injectionToken) => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : injector.runInContext(() => guard(route, segments));
    return wrapIntoObservable(guardVal);
  });
  return (0, import_rxjs.of)(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const noMatch$1 = {
  matched: false,
  consumedSegments: [],
  remainingSegments: [],
  parameters: {},
  positionalParamSegments: {}
};
function matchWithChecks(segmentGroup, route, segments, injector, urlSerializer) {
  const result = match(segmentGroup, route, segments);
  if (!result.matched) {
    return (0, import_rxjs.of)(result);
  }
  injector = getOrCreateRouteInjectorIfNeeded(route, injector);
  return runCanMatchGuards(injector, route, segments, urlSerializer).pipe((0, import_operators.map)((v) => v === true ? result : __spreadValues({}, noMatch$1)));
}
function match(segmentGroup, route, segments) {
  var _a;
  if (route.path === "") {
    if (route.pathMatch === "full" && (segmentGroup.hasChildren() || segments.length > 0)) {
      return __spreadValues({}, noMatch$1);
    }
    return {
      matched: true,
      consumedSegments: [],
      remainingSegments: segments,
      parameters: {},
      positionalParamSegments: {}
    };
  }
  const matcher = route.matcher || defaultUrlMatcher;
  const res = matcher(segments, segmentGroup, route);
  if (!res)
    return __spreadValues({}, noMatch$1);
  const posParams = {};
  forEach(res.posParams, (v, k) => {
    posParams[k] = v.path;
  });
  const parameters = res.consumed.length > 0 ? __spreadValues(__spreadValues({}, posParams), res.consumed[res.consumed.length - 1].parameters) : posParams;
  return {
    matched: true,
    consumedSegments: res.consumed,
    remainingSegments: segments.slice(res.consumed.length),
    parameters,
    positionalParamSegments: (_a = res.posParams) != null ? _a : {}
  };
}
function split(segmentGroup, consumedSegments, slicedSegments, config, relativeLinkResolution = "corrected") {
  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {
    const s2 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
    s2._sourceSegment = segmentGroup;
    s2._segmentIndexShift = consumedSegments.length;
    return { segmentGroup: s2, slicedSegments: [] };
  }
  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {
    const s2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, config, segmentGroup.children, relativeLinkResolution));
    s2._sourceSegment = segmentGroup;
    s2._segmentIndexShift = consumedSegments.length;
    return { segmentGroup: s2, slicedSegments };
  }
  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
  s._sourceSegment = segmentGroup;
  s._segmentIndexShift = consumedSegments.length;
  return { segmentGroup: s, slicedSegments };
}
function addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, routes, children, relativeLinkResolution) {
  const res = {};
  for (const r of routes) {
    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {
      const s = new UrlSegmentGroup([], {});
      s._sourceSegment = segmentGroup;
      if (relativeLinkResolution === "legacy") {
        s._segmentIndexShift = segmentGroup.segments.length;
        if (typeof ngDevMode === "undefined" || !!ngDevMode) {
          s._segmentIndexShiftCorrected = consumedSegments.length;
        }
      } else {
        s._segmentIndexShift = consumedSegments.length;
      }
      res[getOutlet(r)] = s;
    }
  }
  return __spreadValues(__spreadValues({}, children), res);
}
function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {
  const res = {};
  res[PRIMARY_OUTLET] = primarySegment;
  primarySegment._sourceSegment = segmentGroup;
  primarySegment._segmentIndexShift = consumedSegments.length;
  for (const r of routes) {
    if (r.path === "" && getOutlet(r) !== PRIMARY_OUTLET) {
      const s = new UrlSegmentGroup([], {});
      s._sourceSegment = segmentGroup;
      s._segmentIndexShift = consumedSegments.length;
      res[getOutlet(r)] = s;
    }
  }
  return res;
}
function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {
  return routes.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);
}
function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {
  return routes.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r));
}
function emptyPathMatch(segmentGroup, slicedSegments, r) {
  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === "full") {
    return false;
  }
  return r.path === "";
}
function isImmediateMatch(route, rawSegment, segments, outlet) {
  if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {
    return false;
  }
  if (route.path === "**") {
    return true;
  }
  return match(rawSegment, route, segments).matched;
}
function noLeftoversInUrl(segmentGroup, segments, outlet) {
  return segments.length === 0 && !segmentGroup.children[outlet];
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NG_DEV_MODE$6 = typeof ngDevMode === "undefined" || ngDevMode;
class NoMatch$1 {
  constructor(segmentGroup) {
    this.segmentGroup = segmentGroup || null;
  }
}
class AbsoluteRedirect {
  constructor(urlTree) {
    this.urlTree = urlTree;
  }
}
function noMatch(segmentGroup) {
  return (0, import_rxjs.throwError)(new NoMatch$1(segmentGroup));
}
function absoluteRedirect(newTree) {
  return (0, import_rxjs.throwError)(new AbsoluteRedirect(newTree));
}
function namedOutletsRedirect(redirectTo) {
  return (0, import_rxjs.throwError)(new import_core.\u0275RuntimeError(4e3, NG_DEV_MODE$6 && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));
}
function canLoadFails(route) {
  return (0, import_rxjs.throwError)(navigationCancelingError(NG_DEV_MODE$6 && `Cannot load children because the guard of the route "path: '${route.path}'" returned false`, 3));
}
function applyRedirects$1(injector, configLoader, urlSerializer, urlTree, config) {
  return new ApplyRedirects(injector, configLoader, urlSerializer, urlTree, config).apply();
}
class ApplyRedirects {
  constructor(injector, configLoader, urlSerializer, urlTree, config) {
    this.injector = injector;
    this.configLoader = configLoader;
    this.urlSerializer = urlSerializer;
    this.urlTree = urlTree;
    this.config = config;
    this.allowRedirects = true;
  }
  apply() {
    const splitGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;
    const rootSegmentGroup = new UrlSegmentGroup(splitGroup.segments, splitGroup.children);
    const expanded$ = this.expandSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET);
    const urlTrees$ = expanded$.pipe((0, import_operators.map)((rootSegmentGroup2) => {
      return this.createUrlTree(squashSegmentGroup(rootSegmentGroup2), this.urlTree.queryParams, this.urlTree.fragment);
    }));
    return urlTrees$.pipe((0, import_operators.catchError)((e) => {
      if (e instanceof AbsoluteRedirect) {
        this.allowRedirects = false;
        return this.match(e.urlTree);
      }
      if (e instanceof NoMatch$1) {
        throw this.noMatchError(e);
      }
      throw e;
    }));
  }
  match(tree2) {
    const expanded$ = this.expandSegmentGroup(this.injector, this.config, tree2.root, PRIMARY_OUTLET);
    const mapped$ = expanded$.pipe((0, import_operators.map)((rootSegmentGroup) => {
      return this.createUrlTree(squashSegmentGroup(rootSegmentGroup), tree2.queryParams, tree2.fragment);
    }));
    return mapped$.pipe((0, import_operators.catchError)((e) => {
      if (e instanceof NoMatch$1) {
        throw this.noMatchError(e);
      }
      throw e;
    }));
  }
  noMatchError(e) {
    return new import_core.\u0275RuntimeError(4002, NG_DEV_MODE$6 && `Cannot match any routes. URL Segment: '${e.segmentGroup}'`);
  }
  createUrlTree(rootCandidate, queryParams, fragment) {
    const root = createRoot(rootCandidate);
    return new UrlTree(root, queryParams, fragment);
  }
  expandSegmentGroup(injector, routes, segmentGroup, outlet) {
    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
      return this.expandChildren(injector, routes, segmentGroup).pipe((0, import_operators.map)((children) => new UrlSegmentGroup([], children)));
    }
    return this.expandSegment(injector, segmentGroup, routes, segmentGroup.segments, outlet, true);
  }
  expandChildren(injector, routes, segmentGroup) {
    const childOutlets = [];
    for (const child of Object.keys(segmentGroup.children)) {
      if (child === "primary") {
        childOutlets.unshift(child);
      } else {
        childOutlets.push(child);
      }
    }
    return (0, import_rxjs.from)(childOutlets).pipe((0, import_operators.concatMap)((childOutlet) => {
      const child = segmentGroup.children[childOutlet];
      const sortedRoutes = sortByMatchingOutlets(routes, childOutlet);
      return this.expandSegmentGroup(injector, sortedRoutes, child, childOutlet).pipe((0, import_operators.map)((s) => ({ segment: s, outlet: childOutlet })));
    }), (0, import_operators.scan)((children, expandedChild) => {
      children[expandedChild.outlet] = expandedChild.segment;
      return children;
    }, {}), (0, import_operators.last)());
  }
  expandSegment(injector, segmentGroup, routes, segments, outlet, allowRedirects) {
    return (0, import_rxjs.from)(routes).pipe((0, import_operators.concatMap)((r) => {
      const expanded$ = this.expandSegmentAgainstRoute(injector, segmentGroup, routes, r, segments, outlet, allowRedirects);
      return expanded$.pipe((0, import_operators.catchError)((e) => {
        if (e instanceof NoMatch$1) {
          return (0, import_rxjs.of)(null);
        }
        throw e;
      }));
    }), (0, import_operators.first)((s) => !!s), (0, import_operators.catchError)((e, _) => {
      if (isEmptyError(e)) {
        if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
          return (0, import_rxjs.of)(new UrlSegmentGroup([], {}));
        }
        return noMatch(segmentGroup);
      }
      throw e;
    }));
  }
  expandSegmentAgainstRoute(injector, segmentGroup, routes, route, paths, outlet, allowRedirects) {
    if (!isImmediateMatch(route, segmentGroup, paths, outlet)) {
      return noMatch(segmentGroup);
    }
    if (route.redirectTo === void 0) {
      return this.matchSegmentAgainstRoute(injector, segmentGroup, route, paths, outlet);
    }
    if (allowRedirects && this.allowRedirects) {
      return this.expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, paths, outlet);
    }
    return noMatch(segmentGroup);
  }
  expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet) {
    if (route.path === "**") {
      return this.expandWildCardWithParamsAgainstRouteUsingRedirect(injector, routes, route, outlet);
    }
    return this.expandRegularSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet);
  }
  expandWildCardWithParamsAgainstRouteUsingRedirect(injector, routes, route, outlet) {
    const newTree = this.applyRedirectCommands([], route.redirectTo, {});
    if (route.redirectTo.startsWith("/")) {
      return absoluteRedirect(newTree);
    }
    return this.lineralizeSegments(route, newTree).pipe((0, import_operators.mergeMap)((newSegments) => {
      const group = new UrlSegmentGroup(newSegments, {});
      return this.expandSegment(injector, group, routes, newSegments, outlet, false);
    }));
  }
  expandRegularSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet) {
    const { matched, consumedSegments, remainingSegments, positionalParamSegments } = match(segmentGroup, route, segments);
    if (!matched)
      return noMatch(segmentGroup);
    const newTree = this.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments);
    if (route.redirectTo.startsWith("/")) {
      return absoluteRedirect(newTree);
    }
    return this.lineralizeSegments(route, newTree).pipe((0, import_operators.mergeMap)((newSegments) => {
      return this.expandSegment(injector, segmentGroup, routes, newSegments.concat(remainingSegments), outlet, false);
    }));
  }
  matchSegmentAgainstRoute(injector, rawSegmentGroup, route, segments, outlet) {
    if (route.path === "**") {
      injector = getOrCreateRouteInjectorIfNeeded(route, injector);
      if (route.loadChildren) {
        const loaded$ = route._loadedRoutes ? (0, import_rxjs.of)({ routes: route._loadedRoutes, injector: route._loadedInjector }) : this.configLoader.loadChildren(injector, route);
        return loaded$.pipe((0, import_operators.map)((cfg) => {
          route._loadedRoutes = cfg.routes;
          route._loadedInjector = cfg.injector;
          return new UrlSegmentGroup(segments, {});
        }));
      }
      return (0, import_rxjs.of)(new UrlSegmentGroup(segments, {}));
    }
    return matchWithChecks(rawSegmentGroup, route, segments, injector, this.urlSerializer).pipe((0, import_operators.switchMap)(({ matched, consumedSegments, remainingSegments }) => {
      var _a;
      if (!matched)
        return noMatch(rawSegmentGroup);
      injector = (_a = route._injector) != null ? _a : injector;
      const childConfig$ = this.getChildConfig(injector, route, segments);
      return childConfig$.pipe((0, import_operators.mergeMap)((routerConfig) => {
        var _a2;
        const childInjector = (_a2 = routerConfig.injector) != null ? _a2 : injector;
        const childConfig = routerConfig.routes;
        const { segmentGroup: splitSegmentGroup, slicedSegments } = split(rawSegmentGroup, consumedSegments, remainingSegments, childConfig);
        const segmentGroup = new UrlSegmentGroup(splitSegmentGroup.segments, splitSegmentGroup.children);
        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
          const expanded$2 = this.expandChildren(childInjector, childConfig, segmentGroup);
          return expanded$2.pipe((0, import_operators.map)((children) => new UrlSegmentGroup(consumedSegments, children)));
        }
        if (childConfig.length === 0 && slicedSegments.length === 0) {
          return (0, import_rxjs.of)(new UrlSegmentGroup(consumedSegments, {}));
        }
        const matchedOnOutlet = getOutlet(route) === outlet;
        const expanded$ = this.expandSegment(childInjector, segmentGroup, childConfig, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true);
        return expanded$.pipe((0, import_operators.map)((cs) => new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children)));
      }));
    }));
  }
  getChildConfig(injector, route, segments) {
    if (route.children) {
      return (0, import_rxjs.of)({ routes: route.children, injector });
    }
    if (route.loadChildren) {
      if (route._loadedRoutes !== void 0) {
        return (0, import_rxjs.of)({ routes: route._loadedRoutes, injector: route._loadedInjector });
      }
      return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe((0, import_operators.mergeMap)((shouldLoadResult) => {
        if (shouldLoadResult) {
          return this.configLoader.loadChildren(injector, route).pipe((0, import_operators.tap)((cfg) => {
            route._loadedRoutes = cfg.routes;
            route._loadedInjector = cfg.injector;
          }));
        }
        return canLoadFails(route);
      }));
    }
    return (0, import_rxjs.of)({ routes: [], injector });
  }
  lineralizeSegments(route, urlTree) {
    let res = [];
    let c = urlTree.root;
    while (true) {
      res = res.concat(c.segments);
      if (c.numberOfChildren === 0) {
        return (0, import_rxjs.of)(res);
      }
      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
        return namedOutletsRedirect(route.redirectTo);
      }
      c = c.children[PRIMARY_OUTLET];
    }
  }
  applyRedirectCommands(segments, redirectTo, posParams) {
    return this.applyRedirectCreateUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);
  }
  applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {
    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
    return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
  }
  createQueryParams(redirectToParams, actualParams) {
    const res = {};
    forEach(redirectToParams, (v, k) => {
      const copySourceValue = typeof v === "string" && v.startsWith(":");
      if (copySourceValue) {
        const sourceName = v.substring(1);
        res[k] = actualParams[sourceName];
      } else {
        res[k] = v;
      }
    });
    return res;
  }
  createSegmentGroup(redirectTo, group, segments, posParams) {
    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
    let children = {};
    forEach(group.children, (child, name) => {
      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);
    });
    return new UrlSegmentGroup(updatedSegments, children);
  }
  createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {
    return redirectToSegments.map((s) => s.path.startsWith(":") ? this.findPosParam(redirectTo, s, posParams) : this.findOrReturn(s, actualSegments));
  }
  findPosParam(redirectTo, redirectToUrlSegment, posParams) {
    const pos = posParams[redirectToUrlSegment.path.substring(1)];
    if (!pos)
      throw new import_core.\u0275RuntimeError(4001, NG_DEV_MODE$6 && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);
    return pos;
  }
  findOrReturn(redirectToUrlSegment, actualSegments) {
    let idx = 0;
    for (const s of actualSegments) {
      if (s.path === redirectToUrlSegment.path) {
        actualSegments.splice(idx);
        return s;
      }
      idx++;
    }
    return redirectToUrlSegment;
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function applyRedirects(environmentInjector, configLoader, urlSerializer, config) {
  return (0, import_operators.switchMap)((t) => applyRedirects$1(environmentInjector, configLoader, urlSerializer, t.extractedUrl, config).pipe((0, import_operators.map)((urlAfterRedirects) => __spreadProps(__spreadValues({}, t), { urlAfterRedirects }))));
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NG_DEV_MODE$5 = typeof ngDevMode === "undefined" || !!ngDevMode;
class NoMatch {
}
function newObservableError(e) {
  return new import_rxjs.Observable((obs) => obs.error(e));
}
function recognize$1(injector, rootComponentType, config, urlTree, url, urlSerializer, paramsInheritanceStrategy = "emptyOnly", relativeLinkResolution = "legacy") {
  return new Recognizer(injector, rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution, urlSerializer).recognize().pipe((0, import_operators.switchMap)((result) => {
    if (result === null) {
      return newObservableError(new NoMatch());
    } else {
      return (0, import_rxjs.of)(result);
    }
  }));
}
class Recognizer {
  constructor(injector, rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution, urlSerializer) {
    this.injector = injector;
    this.rootComponentType = rootComponentType;
    this.config = config;
    this.urlTree = urlTree;
    this.url = url;
    this.paramsInheritanceStrategy = paramsInheritanceStrategy;
    this.relativeLinkResolution = relativeLinkResolution;
    this.urlSerializer = urlSerializer;
  }
  recognize() {
    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config.filter((c) => c.redirectTo === void 0), this.relativeLinkResolution).segmentGroup;
    return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET).pipe((0, import_operators.map)((children) => {
      if (children === null) {
        return null;
      }
      const root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});
      const rootNode = new TreeNode(root, children);
      const routeState = new RouterStateSnapshot(this.url, rootNode);
      this.inheritParamsAndData(routeState._root);
      return routeState;
    }));
  }
  inheritParamsAndData(routeNode) {
    const route = routeNode.value;
    const i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);
    route.params = Object.freeze(i.params);
    route.data = Object.freeze(i.data);
    routeNode.children.forEach((n) => this.inheritParamsAndData(n));
  }
  processSegmentGroup(injector, config, segmentGroup, outlet) {
    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
      return this.processChildren(injector, config, segmentGroup);
    }
    return this.processSegment(injector, config, segmentGroup, segmentGroup.segments, outlet);
  }
  processChildren(injector, config, segmentGroup) {
    return (0, import_rxjs.from)(Object.keys(segmentGroup.children)).pipe((0, import_operators.concatMap)((childOutlet) => {
      const child = segmentGroup.children[childOutlet];
      const sortedConfig = sortByMatchingOutlets(config, childOutlet);
      return this.processSegmentGroup(injector, sortedConfig, child, childOutlet);
    }), (0, import_operators.scan)((children, outletChildren) => {
      if (!children || !outletChildren)
        return null;
      children.push(...outletChildren);
      return children;
    }), (0, import_operators.takeWhile)((children) => children !== null), (0, import_operators.defaultIfEmpty)(null), (0, import_operators.last)(), (0, import_operators.map)((children) => {
      if (children === null)
        return null;
      const mergedChildren = mergeEmptyPathMatches(children);
      if (NG_DEV_MODE$5) {
        checkOutletNameUniqueness(mergedChildren);
      }
      sortActivatedRouteSnapshots(mergedChildren);
      return mergedChildren;
    }));
  }
  processSegment(injector, routes, segmentGroup, segments, outlet) {
    return (0, import_rxjs.from)(routes).pipe((0, import_operators.concatMap)((r) => {
      var _a;
      return this.processSegmentAgainstRoute((_a = r._injector) != null ? _a : injector, r, segmentGroup, segments, outlet);
    }), (0, import_operators.first)((x) => !!x), (0, import_operators.catchError)((e) => {
      if (isEmptyError(e)) {
        if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
          return (0, import_rxjs.of)([]);
        }
        return (0, import_rxjs.of)(null);
      }
      throw e;
    }));
  }
  processSegmentAgainstRoute(injector, route, rawSegment, segments, outlet) {
    var _a, _b;
    if (route.redirectTo || !isImmediateMatch(route, rawSegment, segments, outlet))
      return (0, import_rxjs.of)(null);
    let matchResult;
    if (route.path === "**") {
      const params = segments.length > 0 ? last(segments).parameters : {};
      const pathIndexShift = getPathIndexShift(rawSegment) + segments.length;
      const snapshot = new ActivatedRouteSnapshot(
        segments,
        params,
        Object.freeze(__spreadValues({}, this.urlTree.queryParams)),
        this.urlTree.fragment,
        getData(route),
        getOutlet(route),
        (_b = (_a = route.component) != null ? _a : route._loadedComponent) != null ? _b : null,
        route,
        getSourceSegmentGroup(rawSegment),
        pathIndexShift,
        getResolve(route),
        NG_DEV_MODE$5 ? getCorrectedPathIndexShift(rawSegment) + segments.length : pathIndexShift
      );
      matchResult = (0, import_rxjs.of)({
        snapshot,
        consumedSegments: [],
        remainingSegments: []
      });
    } else {
      matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer).pipe((0, import_operators.map)(({ matched, consumedSegments, remainingSegments, parameters }) => {
        var _a2, _b2;
        if (!matched) {
          return null;
        }
        const pathIndexShift = getPathIndexShift(rawSegment) + consumedSegments.length;
        const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), getOutlet(route), (_b2 = (_a2 = route.component) != null ? _a2 : route._loadedComponent) != null ? _b2 : null, route, getSourceSegmentGroup(rawSegment), pathIndexShift, getResolve(route), NG_DEV_MODE$5 ? getCorrectedPathIndexShift(rawSegment) + consumedSegments.length : pathIndexShift);
        return { snapshot, consumedSegments, remainingSegments };
      }));
    }
    return matchResult.pipe((0, import_operators.switchMap)((result) => {
      var _a2, _b2;
      if (result === null) {
        return (0, import_rxjs.of)(null);
      }
      const { snapshot, consumedSegments, remainingSegments } = result;
      injector = (_a2 = route._injector) != null ? _a2 : injector;
      const childInjector = (_b2 = route._loadedInjector) != null ? _b2 : injector;
      const childConfig = getChildConfig(route);
      const { segmentGroup, slicedSegments } = split(
        rawSegment,
        consumedSegments,
        remainingSegments,
        childConfig.filter((c) => c.redirectTo === void 0),
        this.relativeLinkResolution
      );
      if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
        return this.processChildren(childInjector, childConfig, segmentGroup).pipe((0, import_operators.map)((children) => {
          if (children === null) {
            return null;
          }
          return [new TreeNode(snapshot, children)];
        }));
      }
      if (childConfig.length === 0 && slicedSegments.length === 0) {
        return (0, import_rxjs.of)([new TreeNode(snapshot, [])]);
      }
      const matchedOnOutlet = getOutlet(route) === outlet;
      return this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet).pipe((0, import_operators.map)((children) => {
        if (children === null) {
          return null;
        }
        return [new TreeNode(snapshot, children)];
      }));
    }));
  }
}
function sortActivatedRouteSnapshots(nodes) {
  nodes.sort((a, b) => {
    if (a.value.outlet === PRIMARY_OUTLET)
      return -1;
    if (b.value.outlet === PRIMARY_OUTLET)
      return 1;
    return a.value.outlet.localeCompare(b.value.outlet);
  });
}
function getChildConfig(route) {
  if (route.children) {
    return route.children;
  }
  if (route.loadChildren) {
    return route._loadedRoutes;
  }
  return [];
}
function hasEmptyPathConfig(node) {
  const config = node.value.routeConfig;
  return config && config.path === "" && config.redirectTo === void 0;
}
function mergeEmptyPathMatches(nodes) {
  const result = [];
  const mergedNodes = /* @__PURE__ */ new Set();
  for (const node of nodes) {
    if (!hasEmptyPathConfig(node)) {
      result.push(node);
      continue;
    }
    const duplicateEmptyPathNode = result.find((resultNode) => node.value.routeConfig === resultNode.value.routeConfig);
    if (duplicateEmptyPathNode !== void 0) {
      duplicateEmptyPathNode.children.push(...node.children);
      mergedNodes.add(duplicateEmptyPathNode);
    } else {
      result.push(node);
    }
  }
  for (const mergedNode of mergedNodes) {
    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);
    result.push(new TreeNode(mergedNode.value, mergedChildren));
  }
  return result.filter((n) => !mergedNodes.has(n));
}
function checkOutletNameUniqueness(nodes) {
  const names = {};
  nodes.forEach((n) => {
    const routeWithSameOutletName = names[n.value.outlet];
    if (routeWithSameOutletName) {
      const p = routeWithSameOutletName.url.map((s) => s.toString()).join("/");
      const c = n.value.url.map((s) => s.toString()).join("/");
      throw new import_core.\u0275RuntimeError(4006, NG_DEV_MODE$5 && `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);
    }
    names[n.value.outlet] = n.value;
  });
}
function getSourceSegmentGroup(segmentGroup) {
  let s = segmentGroup;
  while (s._sourceSegment) {
    s = s._sourceSegment;
  }
  return s;
}
function getPathIndexShift(segmentGroup) {
  var _a, _b;
  let s = segmentGroup;
  let res = (_a = s._segmentIndexShift) != null ? _a : 0;
  while (s._sourceSegment) {
    s = s._sourceSegment;
    res += (_b = s._segmentIndexShift) != null ? _b : 0;
  }
  return res - 1;
}
function getCorrectedPathIndexShift(segmentGroup) {
  var _a, _b, _c, _d;
  let s = segmentGroup;
  let res = (_b = (_a = s._segmentIndexShiftCorrected) != null ? _a : s._segmentIndexShift) != null ? _b : 0;
  while (s._sourceSegment) {
    s = s._sourceSegment;
    res += (_d = (_c = s._segmentIndexShiftCorrected) != null ? _c : s._segmentIndexShift) != null ? _d : 0;
  }
  return res - 1;
}
function getData(route) {
  return route.data || {};
}
function getResolve(route) {
  return route.resolve || {};
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function recognize(injector, rootComponentType, config, serializer, paramsInheritanceStrategy, relativeLinkResolution) {
  return (0, import_operators.mergeMap)((t) => recognize$1(injector, rootComponentType, config, t.urlAfterRedirects, serializer.serialize(t.urlAfterRedirects), serializer, paramsInheritanceStrategy, relativeLinkResolution).pipe((0, import_operators.map)((targetSnapshot) => __spreadProps(__spreadValues({}, t), { targetSnapshot }))));
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function resolveData(paramsInheritanceStrategy, injector) {
  return (0, import_operators.mergeMap)((t) => {
    const { targetSnapshot, guards: { canActivateChecks } } = t;
    if (!canActivateChecks.length) {
      return (0, import_rxjs.of)(t);
    }
    let canActivateChecksResolved = 0;
    return (0, import_rxjs.from)(canActivateChecks).pipe((0, import_operators.concatMap)((check) => runResolve(check.route, targetSnapshot, paramsInheritanceStrategy, injector)), (0, import_operators.tap)(() => canActivateChecksResolved++), (0, import_operators.takeLast)(1), (0, import_operators.mergeMap)((_) => canActivateChecksResolved === canActivateChecks.length ? (0, import_rxjs.of)(t) : import_rxjs.EMPTY));
  });
}
function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {
  const config = futureARS.routeConfig;
  const resolve = futureARS._resolve;
  if ((config == null ? void 0 : config.title) !== void 0 && !hasStaticTitle(config)) {
    resolve[RouteTitleKey] = config.title;
  }
  return resolveNode(resolve, futureARS, futureRSS, injector).pipe((0, import_operators.map)((resolvedData) => {
    futureARS._resolvedData = resolvedData;
    futureARS.data = inheritedParamsDataResolve(futureARS, paramsInheritanceStrategy).resolve;
    if (config && hasStaticTitle(config)) {
      futureARS.data[RouteTitleKey] = config.title;
    }
    return null;
  }));
}
function resolveNode(resolve, futureARS, futureRSS, injector) {
  const keys = getDataKeys(resolve);
  if (keys.length === 0) {
    return (0, import_rxjs.of)({});
  }
  const data = {};
  return (0, import_rxjs.from)(keys).pipe((0, import_operators.mergeMap)((key) => getResolver(resolve[key], futureARS, futureRSS, injector).pipe((0, import_operators.first)(), (0, import_operators.tap)((value) => {
    data[key] = value;
  }))), (0, import_operators.takeLast)(1), (0, import_operators.mapTo)(data), (0, import_operators.catchError)((e) => isEmptyError(e) ? import_rxjs.EMPTY : (0, import_rxjs.throwError)(e)));
}
function getDataKeys(obj) {
  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];
}
function getResolver(injectionToken, futureARS, futureRSS, injector) {
  var _a;
  const closestInjector = (_a = getClosestRouteInjector(futureARS)) != null ? _a : injector;
  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);
  const resolverValue = resolver.resolve ? resolver.resolve(futureARS, futureRSS) : closestInjector.runInContext(() => resolver(futureARS, futureRSS));
  return wrapIntoObservable(resolverValue);
}
function hasStaticTitle(config) {
  return typeof config.title === "string" || config.title === null;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function switchTap(next) {
  return (0, import_operators.switchMap)((v) => {
    const nextResult = next(v);
    if (nextResult) {
      return (0, import_rxjs.from)(nextResult).pipe((0, import_operators.map)(() => v));
    }
    return (0, import_rxjs.of)(v);
  });
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class TitleStrategy {
  buildTitle(snapshot) {
    var _a;
    let pageTitle;
    let route = snapshot.root;
    while (route !== void 0) {
      pageTitle = (_a = this.getResolvedTitleForRoute(route)) != null ? _a : pageTitle;
      route = route.children.find((child) => child.outlet === PRIMARY_OUTLET);
    }
    return pageTitle;
  }
  getResolvedTitleForRoute(snapshot) {
    return snapshot.data[RouteTitleKey];
  }
}
TitleStrategy.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TitleStrategy, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable });
TitleStrategy.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TitleStrategy, providedIn: "root", useFactory: () => (0, import_core.inject)(DefaultTitleStrategy) });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TitleStrategy, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root", useFactory: () => (0, import_core.inject)(DefaultTitleStrategy) }]
}] });
class DefaultTitleStrategy extends TitleStrategy {
  constructor(title) {
    super();
    this.title = title;
  }
  updateTitle(snapshot) {
    const title = this.buildTitle(snapshot);
    if (title !== void 0) {
      this.title.setTitle(title);
    }
  }
}
DefaultTitleStrategy.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DefaultTitleStrategy, deps: [{ token: i1.Title }], target: i0.\u0275\u0275FactoryTarget.Injectable });
DefaultTitleStrategy.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DefaultTitleStrategy, providedIn: "root" });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: DefaultTitleStrategy, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root" }]
}], ctorParameters: function() {
  return [{ type: i1.Title }];
} });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function assignRelativeLinkResolution(router) {
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class RouteReuseStrategy {
}
class BaseRouteReuseStrategy {
  shouldDetach(route) {
    return false;
  }
  store(route, detachedTree) {
  }
  shouldAttach(route) {
    return false;
  }
  retrieve(route) {
    return null;
  }
  shouldReuseRoute(future, curr) {
    return future.routeConfig === curr.routeConfig;
  }
}
class DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NG_DEV_MODE$4 = typeof ngDevMode === "undefined" || !!ngDevMode;
const ROUTER_CONFIGURATION = new import_core.InjectionToken(NG_DEV_MODE$4 ? "router config" : "", {
  providedIn: "root",
  factory: () => ({})
});
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NG_DEV_MODE$3 = typeof ngDevMode === "undefined" || !!ngDevMode;
const ROUTES = new import_core.InjectionToken("ROUTES");
class RouterConfigLoader {
  constructor(injector, compiler) {
    this.injector = injector;
    this.compiler = compiler;
    this.componentLoaders = /* @__PURE__ */ new WeakMap();
    this.childrenLoaders = /* @__PURE__ */ new WeakMap();
  }
  loadComponent(route) {
    if (this.componentLoaders.get(route)) {
      return this.componentLoaders.get(route);
    } else if (route._loadedComponent) {
      return (0, import_rxjs.of)(route._loadedComponent);
    }
    if (this.onLoadStartListener) {
      this.onLoadStartListener(route);
    }
    const loadRunner = wrapIntoObservable(route.loadComponent()).pipe((0, import_operators.tap)((component) => {
      var _a;
      if (this.onLoadEndListener) {
        this.onLoadEndListener(route);
      }
      NG_DEV_MODE$3 && assertStandalone((_a = route.path) != null ? _a : "", component);
      route._loadedComponent = component;
    }), (0, import_operators.finalize)(() => {
      this.componentLoaders.delete(route);
    }));
    const loader = new import_rxjs.ConnectableObservable(loadRunner, () => new import_rxjs.Subject()).pipe((0, import_operators.refCount)());
    this.componentLoaders.set(route, loader);
    return loader;
  }
  loadChildren(parentInjector, route) {
    if (this.childrenLoaders.get(route)) {
      return this.childrenLoaders.get(route);
    } else if (route._loadedRoutes) {
      return (0, import_rxjs.of)({ routes: route._loadedRoutes, injector: route._loadedInjector });
    }
    if (this.onLoadStartListener) {
      this.onLoadStartListener(route);
    }
    const moduleFactoryOrRoutes$ = this.loadModuleFactoryOrRoutes(route.loadChildren);
    const loadRunner = moduleFactoryOrRoutes$.pipe((0, import_operators.map)((factoryOrRoutes) => {
      if (this.onLoadEndListener) {
        this.onLoadEndListener(route);
      }
      let injector;
      let rawRoutes;
      let requireStandaloneComponents = false;
      if (Array.isArray(factoryOrRoutes)) {
        rawRoutes = factoryOrRoutes;
        requireStandaloneComponents = true;
      } else {
        injector = factoryOrRoutes.create(parentInjector).injector;
        rawRoutes = flatten(injector.get(ROUTES, [], import_core.InjectFlags.Self | import_core.InjectFlags.Optional));
      }
      const routes = rawRoutes.map(standardizeConfig);
      NG_DEV_MODE$3 && validateConfig(routes, route.path, requireStandaloneComponents);
      return { routes, injector };
    }), (0, import_operators.finalize)(() => {
      this.childrenLoaders.delete(route);
    }));
    const loader = new import_rxjs.ConnectableObservable(loadRunner, () => new import_rxjs.Subject()).pipe((0, import_operators.refCount)());
    this.childrenLoaders.set(route, loader);
    return loader;
  }
  loadModuleFactoryOrRoutes(loadChildren) {
    return wrapIntoObservable(loadChildren()).pipe((0, import_operators.mergeMap)((t) => {
      if (t instanceof import_core.NgModuleFactory || Array.isArray(t)) {
        return (0, import_rxjs.of)(t);
      } else {
        return (0, import_rxjs.from)(this.compiler.compileModuleAsync(t));
      }
    }));
  }
}
RouterConfigLoader.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterConfigLoader, deps: [{ token: i0.Injector }, { token: i0.Compiler }], target: i0.\u0275\u0275FactoryTarget.Injectable });
RouterConfigLoader.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterConfigLoader, providedIn: "root" });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterConfigLoader, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root" }]
}], ctorParameters: function() {
  return [{ type: i0.Injector }, { type: i0.Compiler }];
} });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class UrlHandlingStrategy {
}
class DefaultUrlHandlingStrategy {
  shouldProcessUrl(url) {
    return true;
  }
  extract(url) {
    return url;
  }
  merge(newUrlPart, wholeUrl) {
    return newUrlPart;
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NG_DEV_MODE$2 = typeof ngDevMode === "undefined" || !!ngDevMode;
function defaultErrorHandler(error) {
  throw error;
}
function defaultMalformedUriErrorHandler(error, urlSerializer, url) {
  return urlSerializer.parse("/");
}
const exactMatchOptions = {
  paths: "exact",
  fragment: "ignored",
  matrixParams: "ignored",
  queryParams: "exact"
};
const subsetMatchOptions = {
  paths: "subset",
  fragment: "ignored",
  matrixParams: "ignored",
  queryParams: "subset"
};
function assignExtraOptionsToRouter(opts, router) {
  if (opts.errorHandler) {
    router.errorHandler = opts.errorHandler;
  }
  if (opts.malformedUriErrorHandler) {
    router.malformedUriErrorHandler = opts.malformedUriErrorHandler;
  }
  if (opts.onSameUrlNavigation) {
    router.onSameUrlNavigation = opts.onSameUrlNavigation;
  }
  if (opts.paramsInheritanceStrategy) {
    router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;
  }
  if (opts.relativeLinkResolution) {
    router.relativeLinkResolution = opts.relativeLinkResolution;
  }
  if (opts.urlUpdateStrategy) {
    router.urlUpdateStrategy = opts.urlUpdateStrategy;
  }
  if (opts.canceledNavigationResolution) {
    router.canceledNavigationResolution = opts.canceledNavigationResolution;
  }
}
function setupRouter() {
  var _a, _b;
  const urlSerializer = (0, import_core.inject)(UrlSerializer);
  const contexts = (0, import_core.inject)(ChildrenOutletContexts);
  const location = (0, import_core.inject)(import_common.Location);
  const injector = (0, import_core.inject)(import_core.Injector);
  const compiler = (0, import_core.inject)(import_core.Compiler);
  const config = (_a = (0, import_core.inject)(ROUTES, { optional: true })) != null ? _a : [];
  const opts = (_b = (0, import_core.inject)(ROUTER_CONFIGURATION, { optional: true })) != null ? _b : {};
  const defaultTitleStrategy = (0, import_core.inject)(DefaultTitleStrategy);
  const titleStrategy = (0, import_core.inject)(TitleStrategy, { optional: true });
  const urlHandlingStrategy = (0, import_core.inject)(UrlHandlingStrategy, { optional: true });
  const routeReuseStrategy = (0, import_core.inject)(RouteReuseStrategy, { optional: true });
  const router = new Router(null, urlSerializer, contexts, location, injector, compiler, flatten(config));
  if (urlHandlingStrategy) {
    router.urlHandlingStrategy = urlHandlingStrategy;
  }
  if (routeReuseStrategy) {
    router.routeReuseStrategy = routeReuseStrategy;
  }
  router.titleStrategy = titleStrategy != null ? titleStrategy : defaultTitleStrategy;
  assignExtraOptionsToRouter(opts, router);
  assignRelativeLinkResolution(router);
  return router;
}
class Router {
  constructor(rootComponentType, urlSerializer, rootContexts, location, injector, compiler, config) {
    this.rootComponentType = rootComponentType;
    this.urlSerializer = urlSerializer;
    this.rootContexts = rootContexts;
    this.location = location;
    this.config = config;
    this.lastSuccessfulNavigation = null;
    this.currentNavigation = null;
    this.disposed = false;
    this.navigationId = 0;
    this.currentPageId = 0;
    this.isNgZoneEnabled = false;
    this.events = new import_rxjs.Subject();
    this.errorHandler = defaultErrorHandler;
    this.malformedUriErrorHandler = defaultMalformedUriErrorHandler;
    this.navigated = false;
    this.lastSuccessfulId = -1;
    this.afterPreactivation = () => (0, import_rxjs.of)(void 0);
    this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();
    this.routeReuseStrategy = new DefaultRouteReuseStrategy();
    this.onSameUrlNavigation = "ignore";
    this.paramsInheritanceStrategy = "emptyOnly";
    this.urlUpdateStrategy = "deferred";
    this.relativeLinkResolution = "corrected";
    this.canceledNavigationResolution = "replace";
    const onLoadStart = (r) => this.triggerEvent(new RouteConfigLoadStart(r));
    const onLoadEnd = (r) => this.triggerEvent(new RouteConfigLoadEnd(r));
    this.configLoader = injector.get(RouterConfigLoader);
    this.configLoader.onLoadEndListener = onLoadEnd;
    this.configLoader.onLoadStartListener = onLoadStart;
    this.ngModule = injector.get(import_core.NgModuleRef);
    this.console = injector.get(import_core.\u0275Console);
    const ngZone = injector.get(import_core.NgZone);
    this.isNgZoneEnabled = ngZone instanceof import_core.NgZone && import_core.NgZone.isInAngularZone();
    this.resetConfig(config);
    this.currentUrlTree = createEmptyUrlTree();
    this.rawUrlTree = this.currentUrlTree;
    this.browserUrlTree = this.currentUrlTree;
    this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);
    this.transitions = new import_rxjs.BehaviorSubject({
      id: 0,
      targetPageId: 0,
      currentUrlTree: this.currentUrlTree,
      currentRawUrl: this.currentUrlTree,
      extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),
      urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree),
      rawUrl: this.currentUrlTree,
      extras: {},
      resolve: null,
      reject: null,
      promise: Promise.resolve(true),
      source: "imperative",
      restoredState: null,
      currentSnapshot: this.routerState.snapshot,
      targetSnapshot: null,
      currentRouterState: this.routerState,
      targetRouterState: null,
      guards: { canActivateChecks: [], canDeactivateChecks: [] },
      guardsResult: null
    });
    this.navigations = this.setupNavigations(this.transitions);
    this.processNavigations();
  }
  get browserPageId() {
    var _a;
    return (_a = this.location.getState()) == null ? void 0 : _a.\u0275routerPageId;
  }
  setupNavigations(transitions) {
    const eventsSubject = this.events;
    return transitions.pipe(
      (0, import_operators.filter)((t) => t.id !== 0),
      (0, import_operators.map)((t) => __spreadProps(__spreadValues({}, t), { extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl) })),
      (0, import_operators.switchMap)((overallTransitionState) => {
        let completed = false;
        let errored = false;
        return (0, import_rxjs.of)(overallTransitionState).pipe(
          (0, import_operators.tap)((t) => {
            this.currentNavigation = {
              id: t.id,
              initialUrl: t.rawUrl,
              extractedUrl: t.extractedUrl,
              trigger: t.source,
              extras: t.extras,
              previousNavigation: this.lastSuccessfulNavigation ? __spreadProps(__spreadValues({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null
            };
          }),
          (0, import_operators.switchMap)((t) => {
            const browserUrlTree = this.browserUrlTree.toString();
            const urlTransition = !this.navigated || t.extractedUrl.toString() !== browserUrlTree || browserUrlTree !== this.currentUrlTree.toString();
            const processCurrentUrl = (this.onSameUrlNavigation === "reload" ? true : urlTransition) && this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl);
            if (processCurrentUrl) {
              if (isBrowserTriggeredNavigation(t.source)) {
                this.browserUrlTree = t.extractedUrl;
              }
              return (0, import_rxjs.of)(t).pipe(
                (0, import_operators.switchMap)((t2) => {
                  const transition = this.transitions.getValue();
                  eventsSubject.next(new NavigationStart(t2.id, this.serializeUrl(t2.extractedUrl), t2.source, t2.restoredState));
                  if (transition !== this.transitions.getValue()) {
                    return import_rxjs.EMPTY;
                  }
                  return Promise.resolve(t2);
                }),
                applyRedirects(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config),
                (0, import_operators.tap)((t2) => {
                  this.currentNavigation = __spreadProps(__spreadValues({}, this.currentNavigation), {
                    finalUrl: t2.urlAfterRedirects
                  });
                  overallTransitionState.urlAfterRedirects = t2.urlAfterRedirects;
                }),
                recognize(this.ngModule.injector, this.rootComponentType, this.config, this.urlSerializer, this.paramsInheritanceStrategy, this.relativeLinkResolution),
                (0, import_operators.tap)((t2) => {
                  overallTransitionState.targetSnapshot = t2.targetSnapshot;
                  if (this.urlUpdateStrategy === "eager") {
                    if (!t2.extras.skipLocationChange) {
                      const rawUrl = this.urlHandlingStrategy.merge(t2.urlAfterRedirects, t2.rawUrl);
                      this.setBrowserUrl(rawUrl, t2);
                    }
                    this.browserUrlTree = t2.urlAfterRedirects;
                  }
                  const routesRecognized = new RoutesRecognized(t2.id, this.serializeUrl(t2.extractedUrl), this.serializeUrl(t2.urlAfterRedirects), t2.targetSnapshot);
                  eventsSubject.next(routesRecognized);
                })
              );
            } else {
              const processPreviousUrl = urlTransition && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree);
              if (processPreviousUrl) {
                const { id, extractedUrl, source, restoredState, extras } = t;
                const navStart = new NavigationStart(id, this.serializeUrl(extractedUrl), source, restoredState);
                eventsSubject.next(navStart);
                const targetSnapshot = createEmptyState(extractedUrl, this.rootComponentType).snapshot;
                overallTransitionState = __spreadProps(__spreadValues({}, t), {
                  targetSnapshot,
                  urlAfterRedirects: extractedUrl,
                  extras: __spreadProps(__spreadValues({}, extras), { skipLocationChange: false, replaceUrl: false })
                });
                return (0, import_rxjs.of)(overallTransitionState);
              } else {
                this.rawUrlTree = t.rawUrl;
                t.resolve(null);
                return import_rxjs.EMPTY;
              }
            }
          }),
          (0, import_operators.tap)((t) => {
            const guardsStart = new GuardsCheckStart(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
            this.triggerEvent(guardsStart);
          }),
          (0, import_operators.map)((t) => {
            overallTransitionState = __spreadProps(__spreadValues({}, t), {
              guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, this.rootContexts)
            });
            return overallTransitionState;
          }),
          checkGuards(this.ngModule.injector, (evt) => this.triggerEvent(evt)),
          (0, import_operators.tap)((t) => {
            overallTransitionState.guardsResult = t.guardsResult;
            if (isUrlTree(t.guardsResult)) {
              throw redirectingNavigationError(this.urlSerializer, t.guardsResult);
            }
            const guardsEnd = new GuardsCheckEnd(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);
            this.triggerEvent(guardsEnd);
          }),
          (0, import_operators.filter)((t) => {
            if (!t.guardsResult) {
              this.restoreHistory(t);
              this.cancelNavigationTransition(t, "", 3);
              return false;
            }
            return true;
          }),
          switchTap((t) => {
            if (t.guards.canActivateChecks.length) {
              return (0, import_rxjs.of)(t).pipe((0, import_operators.tap)((t2) => {
                const resolveStart = new ResolveStart(t2.id, this.serializeUrl(t2.extractedUrl), this.serializeUrl(t2.urlAfterRedirects), t2.targetSnapshot);
                this.triggerEvent(resolveStart);
              }), (0, import_operators.switchMap)((t2) => {
                let dataResolved = false;
                return (0, import_rxjs.of)(t2).pipe(resolveData(this.paramsInheritanceStrategy, this.ngModule.injector), (0, import_operators.tap)({
                  next: () => dataResolved = true,
                  complete: () => {
                    if (!dataResolved) {
                      this.restoreHistory(t2);
                      this.cancelNavigationTransition(t2, NG_DEV_MODE$2 ? `At least one route resolver didn't emit any value.` : "", 2);
                    }
                  }
                }));
              }), (0, import_operators.tap)((t2) => {
                const resolveEnd = new ResolveEnd(t2.id, this.serializeUrl(t2.extractedUrl), this.serializeUrl(t2.urlAfterRedirects), t2.targetSnapshot);
                this.triggerEvent(resolveEnd);
              }));
            }
            return void 0;
          }),
          switchTap((t) => {
            const loadComponents = (route) => {
              var _a;
              const loaders = [];
              if (((_a = route.routeConfig) == null ? void 0 : _a.loadComponent) && !route.routeConfig._loadedComponent) {
                loaders.push(this.configLoader.loadComponent(route.routeConfig).pipe((0, import_operators.tap)((loadedComponent) => {
                  route.component = loadedComponent;
                }), (0, import_operators.map)(() => void 0)));
              }
              for (const child of route.children) {
                loaders.push(...loadComponents(child));
              }
              return loaders;
            };
            return (0, import_rxjs.combineLatest)(loadComponents(t.targetSnapshot.root)).pipe((0, import_operators.defaultIfEmpty)(), (0, import_operators.take)(1));
          }),
          switchTap(() => this.afterPreactivation()),
          (0, import_operators.map)((t) => {
            const targetRouterState = createRouterState(this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);
            overallTransitionState = __spreadProps(__spreadValues({}, t), { targetRouterState });
            return overallTransitionState;
          }),
          (0, import_operators.tap)((t) => {
            this.currentUrlTree = t.urlAfterRedirects;
            this.rawUrlTree = this.urlHandlingStrategy.merge(t.urlAfterRedirects, t.rawUrl);
            this.routerState = t.targetRouterState;
            if (this.urlUpdateStrategy === "deferred") {
              if (!t.extras.skipLocationChange) {
                this.setBrowserUrl(this.rawUrlTree, t);
              }
              this.browserUrlTree = t.urlAfterRedirects;
            }
          }),
          activateRoutes(this.rootContexts, this.routeReuseStrategy, (evt) => this.triggerEvent(evt)),
          (0, import_operators.tap)({
            next() {
              completed = true;
            },
            complete() {
              completed = true;
            }
          }),
          (0, import_operators.finalize)(() => {
            var _a;
            if (!completed && !errored) {
              const cancelationReason = NG_DEV_MODE$2 ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : "";
              this.cancelNavigationTransition(overallTransitionState, cancelationReason, 1);
            }
            if (((_a = this.currentNavigation) == null ? void 0 : _a.id) === overallTransitionState.id) {
              this.currentNavigation = null;
            }
          }),
          (0, import_operators.catchError)((e) => {
            var _a;
            errored = true;
            if (isNavigationCancelingError$1(e)) {
              if (!isRedirectingNavigationCancelingError$1(e)) {
                this.navigated = true;
                this.restoreHistory(overallTransitionState, true);
              }
              const navCancel = new NavigationCancel(overallTransitionState.id, this.serializeUrl(overallTransitionState.extractedUrl), e.message, e.cancellationCode);
              eventsSubject.next(navCancel);
              if (!isRedirectingNavigationCancelingError$1(e)) {
                overallTransitionState.resolve(false);
              } else {
                const mergedTree = this.urlHandlingStrategy.merge(e.url, this.rawUrlTree);
                const extras = {
                  skipLocationChange: overallTransitionState.extras.skipLocationChange,
                  replaceUrl: this.urlUpdateStrategy === "eager" || isBrowserTriggeredNavigation(overallTransitionState.source)
                };
                this.scheduleNavigation(mergedTree, "imperative", null, extras, {
                  resolve: overallTransitionState.resolve,
                  reject: overallTransitionState.reject,
                  promise: overallTransitionState.promise
                });
              }
            } else {
              this.restoreHistory(overallTransitionState, true);
              const navError = new NavigationError(overallTransitionState.id, this.serializeUrl(overallTransitionState.extractedUrl), e, (_a = overallTransitionState.targetSnapshot) != null ? _a : void 0);
              eventsSubject.next(navError);
              try {
                overallTransitionState.resolve(this.errorHandler(e));
              } catch (ee) {
                overallTransitionState.reject(ee);
              }
            }
            return import_rxjs.EMPTY;
          })
        );
      })
    );
  }
  resetRootComponentType(rootComponentType) {
    this.rootComponentType = rootComponentType;
    this.routerState.root.component = this.rootComponentType;
  }
  setTransition(t) {
    this.transitions.next(__spreadValues(__spreadValues({}, this.transitions.value), t));
  }
  initialNavigation() {
    this.setUpLocationChangeListener();
    if (this.navigationId === 0) {
      this.navigateByUrl(this.location.path(true), { replaceUrl: true });
    }
  }
  setUpLocationChangeListener() {
    if (!this.locationSubscription) {
      this.locationSubscription = this.location.subscribe((event) => {
        const source = event["type"] === "popstate" ? "popstate" : "hashchange";
        if (source === "popstate") {
          setTimeout(() => {
            var _a;
            const extras = { replaceUrl: true };
            const state = ((_a = event.state) == null ? void 0 : _a.navigationId) ? event.state : null;
            if (state) {
              const stateCopy = __spreadValues({}, state);
              delete stateCopy.navigationId;
              delete stateCopy.\u0275routerPageId;
              if (Object.keys(stateCopy).length !== 0) {
                extras.state = stateCopy;
              }
            }
            const urlTree = this.parseUrl(event["url"]);
            this.scheduleNavigation(urlTree, source, state, extras);
          }, 0);
        }
      });
    }
  }
  get url() {
    return this.serializeUrl(this.currentUrlTree);
  }
  getCurrentNavigation() {
    return this.currentNavigation;
  }
  triggerEvent(event) {
    this.events.next(event);
  }
  resetConfig(config) {
    NG_DEV_MODE$2 && validateConfig(config);
    this.config = config.map(standardizeConfig);
    this.navigated = false;
    this.lastSuccessfulId = -1;
  }
  ngOnDestroy() {
    this.dispose();
  }
  dispose() {
    this.transitions.complete();
    if (this.locationSubscription) {
      this.locationSubscription.unsubscribe();
      this.locationSubscription = void 0;
    }
    this.disposed = true;
  }
  createUrlTree(commands, navigationExtras = {}) {
    const { relativeTo, queryParams, fragment, queryParamsHandling, preserveFragment } = navigationExtras;
    const a = relativeTo || this.routerState.root;
    const f = preserveFragment ? this.currentUrlTree.fragment : fragment;
    let q = null;
    switch (queryParamsHandling) {
      case "merge":
        q = __spreadValues(__spreadValues({}, this.currentUrlTree.queryParams), queryParams);
        break;
      case "preserve":
        q = this.currentUrlTree.queryParams;
        break;
      default:
        q = queryParams || null;
    }
    if (q !== null) {
      q = this.removeEmptyProps(q);
    }
    return createUrlTree(a, this.currentUrlTree, commands, q, f != null ? f : null);
  }
  navigateByUrl(url, extras = {
    skipLocationChange: false
  }) {
    if (typeof ngDevMode === "undefined" || ngDevMode && this.isNgZoneEnabled && !import_core.NgZone.isInAngularZone()) {
      this.console.warn(`Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?`);
    }
    const urlTree = isUrlTree(url) ? url : this.parseUrl(url);
    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
    return this.scheduleNavigation(mergedTree, "imperative", null, extras);
  }
  navigate(commands, extras = { skipLocationChange: false }) {
    validateCommands(commands);
    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
  }
  serializeUrl(url) {
    return this.urlSerializer.serialize(url);
  }
  parseUrl(url) {
    let urlTree;
    try {
      urlTree = this.urlSerializer.parse(url);
    } catch (e) {
      urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);
    }
    return urlTree;
  }
  isActive(url, matchOptions) {
    let options;
    if (matchOptions === true) {
      options = __spreadValues({}, exactMatchOptions);
    } else if (matchOptions === false) {
      options = __spreadValues({}, subsetMatchOptions);
    } else {
      options = matchOptions;
    }
    if (isUrlTree(url)) {
      return containsTree(this.currentUrlTree, url, options);
    }
    const urlTree = this.parseUrl(url);
    return containsTree(this.currentUrlTree, urlTree, options);
  }
  removeEmptyProps(params) {
    return Object.keys(params).reduce((result, key) => {
      const value = params[key];
      if (value !== null && value !== void 0) {
        result[key] = value;
      }
      return result;
    }, {});
  }
  processNavigations() {
    this.navigations.subscribe((t) => {
      var _a;
      this.navigated = true;
      this.lastSuccessfulId = t.id;
      this.currentPageId = t.targetPageId;
      this.events.next(new NavigationEnd(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree)));
      this.lastSuccessfulNavigation = this.currentNavigation;
      (_a = this.titleStrategy) == null ? void 0 : _a.updateTitle(this.routerState.snapshot);
      t.resolve(true);
    }, (e) => {
      this.console.warn(`Unhandled Navigation Error: ${e}`);
    });
  }
  scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {
    var _a, _b;
    if (this.disposed) {
      return Promise.resolve(false);
    }
    let resolve;
    let reject;
    let promise;
    if (priorPromise) {
      resolve = priorPromise.resolve;
      reject = priorPromise.reject;
      promise = priorPromise.promise;
    } else {
      promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
    }
    const id = ++this.navigationId;
    let targetPageId;
    if (this.canceledNavigationResolution === "computed") {
      const isInitialPage = this.currentPageId === 0;
      if (isInitialPage) {
        restoredState = this.location.getState();
      }
      if (restoredState && restoredState.\u0275routerPageId) {
        targetPageId = restoredState.\u0275routerPageId;
      } else {
        if (extras.replaceUrl || extras.skipLocationChange) {
          targetPageId = (_a = this.browserPageId) != null ? _a : 0;
        } else {
          targetPageId = ((_b = this.browserPageId) != null ? _b : 0) + 1;
        }
      }
    } else {
      targetPageId = 0;
    }
    this.setTransition({
      id,
      targetPageId,
      source,
      restoredState,
      currentUrlTree: this.currentUrlTree,
      currentRawUrl: this.rawUrlTree,
      rawUrl,
      extras,
      resolve,
      reject,
      promise,
      currentSnapshot: this.routerState.snapshot,
      currentRouterState: this.routerState
    });
    return promise.catch((e) => {
      return Promise.reject(e);
    });
  }
  setBrowserUrl(url, t) {
    const path = this.urlSerializer.serialize(url);
    const state = __spreadValues(__spreadValues({}, t.extras.state), this.generateNgRouterState(t.id, t.targetPageId));
    if (this.location.isCurrentPathEqualTo(path) || !!t.extras.replaceUrl) {
      this.location.replaceState(path, "", state);
    } else {
      this.location.go(path, "", state);
    }
  }
  restoreHistory(t, restoringFromCaughtError = false) {
    var _a, _b;
    if (this.canceledNavigationResolution === "computed") {
      const targetPagePosition = this.currentPageId - t.targetPageId;
      const browserUrlUpdateOccurred = t.source === "popstate" || this.urlUpdateStrategy === "eager" || this.currentUrlTree === ((_a = this.currentNavigation) == null ? void 0 : _a.finalUrl);
      if (browserUrlUpdateOccurred && targetPagePosition !== 0) {
        this.location.historyGo(targetPagePosition);
      } else if (this.currentUrlTree === ((_b = this.currentNavigation) == null ? void 0 : _b.finalUrl) && targetPagePosition === 0) {
        this.resetState(t);
        this.browserUrlTree = t.currentUrlTree;
        this.resetUrlToCurrentUrlTree();
      } else {
      }
    } else if (this.canceledNavigationResolution === "replace") {
      if (restoringFromCaughtError) {
        this.resetState(t);
      }
      this.resetUrlToCurrentUrlTree();
    }
  }
  resetState(t) {
    this.routerState = t.currentRouterState;
    this.currentUrlTree = t.currentUrlTree;
    this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl);
  }
  resetUrlToCurrentUrlTree() {
    this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));
  }
  cancelNavigationTransition(t, reason, code) {
    const navCancel = new NavigationCancel(t.id, this.serializeUrl(t.extractedUrl), reason, code);
    this.triggerEvent(navCancel);
    t.resolve(false);
  }
  generateNgRouterState(navigationId, routerPageId) {
    if (this.canceledNavigationResolution === "computed") {
      return { navigationId, \u0275routerPageId: routerPageId };
    }
    return { navigationId };
  }
}
Router.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Router, deps: "invalid", target: i0.\u0275\u0275FactoryTarget.Injectable });
Router.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Router, providedIn: "root", useFactory: setupRouter });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: Router, decorators: [{
  type: import_core.Injectable,
  args: [{
    providedIn: "root",
    useFactory: setupRouter
  }]
}], ctorParameters: function() {
  return [{ type: i0.Type }, { type: UrlSerializer }, { type: ChildrenOutletContexts }, { type: i3.Location }, { type: i0.Injector }, { type: i0.Compiler }, { type: void 0 }];
} });
function validateCommands(commands) {
  for (let i = 0; i < commands.length; i++) {
    const cmd = commands[i];
    if (cmd == null) {
      throw new import_core.\u0275RuntimeError(4008, NG_DEV_MODE$2 && `The requested path contains ${cmd} segment at index ${i}`);
    }
  }
}
function isBrowserTriggeredNavigation(source) {
  return source !== "imperative";
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class RouterLink {
  constructor(router, route, tabIndexAttribute, renderer, el) {
    this.router = router;
    this.route = route;
    this.tabIndexAttribute = tabIndexAttribute;
    this.renderer = renderer;
    this.el = el;
    this._preserveFragment = false;
    this._skipLocationChange = false;
    this._replaceUrl = false;
    this.commands = null;
    this.onChanges = new import_rxjs.Subject();
    this.setTabIndexIfNotOnNativeEl("0");
  }
  set preserveFragment(preserveFragment) {
    this._preserveFragment = (0, import_core.\u0275coerceToBoolean)(preserveFragment);
  }
  get preserveFragment() {
    return this._preserveFragment;
  }
  set skipLocationChange(skipLocationChange) {
    this._skipLocationChange = (0, import_core.\u0275coerceToBoolean)(skipLocationChange);
  }
  get skipLocationChange() {
    return this._skipLocationChange;
  }
  set replaceUrl(replaceUrl) {
    this._replaceUrl = (0, import_core.\u0275coerceToBoolean)(replaceUrl);
  }
  get replaceUrl() {
    return this._replaceUrl;
  }
  setTabIndexIfNotOnNativeEl(newTabIndex) {
    if (this.tabIndexAttribute != null) {
      return;
    }
    const renderer = this.renderer;
    const nativeElement = this.el.nativeElement;
    if (newTabIndex !== null) {
      renderer.setAttribute(nativeElement, "tabindex", newTabIndex);
    } else {
      renderer.removeAttribute(nativeElement, "tabindex");
    }
  }
  ngOnChanges(changes) {
    this.onChanges.next(this);
  }
  set routerLink(commands) {
    if (commands != null) {
      this.commands = Array.isArray(commands) ? commands : [commands];
      this.setTabIndexIfNotOnNativeEl("0");
    } else {
      this.commands = null;
      this.setTabIndexIfNotOnNativeEl(null);
    }
  }
  onClick() {
    if (this.urlTree === null) {
      return true;
    }
    const extras = {
      skipLocationChange: this.skipLocationChange,
      replaceUrl: this.replaceUrl,
      state: this.state
    };
    this.router.navigateByUrl(this.urlTree, extras);
    return true;
  }
  get urlTree() {
    if (this.commands === null) {
      return null;
    }
    return this.router.createUrlTree(this.commands, {
      relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route,
      queryParams: this.queryParams,
      fragment: this.fragment,
      queryParamsHandling: this.queryParamsHandling,
      preserveFragment: this.preserveFragment
    });
  }
}
RouterLink.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterLink, deps: [{ token: Router }, { token: ActivatedRoute }, { token: "tabindex", attribute: true }, { token: i0.Renderer2 }, { token: i0.ElementRef }], target: i0.\u0275\u0275FactoryTarget.Directive });
RouterLink.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "14.3.0", type: RouterLink, isStandalone: true, selector: ":not(a):not(area)[routerLink]", inputs: { queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", state: "state", relativeTo: "relativeTo", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", routerLink: "routerLink" }, host: { listeners: { "click": "onClick()" } }, usesOnChanges: true, ngImport: i0 });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterLink, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: ":not(a):not(area)[routerLink]",
    standalone: true
  }]
}], ctorParameters: function() {
  return [{ type: Router }, { type: ActivatedRoute }, { type: void 0, decorators: [{
    type: import_core.Attribute,
    args: ["tabindex"]
  }] }, { type: i0.Renderer2 }, { type: i0.ElementRef }];
}, propDecorators: { queryParams: [{
  type: import_core.Input
}], fragment: [{
  type: import_core.Input
}], queryParamsHandling: [{
  type: import_core.Input
}], state: [{
  type: import_core.Input
}], relativeTo: [{
  type: import_core.Input
}], preserveFragment: [{
  type: import_core.Input
}], skipLocationChange: [{
  type: import_core.Input
}], replaceUrl: [{
  type: import_core.Input
}], routerLink: [{
  type: import_core.Input
}], onClick: [{
  type: import_core.HostListener,
  args: ["click"]
}] } });
class RouterLinkWithHref {
  constructor(router, route, locationStrategy) {
    this.router = router;
    this.route = route;
    this.locationStrategy = locationStrategy;
    this._preserveFragment = false;
    this._skipLocationChange = false;
    this._replaceUrl = false;
    this.commands = null;
    this.href = null;
    this.onChanges = new import_rxjs.Subject();
    this.subscription = router.events.subscribe((s) => {
      if (s instanceof NavigationEnd) {
        this.updateTargetUrlAndHref();
      }
    });
  }
  set preserveFragment(preserveFragment) {
    this._preserveFragment = (0, import_core.\u0275coerceToBoolean)(preserveFragment);
  }
  get preserveFragment() {
    return this._preserveFragment;
  }
  set skipLocationChange(skipLocationChange) {
    this._skipLocationChange = (0, import_core.\u0275coerceToBoolean)(skipLocationChange);
  }
  get skipLocationChange() {
    return this._skipLocationChange;
  }
  set replaceUrl(replaceUrl) {
    this._replaceUrl = (0, import_core.\u0275coerceToBoolean)(replaceUrl);
  }
  get replaceUrl() {
    return this._replaceUrl;
  }
  set routerLink(commands) {
    if (commands != null) {
      this.commands = Array.isArray(commands) ? commands : [commands];
    } else {
      this.commands = null;
    }
  }
  ngOnChanges(changes) {
    this.updateTargetUrlAndHref();
    this.onChanges.next(this);
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  onClick(button, ctrlKey, shiftKey, altKey, metaKey) {
    if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {
      return true;
    }
    if (typeof this.target === "string" && this.target != "_self" || this.urlTree === null) {
      return true;
    }
    const extras = {
      skipLocationChange: this.skipLocationChange,
      replaceUrl: this.replaceUrl,
      state: this.state
    };
    this.router.navigateByUrl(this.urlTree, extras);
    return false;
  }
  updateTargetUrlAndHref() {
    this.href = this.urlTree !== null ? this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null;
  }
  get urlTree() {
    if (this.commands === null) {
      return null;
    }
    return this.router.createUrlTree(this.commands, {
      relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route,
      queryParams: this.queryParams,
      fragment: this.fragment,
      queryParamsHandling: this.queryParamsHandling,
      preserveFragment: this.preserveFragment
    });
  }
}
RouterLinkWithHref.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterLinkWithHref, deps: [{ token: Router }, { token: ActivatedRoute }, { token: i3.LocationStrategy }], target: i0.\u0275\u0275FactoryTarget.Directive });
RouterLinkWithHref.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "14.3.0", type: RouterLinkWithHref, isStandalone: true, selector: "a[routerLink],area[routerLink]", inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", state: "state", relativeTo: "relativeTo", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", routerLink: "routerLink" }, host: { listeners: { "click": "onClick($event.button,$event.ctrlKey,$event.shiftKey,$event.altKey,$event.metaKey)" }, properties: { "attr.target": "this.target", "attr.href": "this.href" } }, usesOnChanges: true, ngImport: i0 });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterLinkWithHref, decorators: [{
  type: import_core.Directive,
  args: [{ selector: "a[routerLink],area[routerLink]", standalone: true }]
}], ctorParameters: function() {
  return [{ type: Router }, { type: ActivatedRoute }, { type: i3.LocationStrategy }];
}, propDecorators: { target: [{
  type: import_core.HostBinding,
  args: ["attr.target"]
}, {
  type: import_core.Input
}], queryParams: [{
  type: import_core.Input
}], fragment: [{
  type: import_core.Input
}], queryParamsHandling: [{
  type: import_core.Input
}], state: [{
  type: import_core.Input
}], relativeTo: [{
  type: import_core.Input
}], href: [{
  type: import_core.HostBinding,
  args: ["attr.href"]
}], preserveFragment: [{
  type: import_core.Input
}], skipLocationChange: [{
  type: import_core.Input
}], replaceUrl: [{
  type: import_core.Input
}], routerLink: [{
  type: import_core.Input
}], onClick: [{
  type: import_core.HostListener,
  args: [
    "click",
    ["$event.button", "$event.ctrlKey", "$event.shiftKey", "$event.altKey", "$event.metaKey"]
  ]
}] } });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class RouterLinkActive {
  constructor(router, element, renderer, cdr, link, linkWithHref) {
    this.router = router;
    this.element = element;
    this.renderer = renderer;
    this.cdr = cdr;
    this.link = link;
    this.linkWithHref = linkWithHref;
    this.classes = [];
    this.isActive = false;
    this.routerLinkActiveOptions = { exact: false };
    this.isActiveChange = new import_core.EventEmitter();
    this.routerEventsSubscription = router.events.subscribe((s) => {
      if (s instanceof NavigationEnd) {
        this.update();
      }
    });
  }
  ngAfterContentInit() {
    (0, import_rxjs.of)(this.links.changes, this.linksWithHrefs.changes, (0, import_rxjs.of)(null)).pipe((0, import_operators.mergeAll)()).subscribe((_) => {
      this.update();
      this.subscribeToEachLinkOnChanges();
    });
  }
  subscribeToEachLinkOnChanges() {
    var _a;
    (_a = this.linkInputChangesSubscription) == null ? void 0 : _a.unsubscribe();
    const allLinkChanges = [...this.links.toArray(), ...this.linksWithHrefs.toArray(), this.link, this.linkWithHref].filter((link) => !!link).map((link) => link.onChanges);
    this.linkInputChangesSubscription = (0, import_rxjs.from)(allLinkChanges).pipe((0, import_operators.mergeAll)()).subscribe((link) => {
      if (this.isActive !== this.isLinkActive(this.router)(link)) {
        this.update();
      }
    });
  }
  set routerLinkActive(data) {
    const classes = Array.isArray(data) ? data : data.split(" ");
    this.classes = classes.filter((c) => !!c);
  }
  ngOnChanges(changes) {
    this.update();
  }
  ngOnDestroy() {
    var _a;
    this.routerEventsSubscription.unsubscribe();
    (_a = this.linkInputChangesSubscription) == null ? void 0 : _a.unsubscribe();
  }
  update() {
    if (!this.links || !this.linksWithHrefs || !this.router.navigated)
      return;
    Promise.resolve().then(() => {
      const hasActiveLinks = this.hasActiveLinks();
      if (this.isActive !== hasActiveLinks) {
        this.isActive = hasActiveLinks;
        this.cdr.markForCheck();
        this.classes.forEach((c) => {
          if (hasActiveLinks) {
            this.renderer.addClass(this.element.nativeElement, c);
          } else {
            this.renderer.removeClass(this.element.nativeElement, c);
          }
        });
        if (hasActiveLinks && this.ariaCurrentWhenActive !== void 0) {
          this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString());
        } else {
          this.renderer.removeAttribute(this.element.nativeElement, "aria-current");
        }
        this.isActiveChange.emit(hasActiveLinks);
      }
    });
  }
  isLinkActive(router) {
    const options = isActiveMatchOptions(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || false;
    return (link) => link.urlTree ? router.isActive(link.urlTree, options) : false;
  }
  hasActiveLinks() {
    const isActiveCheckFn = this.isLinkActive(this.router);
    return this.link && isActiveCheckFn(this.link) || this.linkWithHref && isActiveCheckFn(this.linkWithHref) || this.links.some(isActiveCheckFn) || this.linksWithHrefs.some(isActiveCheckFn);
  }
}
RouterLinkActive.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterLinkActive, deps: [{ token: Router }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: RouterLink, optional: true }, { token: RouterLinkWithHref, optional: true }], target: i0.\u0275\u0275FactoryTarget.Directive });
RouterLinkActive.\u0275dir = i0.\u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "14.3.0", type: RouterLinkActive, isStandalone: true, selector: "[routerLinkActive]", inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", ariaCurrentWhenActive: "ariaCurrentWhenActive", routerLinkActive: "routerLinkActive" }, outputs: { isActiveChange: "isActiveChange" }, queries: [{ propertyName: "links", predicate: RouterLink, descendants: true }, { propertyName: "linksWithHrefs", predicate: RouterLinkWithHref, descendants: true }], exportAs: ["routerLinkActive"], usesOnChanges: true, ngImport: i0 });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterLinkActive, decorators: [{
  type: import_core.Directive,
  args: [{
    selector: "[routerLinkActive]",
    exportAs: "routerLinkActive",
    standalone: true
  }]
}], ctorParameters: function() {
  return [{ type: Router }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: RouterLink, decorators: [{
    type: import_core.Optional
  }] }, { type: RouterLinkWithHref, decorators: [{
    type: import_core.Optional
  }] }];
}, propDecorators: { links: [{
  type: import_core.ContentChildren,
  args: [RouterLink, { descendants: true }]
}], linksWithHrefs: [{
  type: import_core.ContentChildren,
  args: [RouterLinkWithHref, { descendants: true }]
}], routerLinkActiveOptions: [{
  type: import_core.Input
}], ariaCurrentWhenActive: [{
  type: import_core.Input
}], isActiveChange: [{
  type: import_core.Output
}], routerLinkActive: [{
  type: import_core.Input
}] } });
function isActiveMatchOptions(options) {
  return !!options.paths;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class PreloadingStrategy {
}
class PreloadAllModules {
  preload(route, fn) {
    return fn().pipe((0, import_operators.catchError)(() => (0, import_rxjs.of)(null)));
  }
}
PreloadAllModules.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: PreloadAllModules, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable });
PreloadAllModules.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: PreloadAllModules, providedIn: "root" });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: PreloadAllModules, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root" }]
}] });
class NoPreloading {
  preload(route, fn) {
    return (0, import_rxjs.of)(null);
  }
}
NoPreloading.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: NoPreloading, deps: [], target: i0.\u0275\u0275FactoryTarget.Injectable });
NoPreloading.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: NoPreloading, providedIn: "root" });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: NoPreloading, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root" }]
}] });
class RouterPreloader {
  constructor(router, compiler, injector, preloadingStrategy, loader) {
    this.router = router;
    this.injector = injector;
    this.preloadingStrategy = preloadingStrategy;
    this.loader = loader;
  }
  setUpPreloading() {
    this.subscription = this.router.events.pipe((0, import_operators.filter)((e) => e instanceof NavigationEnd), (0, import_operators.concatMap)(() => this.preload())).subscribe(() => {
    });
  }
  preload() {
    return this.processRoutes(this.injector, this.router.config);
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  processRoutes(injector, routes) {
    var _a, _b, _c;
    const res = [];
    for (const route of routes) {
      if (route.providers && !route._injector) {
        route._injector = (0, import_core.createEnvironmentInjector)(route.providers, injector, `Route: ${route.path}`);
      }
      const injectorForCurrentRoute = (_a = route._injector) != null ? _a : injector;
      const injectorForChildren = (_b = route._loadedInjector) != null ? _b : injectorForCurrentRoute;
      if (route.loadChildren && !route._loadedRoutes && route.canLoad === void 0 || route.loadComponent && !route._loadedComponent) {
        res.push(this.preloadConfig(injectorForCurrentRoute, route));
      } else if (route.children || route._loadedRoutes) {
        res.push(this.processRoutes(injectorForChildren, (_c = route.children) != null ? _c : route._loadedRoutes));
      }
    }
    return (0, import_rxjs.from)(res).pipe((0, import_operators.mergeAll)());
  }
  preloadConfig(injector, route) {
    return this.preloadingStrategy.preload(route, () => {
      let loadedChildren$;
      if (route.loadChildren && route.canLoad === void 0) {
        loadedChildren$ = this.loader.loadChildren(injector, route);
      } else {
        loadedChildren$ = (0, import_rxjs.of)(null);
      }
      const recursiveLoadChildren$ = loadedChildren$.pipe((0, import_operators.mergeMap)((config) => {
        var _a;
        if (config === null) {
          return (0, import_rxjs.of)(void 0);
        }
        route._loadedRoutes = config.routes;
        route._loadedInjector = config.injector;
        return this.processRoutes((_a = config.injector) != null ? _a : injector, config.routes);
      }));
      if (route.loadComponent && !route._loadedComponent) {
        const loadComponent$ = this.loader.loadComponent(route);
        return (0, import_rxjs.from)([recursiveLoadChildren$, loadComponent$]).pipe((0, import_operators.mergeAll)());
      } else {
        return recursiveLoadChildren$;
      }
    });
  }
}
RouterPreloader.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterPreloader, deps: [{ token: Router }, { token: i0.Compiler }, { token: i0.EnvironmentInjector }, { token: PreloadingStrategy }, { token: RouterConfigLoader }], target: i0.\u0275\u0275FactoryTarget.Injectable });
RouterPreloader.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterPreloader, providedIn: "root" });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterPreloader, decorators: [{
  type: import_core.Injectable,
  args: [{ providedIn: "root" }]
}], ctorParameters: function() {
  return [{ type: Router }, { type: i0.Compiler }, { type: i0.EnvironmentInjector }, { type: PreloadingStrategy }, { type: RouterConfigLoader }];
} });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const ROUTER_SCROLLER = new import_core.InjectionToken("");
class RouterScroller {
  constructor(router, viewportScroller, options = {}) {
    this.router = router;
    this.viewportScroller = viewportScroller;
    this.options = options;
    this.lastId = 0;
    this.lastSource = "imperative";
    this.restoredId = 0;
    this.store = {};
    options.scrollPositionRestoration = options.scrollPositionRestoration || "disabled";
    options.anchorScrolling = options.anchorScrolling || "disabled";
  }
  init() {
    if (this.options.scrollPositionRestoration !== "disabled") {
      this.viewportScroller.setHistoryScrollRestoration("manual");
    }
    this.routerEventsSubscription = this.createScrollEvents();
    this.scrollEventsSubscription = this.consumeScrollEvents();
  }
  createScrollEvents() {
    return this.router.events.subscribe((e) => {
      if (e instanceof NavigationStart) {
        this.store[this.lastId] = this.viewportScroller.getScrollPosition();
        this.lastSource = e.navigationTrigger;
        this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;
      } else if (e instanceof NavigationEnd) {
        this.lastId = e.id;
        this.scheduleScrollEvent(e, this.router.parseUrl(e.urlAfterRedirects).fragment);
      }
    });
  }
  consumeScrollEvents() {
    return this.router.events.subscribe((e) => {
      if (!(e instanceof Scroll))
        return;
      if (e.position) {
        if (this.options.scrollPositionRestoration === "top") {
          this.viewportScroller.scrollToPosition([0, 0]);
        } else if (this.options.scrollPositionRestoration === "enabled") {
          this.viewportScroller.scrollToPosition(e.position);
        }
      } else {
        if (e.anchor && this.options.anchorScrolling === "enabled") {
          this.viewportScroller.scrollToAnchor(e.anchor);
        } else if (this.options.scrollPositionRestoration !== "disabled") {
          this.viewportScroller.scrollToPosition([0, 0]);
        }
      }
    });
  }
  scheduleScrollEvent(routerEvent, anchor) {
    this.router.triggerEvent(new Scroll(routerEvent, this.lastSource === "popstate" ? this.store[this.restoredId] : null, anchor));
  }
  ngOnDestroy() {
    if (this.routerEventsSubscription) {
      this.routerEventsSubscription.unsubscribe();
    }
    if (this.scrollEventsSubscription) {
      this.scrollEventsSubscription.unsubscribe();
    }
  }
}
RouterScroller.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterScroller, deps: "invalid", target: i0.\u0275\u0275FactoryTarget.Injectable });
RouterScroller.\u0275prov = i0.\u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterScroller });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterScroller, decorators: [{
  type: import_core.Injectable
}], ctorParameters: function() {
  return [{ type: Router }, { type: i3.ViewportScroller }, { type: void 0 }];
} });
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NG_DEV_MODE$1 = typeof ngDevMode === "undefined" || ngDevMode;
function provideRouter(routes, ...features) {
  return [
    provideRoutes(routes),
    { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },
    { provide: import_core.APP_BOOTSTRAP_LISTENER, multi: true, useFactory: getBootstrapListener },
    features.map((feature) => feature.\u0275providers)
  ];
}
function rootRoute(router) {
  return router.routerState.root;
}
function routerFeature(kind, providers) {
  return { \u0275kind: kind, \u0275providers: providers };
}
function provideRoutes(routes) {
  return [
    { provide: ROUTES, multi: true, useValue: routes }
  ];
}
function withInMemoryScrolling(options = {}) {
  const providers = [{
    provide: ROUTER_SCROLLER,
    useFactory: () => {
      const router = (0, import_core.inject)(Router);
      const viewportScroller = (0, import_core.inject)(import_common.ViewportScroller);
      return new RouterScroller(router, viewportScroller, options);
    }
  }];
  return routerFeature(4, providers);
}
function getBootstrapListener() {
  const injector = (0, import_core.inject)(import_core.Injector);
  return (bootstrappedComponentRef) => {
    var _a, _b;
    const ref = injector.get(import_core.ApplicationRef);
    if (bootstrappedComponentRef !== ref.components[0]) {
      return;
    }
    const router = injector.get(Router);
    const bootstrapDone = injector.get(BOOTSTRAP_DONE);
    if (injector.get(INITIAL_NAVIGATION) === 1) {
      router.initialNavigation();
    }
    (_a = injector.get(ROUTER_PRELOADER, null, import_core.InjectFlags.Optional)) == null ? void 0 : _a.setUpPreloading();
    (_b = injector.get(ROUTER_SCROLLER, null, import_core.InjectFlags.Optional)) == null ? void 0 : _b.init();
    router.resetRootComponentType(ref.componentTypes[0]);
    if (!bootstrapDone.closed) {
      bootstrapDone.next();
      bootstrapDone.unsubscribe();
    }
  };
}
const BOOTSTRAP_DONE = new import_core.InjectionToken(NG_DEV_MODE$1 ? "bootstrap done indicator" : "", {
  factory: () => {
    return new import_rxjs.Subject();
  }
});
const INITIAL_NAVIGATION = new import_core.InjectionToken(NG_DEV_MODE$1 ? "initial navigation" : "", { providedIn: "root", factory: () => 1 });
function withEnabledBlockingInitialNavigation() {
  const providers = [
    { provide: INITIAL_NAVIGATION, useValue: 0 },
    {
      provide: import_core.APP_INITIALIZER,
      multi: true,
      deps: [import_core.Injector],
      useFactory: (injector) => {
        const locationInitialized = injector.get(import_common.LOCATION_INITIALIZED, Promise.resolve());
        let initNavigation = false;
        function afterNextNavigation(action) {
          const router = injector.get(Router);
          router.events.pipe((0, import_operators.filter)((e) => e instanceof NavigationEnd || e instanceof NavigationCancel || e instanceof NavigationError), (0, import_operators.map)((e) => {
            if (e instanceof NavigationEnd) {
              return true;
            }
            const redirecting = e instanceof NavigationCancel ? e.code === 0 || e.code === 1 : false;
            return redirecting ? null : false;
          }), (0, import_operators.filter)((result) => result !== null), (0, import_operators.take)(1)).subscribe(() => {
            action();
          });
        }
        return () => {
          return locationInitialized.then(() => {
            return new Promise((resolve) => {
              const router = injector.get(Router);
              const bootstrapDone = injector.get(BOOTSTRAP_DONE);
              afterNextNavigation(() => {
                resolve(true);
                initNavigation = true;
              });
              router.afterPreactivation = () => {
                resolve(true);
                if (!initNavigation) {
                  return bootstrapDone.closed ? (0, import_rxjs.of)(void 0) : bootstrapDone;
                } else {
                  return (0, import_rxjs.of)(void 0);
                }
              };
              router.initialNavigation();
            });
          });
        };
      }
    }
  ];
  return routerFeature(2, providers);
}
function withDisabledInitialNavigation() {
  const providers = [
    {
      provide: import_core.APP_INITIALIZER,
      multi: true,
      useFactory: () => {
        const router = (0, import_core.inject)(Router);
        return () => {
          router.setUpLocationChangeListener();
        };
      }
    },
    { provide: INITIAL_NAVIGATION, useValue: 2 }
  ];
  return routerFeature(3, providers);
}
function withDebugTracing() {
  let providers = [];
  if (NG_DEV_MODE$1) {
    providers = [{
      provide: import_core.ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const router = (0, import_core.inject)(Router);
        return () => router.events.subscribe((e) => {
          var _a, _b;
          (_a = console.group) == null ? void 0 : _a.call(console, `Router Event: ${e.constructor.name}`);
          console.log(stringifyEvent(e));
          console.log(e);
          (_b = console.groupEnd) == null ? void 0 : _b.call(console);
        });
      }
    }];
  } else {
    providers = [];
  }
  return routerFeature(1, providers);
}
const ROUTER_PRELOADER = new import_core.InjectionToken(NG_DEV_MODE$1 ? "router preloader" : "");
function withPreloading(preloadingStrategy) {
  const providers = [
    { provide: ROUTER_PRELOADER, useExisting: RouterPreloader },
    { provide: PreloadingStrategy, useExisting: preloadingStrategy }
  ];
  return routerFeature(0, providers);
}
function withRouterConfig(options) {
  const providers = [
    { provide: ROUTER_CONFIGURATION, useValue: options }
  ];
  return routerFeature(5, providers);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const NG_DEV_MODE = typeof ngDevMode === "undefined" || ngDevMode;
const ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, \u0275EmptyOutletComponent];
const ROUTER_FORROOT_GUARD = new import_core.InjectionToken(NG_DEV_MODE ? "router duplicate forRoot guard" : "ROUTER_FORROOT_GUARD");
const ROUTER_PROVIDERS = [
  import_common.Location,
  { provide: UrlSerializer, useClass: DefaultUrlSerializer },
  { provide: Router, useFactory: setupRouter },
  ChildrenOutletContexts,
  { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },
  RouterConfigLoader
];
function routerNgProbeToken() {
  return new import_core.NgProbeToken("Router", Router);
}
class RouterModule {
  constructor(guard) {
  }
  static forRoot(routes, config) {
    return {
      ngModule: RouterModule,
      providers: [
        ROUTER_PROVIDERS,
        NG_DEV_MODE ? (config == null ? void 0 : config.enableTracing) ? withDebugTracing().\u0275providers : [] : [],
        provideRoutes(routes),
        {
          provide: ROUTER_FORROOT_GUARD,
          useFactory: provideForRootGuard,
          deps: [[Router, new import_core.Optional(), new import_core.SkipSelf()]]
        },
        { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },
        (config == null ? void 0 : config.useHash) ? provideHashLocationStrategy() : providePathLocationStrategy(),
        provideRouterScroller(),
        (config == null ? void 0 : config.preloadingStrategy) ? withPreloading(config.preloadingStrategy).\u0275providers : [],
        { provide: import_core.NgProbeToken, multi: true, useFactory: routerNgProbeToken },
        (config == null ? void 0 : config.initialNavigation) ? provideInitialNavigation(config) : [],
        provideRouterInitializer()
      ]
    };
  }
  static forChild(routes) {
    return { ngModule: RouterModule, providers: [provideRoutes(routes)] };
  }
}
RouterModule.\u0275fac = i0.\u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterModule, deps: [{ token: ROUTER_FORROOT_GUARD, optional: true }], target: i0.\u0275\u0275FactoryTarget.NgModule });
RouterModule.\u0275mod = i0.\u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "14.3.0", ngImport: i0, type: RouterModule, imports: [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, \u0275EmptyOutletComponent], exports: [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, \u0275EmptyOutletComponent] });
RouterModule.\u0275inj = i0.\u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterModule, imports: [\u0275EmptyOutletComponent] });
i0.\u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: RouterModule, decorators: [{
  type: import_core.NgModule,
  args: [{
    imports: ROUTER_DIRECTIVES,
    exports: ROUTER_DIRECTIVES
  }]
}], ctorParameters: function() {
  return [{ type: void 0, decorators: [{
    type: import_core.Optional
  }, {
    type: import_core.Inject,
    args: [ROUTER_FORROOT_GUARD]
  }] }];
} });
function provideRouterScroller() {
  return {
    provide: ROUTER_SCROLLER,
    useFactory: () => {
      const router = (0, import_core.inject)(Router);
      const viewportScroller = (0, import_core.inject)(import_common.ViewportScroller);
      const config = (0, import_core.inject)(ROUTER_CONFIGURATION);
      if (config.scrollOffset) {
        viewportScroller.setOffset(config.scrollOffset);
      }
      return new RouterScroller(router, viewportScroller, config);
    }
  };
}
function provideHashLocationStrategy() {
  return { provide: import_common.LocationStrategy, useClass: import_common.HashLocationStrategy };
}
function providePathLocationStrategy() {
  return { provide: import_common.LocationStrategy, useClass: import_common.PathLocationStrategy };
}
function provideForRootGuard(router) {
  if (NG_DEV_MODE && router) {
    throw new import_core.\u0275RuntimeError(4007, `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.`);
  }
  return "guarded";
}
function provideInitialNavigation(config) {
  return [
    config.initialNavigation === "disabled" ? withDisabledInitialNavigation().\u0275providers : [],
    config.initialNavigation === "enabledBlocking" ? withEnabledBlockingInitialNavigation().\u0275providers : []
  ];
}
const ROUTER_INITIALIZER = new import_core.InjectionToken(NG_DEV_MODE ? "Router Initializer" : "");
function provideRouterInitializer() {
  return [
    { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener },
    { provide: import_core.APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER }
  ];
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const VERSION = new import_core.Version("14.3.0");
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
